<page>
  <title>Wagmi | Reactivity for Ethereum apps</title>
  <url>https://wagmi.sh/</url>
  <content>[Skip to content](#VPContent)

Main Navigation [React](https://wagmi.sh/react/getting-started)[Vue](https://wagmi.sh/vue/getting-started)[Core](https://wagmi.sh/core/getting-started)[CLI](https://wagmi.sh/cli/getting-started)

[Discussions](https://github.com/wevm/wagmi/discussions)

[Release Notes](https://github.com/wevm/wagmi/releases)

[Contributing](https://wagmi.sh/dev/contributing)

[](https://warpcast.com/wevm)

Appearance

[](https://warpcast.com/wevm)

Looking for the 1.x docs? Check out [1.x.wagmi.sh](https://1.x.wagmi.sh/).

Reactivity for Ethereum apps

Type Safe, Extensible, and Modular by design. Build high-performance blockchain frontends.

[Get Started](https://wagmi.sh/react/getting-started)

[Why Wagmi](https://wagmi.sh/react/why)

[View on GitHub](https://github.com/wevm/wagmi)

[

üöÄ

20+ React Hooks
---------------

React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more.

See all hooks



](https://wagmi.sh/react/api/hooks)

[

ü¶Ñ

TypeScript Ready
----------------

Infer types from ABIs and EIP-712 Typed Data and autocomplete your way to productivity.

Learn about TypeScript support



](https://wagmi.sh/react/typescript)

[

üíº

Connect Wallet
--------------

Official connectors for MetaMask, EIP-6963, WalletConnect, Coinbase Wallet, and more.

See all connectors



](https://wagmi.sh/react/api/connectors)

[

üëü

Caching. Deduplication. Persistence.
------------------------------------

Built-in caching, deduplication, persistence powered by TanStack Query.

How to use TanStack Query



](https://wagmi.sh/react/guides/tanstack-query)

[

üå≥

Modular By Design
-----------------

Don't use React or Vue? Use VanillaJS or build an adapter for your favorite framework.

Learn about Wagmi Core



](https://wagmi.sh/core/getting-started)

[

‚úåÔ∏è

Built on Viem
-------------

The modern, low-level TypeScript interface for Ethereum that performs blockchain operations.

Check out Viem



](https://viem.sh/)

Meet The Team
-------------

tmm
---

[](https://warpcast.com/awkweb)

jxom
----

[](https://warpcast.com/jxom)

Sponsored by
------------

[Become a sponsor](https://github.com/sponsors/wevm)</content>
</page>

<page>
  <title>Getting Started | Wagmi</title>
  <url>https://wagmi.sh/react/getting-started</url>
  <content>Overview [‚Äã](#overview)
-----------------------

Wagmi is a React Hooks library for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](https://wagmi.sh/react/why) section.

Automatic Installation [‚Äã](#automatic-installation)
---------------------------------------------------

For new projects, it is recommended to set up your Wagmi app using the [`create-wagmi`](https://wagmi.sh/cli/create-wagmi) command line interface (CLI). This will create a new Wagmi project using TypeScript and install the required dependencies.

pnpmnpmyarnbun

bash

    npm create wagmi@latest

Once the command runs, you'll see some prompts to complete.

    Project name: wagmi-project
    Select a framework: React / Vanilla
    ...

After the prompts, `create-wagmi` will create a directory with your project name and install the required dependencies. Check out the `README.md` for further instructions (if required).

Manual Installation [‚Äã](#manual-installation)
---------------------------------------------

To manually add Wagmi to your project, install the required packages.

pnpmnpmyarnbun

bash

    pnpm add wagmi viem@2.x @tanstack/react-query

bash

    npm install wagmi viem@2.x @tanstack/react-query

bash

    yarn add wagmi viem@2.x @tanstack/react-query

bash

    bun add wagmi viem@2.x @tanstack/react-query

*   [Viem](https://viem.sh/) is a TypeScript interface for Ethereum that performs blockchain operations.
*   [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
*   [TypeScript](https://wagmi.sh/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](https://wagmi.sh/react/typescript).

### Create Config [‚Äã](#create-config)

Create and export a new Wagmi config using `createConfig`.

config.ts

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

In this example, Wagmi is configured to use the Mainnet and Sepolia chains, and `injected` connector. Check out the [`createConfig` docs](https://wagmi.sh/react/api/createConfig) for more configuration options.

TypeScript Tip

If you are using TypeScript, you can "register" the Wagmi config or use the hook `config` property to get strong type-safety across React Context in places that wouldn't normally have type info.

register confighook config property

ts

    import {  } from 'wagmi'
    
    ({ chainId: 123 })Type '123' is not assignable to type '1 | 11155111 | undefined'.
    declare module 'wagmi' {
      interface Register {
        : typeof 
      }
    }

ts

    import {  } from 'wagmi'
    
    ({ chainId: 123,  })Type '123' is not assignable to type '1 | 11155111 | undefined'.

By registering or using the hook `config` property, `useBlockNumber`'s `chainId` is strongly typed to only allow Mainnet and Sepolia IDs. Learn more by reading the [TypeScript docs](https://wagmi.sh/react/typescript#config-types).

### Wrap App in Context Provider [‚Äã](#wrap-app-in-context-provider)

Wrap your app in the `WagmiProvider` React Context Provider and pass the `config` you created earlier to the `value` property.

app.tsxconfig.ts

tsx

    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    function App() {
      return (
        <WagmiProvider config={config}>
          {/** ... */}
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Check out the [`WagmiProvider` docs](https://wagmi.sh/react/api/WagmiProvider) to learn more about React Context in Wagmi.

### Setup TanStack Query [‚Äã](#setup-tanstack-query)

Inside the `WagmiProvider`, wrap your app in a TanStack Query React Context Provider, e.g. `QueryClientProvider`, and pass a new `QueryClient` instance to the `client` property.

app.tsxconfig.ts

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    const queryClient = new QueryClient()
    
    function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            {/** ... */}
          </QueryClientProvider>
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Check out the [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/react) to learn about the library, APIs, and more.

### Use Wagmi [‚Äã](#use-wagmi)

Now that everything is set up, every component inside the Wagmi and TanStack Query Providers can use Wagmi React Hooks.

profile.tsxapp.tsxconfig.ts

tsx

    import { useAccount, useEnsName } from 'wagmi'
    
    export function Profile() {
      const { address } = useAccount()
      const { data, error, status } = useEnsName({ address })
      if (status === 'pending') return <div>Loading ENS name</div>
      if (status === 'error')
        return <div>Error fetching ENS name: {error.message}</div>
      return <div>ENS name: {data}</div>
    }

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    import { Profile } from './profile'
    
    const queryClient = new QueryClient()
    
    function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            <Profile />
          </QueryClientProvider>
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Next Steps [‚Äã](#next-steps)
---------------------------

For more information on what to do next, check out the following topics.

*   [**TypeScript**](https://wagmi.sh/react/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
*   [**Connect Wallet**](https://wagmi.sh/react/guides/connect-wallet) Learn how to enable wallets to connect to and disconnect from your apps and display information about connected accounts.
*   [**React Hooks**](https://wagmi.sh/react/api/hooks) Browse the collection of React Hooks and learn how to use them.
*   [**Viem**](https://wagmi.sh/react/guides/viem) Learn about Viem and how it works with Wagmi.</content>
</page>

<page>
  <title>Connectors | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors</url>
  <content>Released under the [MIT License](https://github.com/wevm/wagmi/blob/main/LICENSE).

Copyright ¬© 2022-present Weth, LLC</content>
</page>

<page>
  <title>Hooks | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks</url>
  <content>Released under the [MIT License](https://github.com/wevm/wagmi/blob/main/LICENSE).

Copyright ¬© 2022-present Weth, LLC</content>
</page>

<page>
  <title>Getting Started | Wagmi</title>
  <url>https://wagmi.sh/core/getting-started</url>
  <content>Overview [‚Äã](#overview)
-----------------------

Wagmi Core is a VanillaJS library for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](https://wagmi.sh/core/why) section.

Manual Installation [‚Äã](#manual-installation)
---------------------------------------------

To manually add Wagmi to your project, install the required packages.

pnpmnpmyarnbun

bash

    pnpm add @wagmi/core @wagmi/connectors viem@2.x

bash

    npm install @wagmi/core @wagmi/connectors viem@2.x

bash

    yarn add @wagmi/core @wagmi/connectors viem@2.x

bash

    bun add @wagmi/core @wagmi/connectors viem@2.x

*   [Wagmi Connectors](https://wagmi.sh/core/api/connectors) is a collection of interfaces for linking accounts/wallets to Wagmi.
*   [Viem](https://viem.sh/) is a TypeScript interface for Ethereum that performs blockchain operations.
*   [TypeScript](https://wagmi.sh/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](https://wagmi.sh/core/typescript).

### Create Config [‚Äã](#create-config)

Create and export a new Wagmi config using `createConfig`.

config.ts

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

In this example, Wagmi is configured to use the Mainnet and Sepolia chains. Check out the [`createConfig` docs](https://wagmi.sh/core/api/createConfig) for more configuration options.

### Use Wagmi [‚Äã](#use-wagmi)

Now that everything is set up, you can pass the `config` to use actions.

index.tsconfig.ts

tsx

    import { getAccount, getEnsName } from '@wagmi/core'
    import { config } from './config'
    
    const { address } = getAccount(config)
    const ensName = await getEnsName(config, { address })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Next Steps [‚Äã](#next-steps)
---------------------------

For more information on what to do next, check out the following topics.

*   [**TypeScript**](https://wagmi.sh/core/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
*   [**Actions**](https://wagmi.sh/core/api/actions) Browse the collection of actions and learn how to use them.
*   [**Framework Adapters**](https://wagmi.sh/core/guides/framework-adapters) Learn how to create a Wagmi-like adapter for your favorite framework.
*   [**Viem docs**](https://viem.sh/) Wagmi Core is a wrapper around Viem that manages account and client reactivity. Learn more about Viem and how to use it.</content>
</page>

<page>
  <title>Getting Started | Wagmi</title>
  <url>https://wagmi.sh/cli/getting-started</url>
  <content>Overview [‚Äã](#overview)
-----------------------

Wagmi CLI is a command line interface for managing ABIs (from Etherscan/block explorers, Foundry/Hardhat projects, etc.), generating code (e.g. React Hooks), and much more. It makes working with Ethereum easier by automating manual work so you can build faster. You can learn more about the rationale behind the project in the [Why Wagmi CLI](https://wagmi.sh/cli/why) section.

Manual Installation [‚Äã](#manual-installation)
---------------------------------------------

To manually add Wagmi CLI to your project, install the required packages.

pnpmnpmyarnbun

bash

    pnpm add -D @wagmi/cli

bash

    npm install --save-dev @wagmi/cli

bash

    yarn add -D @wagmi/cli

bash

    bun add -D @wagmi/cli

Create Config File [‚Äã](#create-config-file)
-------------------------------------------

Run the `init` command to generate a configuration file: either `wagmi.config.ts` if TypeScript is detected, otherwise `wagmi.config.js`. You can also create the configuration file manually. See [Configuring CLI](https://wagmi.sh/cli/config/configuring-cli) for more info.

The generated configuration file will look something like this:

wagmi.config.ts

ts

    import { defineConfig } from '@wagmi/cli'
    
    export default defineConfig({
      out: 'src/generated.ts',
      contracts: [],
      plugins: [],
    })

Add Contracts And Plugins [‚Äã](#add-contracts-and-plugins)
---------------------------------------------------------

Once the configuration file is set up, you can add contracts and plugins to it. These contracts and plugins are used to manage ABIs (fetch from block explorers, resolve from the file system, etc.), generate code (React hooks, etc.), and much more!

For example, we can add the ERC-20 contract from Viem, and the [`etherscan`](https://wagmi.sh/cli/api/plugins/etherscan) and [`react`](https://wagmi.sh/cli/api/plugins/react) plugins.

wagmi.config.ts

ts

    import { defineConfig } from '@wagmi/cli'
    import { etherscan, react } from '@wagmi/cli/plugins'
    import { erc20Abi } from 'viem'
    import { mainnet, sepolia } from 'wagmi/chains'
     
    export default defineConfig({
      out: 'src/generated.ts',
      contracts: [
        {
          name: 'erc20',
          abi: erc20Abi,
        },
      ],
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY!,
          chainId: mainnet.id,
          contracts: [
            {
              name: 'EnsRegistry',
              address: {
                [mainnet.id]: '0x314159265dd8dbb310642f98f50c066173c1259b',
                [sepolia.id]: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
              },
            },
          ],
        }),
        react(),
      ],
    })

Run Code Generation [‚Äã](#run-code-generation)
---------------------------------------------

Now that we added a few contracts and plugins to the configuration file, we can run the [`generate`](https://wagmi.sh/cli/api/commands/generate) command to resolve ABIs and generate code to the `out` file.

In this example, the `generate` command will do the following:

*   Validate the `etherscan` and `react` plugins
*   Fetch and cache the ENS Registry ABI from the Mainnet Etherscan API
*   Pull in the `erc20Abi` using the name `'ERC20'`
*   Generate React Hooks for both ABIs
*   Save ABIs, ENS Registry deployment addresses, and React Hooks to the `out` file

Use Generated Code [‚Äã](#use-generated-code)
-------------------------------------------

Once `out` is created, you can start using the generated code in your project.

ts

    import { useReadErc20, useReadErc20BalanceOf } from './generated'
    
    // Use the generated ERC-20 read hook
    const { data } = useReadErc20({
      address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
      functionName: 'balanceOf',
      args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    // Use the generated ERC-20 "balanceOf" hook
    const { data } = useReadErc20BalanceOf({
      address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
      args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })

TIP

Instead of committing the `out` file, you likely want to add `out` to your `.gitignore` and run `generate` during the build process or before you start your dev server in a `"predev"` script.

Next Steps [‚Äã](#next-steps)
---------------------------

For more information on what to do next, check out the following topics.

*   [**Configuring CLI**](https://wagmi.sh/cli/config/configuring-cli) Learn how to configure the CLI to work best for your project.
*   [**Commands**](https://wagmi.sh/cli/api/commands) Learn more about the CLI commands and how to use them.
*   [**Plugins**](https://wagmi.sh/cli/api/plugins) Browse the collection of plugins and set them up with your config.</content>
</page>

<page>
  <title>Contributing | Wagmi</title>
  <url>https://wagmi.sh/dev/contributing</url>
  <content>Thanks for your interest in contributing to Wagmi! Please take a moment to review this document **before submitting a pull request.**

Overview [‚Äã](#overview)
-----------------------

This guide is intended to help you get started with contributing. By following these steps, you will understand the development process and workflow. If you want to contribute, but aren't sure where to start, you can create a [new discussion](https://github.com/wevm/wagmi/discussions/new/choose).

WARNING

**Please ask first before starting work on any significant new features. This includes things like adding new hooks, actions, connectors, etc.**

It's never a fun experience to have your pull request declined after investing time and effort into a new feature. To avoid this from happening, we request that contributors first create a [feature request](https://github.com/wevm/wagmi/discussions/new?category=ideas) to discuss any API changes or significant new ideas.

1\. Cloning the repository [‚Äã](#_1-cloning-the-repository)
----------------------------------------------------------

To start contributing to the project, clone it to your local machine using git:

bash

    git clone https://github.com/wevm/wagmi.git

Or the [GitHub CLI](https://cli.github.com/):

bash

    gh repo clone wevm/wagmi

2\. Installing Node.js and pnpm [‚Äã](#_2-installing-node-js-and-pnpm)
--------------------------------------------------------------------

Wagmi uses Node.js with [pnpm workspaces](https://pnpm.io/workspaces) to manage multiple projects. You can run the following command in your terminal to check your local Node.js version.

If **`node@22.x`** is not installed, you can install via [fnm](https://github.com/Schniz/fnm) or from the [official website](https://nodejs.org/).

Once Node.js is installed, run the following to install [Corepack](https://nodejs.org/api/corepack.html). Corepack automatically installs and manages **`pnpm@9.11.0`**.

3\. Installing dependencies [‚Äã](#_3-installing-dependencies)
------------------------------------------------------------

Once in the project's root directory, run the following command to install pnpm (via Corepack) and the project's dependencies:

After the install completes, pnpm links packages across the project for development and [git hooks](https://github.com/toplenboren/simple-git-hooks) are set up.

4\. Adding the env variables [‚Äã](#_4-adding-the-env-variables)
--------------------------------------------------------------

The [dev playgrounds](#_5-running-the-dev-playgrounds) and [test suite](#_6-running-the-test-suite) require environment variables to be set. Copy over the following environment variables to `.env`, and fill them out.

bash

    VITE_MAINNET_FORK_URL=https://eth.merkle.io
    VITE_OPTIMISM_FORK_URL=https://mainnet.optimism.io
    
    NEXT_PUBLIC_WC_PROJECT_ID=3fbb6bba6f1de962d911bb5b5c9dba88
    NUXT_PUBLIC_WC_PROJECT_ID=3fbb6bba6f1de962d911bb5b5c9dba88
    VITE_WC_PROJECT_ID=3fbb6bba6f1de962d911bb5b5c9dba88
    
    NEXT_TELEMETRY_DISABLED=1
    NUXT_TELEMETRY_DISABLED=1

You might want to change `*_FORK_URL` to a paid RPC provider for better performance.

5\. Running the dev playgrounds [‚Äã](#_5-running-the-dev-playgrounds)
--------------------------------------------------------------------

To start the local development playgrounds, run one of the following commands. These commands run playground apps, located at `./playgrounds`, that are set up for trying out code while making changes.

bash

    pnpm dev              # `wagmi` playground
    pnpm dev:core         # `@wagmi/core` playground
    pnpm dev:create-wagmi # `create-wagmi` cli tool
    pnpm dev:cli          # `@wagmi/cli` tool
    pnpm dev:next         # `wagmi` playground with Next.js
    pnpm dev:nuxt         # `@wagmi/vue` playground with Nuxt.js
    pnpm dev:react        # `wagmi` playground (same as `pnpm dev`)
    pnpm dev:vue          # `@wagmi/vue` playground

Once a playground dev server is running, you can make changes to any of the package source files (e.g. `packages/react`) and it will automatically update the playground.

6\. Running the test suite [‚Äã](#_6-running-the-test-suite)
----------------------------------------------------------

Wagmi uses [Vitest](https://vitest.dev/) to run tests and [Prool](https://github.com/wevm/prool) to execute tests against locally running chain forks. First, install [Anvil](https://github.com/foundry-rs/foundry/tree/master/crates/anvil) via [Foundryup](https://book.getfoundry.sh/getting-started/installation).

bash

    curl -L https://foundry.paradigm.xyz | bash
    foundryup

Next, make sure you have set up your [env variables](#_4-adding-the-env-variables). Now you are ready to run the tests! You have the following options for running tests:

*   `pnpm test [package?]` ‚Äî runs tests in watch mode
*   `pnpm test:cov` ‚Äî runs tests and reports coverage
*   `pnpm test:core` ‚Äî runs `@wagmi/core` tests
*   `pnpm test:react` ‚Äî runs `wagmi` tests
*   `pnpm test:vue` ‚Äî runs `@wagmi/vue` tests

When adding new features or fixing bugs, it's important to add test cases to cover the new or updated behavior. If snapshot tests fail, you can run the `test:update` command to update the snapshots.

7\. Writing documentation [‚Äã](#_7-writing-documentation)
--------------------------------------------------------

Documentation is crucial to helping developers of all experience levels use Wagmi. Wagmi uses [VitePress](https://vitepress.dev/) for the documentation site (located at `./site`). To start the site in dev mode, run:

Try to keep documentation brief and use plain language so folks of all experience levels can understand. If you think something is unclear or could be explained better, you are welcome to open a pull request.

8\. Submitting a pull request [‚Äã](#_8-submitting-a-pull-request)
----------------------------------------------------------------

When you're ready to submit a pull request, you can follow these naming conventions:

*   Pull request titles use the [Imperative Mood](https://en.wikipedia.org/wiki/Imperative_mood) (e.g., `Add something`, `Fix something`).
*   [Changesets](#versioning) use past tense verbs (e.g., `Added something`, `Fixed something`).

When you submit a pull request, GitHub will automatically lint, build, and test your changes. If you see an ‚ùå, it's most likely a bug in your code. Please, inspect the logs through the GitHub UI to find the cause.

**Please make sure that "Allow edits from maintainers" is enabled so the core team can make updates to your pull request if necessary.**

9\. Versioning [‚Äã](#_9-versioning)
----------------------------------

When adding new features or fixing bugs, we'll need to bump the package versions. We use [Changesets](https://github.com/changesets/changesets) to do this.

TIP

Only changes to the codebase that affect the public API or existing behavior (e.g. bugs) need changesets.

Each changeset defines which packages should be published and whether the change should be a major/minor/patch release, as well as providing release notes that will be added to the changelog upon release.

To create a new changeset, run `pnpm changeset`. This will run the Changesets CLI, prompting you for details about the change. You‚Äôll be able to edit the file after it‚Äôs created ‚Äî don‚Äôt worry about getting everything perfect up front.

Even though you can technically use any markdown formatting you like, headings should be avoided since each changeset will ultimately be nested within a bullet list. Instead, bold text should be used as section headings.

If your PR is making changes to an area that already has a changeset (e.g. there‚Äôs an existing changeset covering theme API changes but you‚Äôre making further changes to the same API), you should update the existing changeset in your PR rather than creating a new one.

### Releasing to npm [‚Äã](#releasing-to-npm)

The first time a PR with a changeset is merged after a release, a new PR will automatically be created called `chore: version packages`. Any subsequent PRs with changesets will automatically update this existing version packages PR. Merging this PR triggers the release process by publishing to npm and cleaning up the changeset files.

### Creating a snapshot release [‚Äã](#creating-a-snapshot-release)

If a PR has changesets, you can create a [snapshot release](https://github.com/changesets/changesets/blob/main/docs/snapshot-releases.md) by [manually dispatching](https://github.com/wevm/wagmi/actions/workflows/canary.yml) the Canary workflow. This publishes a tagged version to npm with the PR branch name and timestamp.

10\. Updating dependencies [‚Äã](#_10-updating-dependencies)
----------------------------------------------------------

Use [Taze](https://github.com/antfu/taze) by running:

bash

    pnpm deps       # prints outdated deps
    pnpm deps patch # print outdated deps with new patch versions
    pnpm deps -w    # updates deps (best done with clean working tree)

[Socket](https://socket.dev/) checks pull requests for vulnerabilities when new dependencies and versions are added, but you should also be vigilant! When updating dependencies, you should check release notes and source code as well as lock versions when possible.</content>
</page>

<page>
  <title>Why Wagmi | Wagmi</title>
  <url>https://wagmi.sh/react/why</url>
  <content>The Problems [‚Äã](#the-problems)
-------------------------------

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi solves all these problems and more ‚Äî allowing app developers to focus on building high-quality and performant experiences for Ethereum ‚Äî by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

Developer Experience [‚Äã](#developer-experience)
-----------------------------------------------

Wagmi delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi's APIs might seem more verbose at first, it makes Wagmi's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi is a great way to learn how to interact with Ethereum in general.

Wagmi also provides [strongly typed APIs](https://wagmi.sh/react/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](https://wagmi.sh/react/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20\(TDD\),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

Performance [‚Äã](#performance)
-----------------------------

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi uses and is built by the same team behind [Viem](https://viem.sh/), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times.

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi supports caching, deduplication, persistence, and much more through [TanStack Query](https://wagmi.sh/react/guides/tanstack-query).

Feature Coverage [‚Äã](#feature-coverage)
---------------------------------------

Wagmi supports the most popular and commonly-used Ethereum features out of the box with 40+ React Hooks for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi also supports just about any wallet out there through official [connectors](https://wagmi.sh/react/api/connectors), [EIP-6963 support](https://wagmi.sh/react/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](https://wagmi.sh/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Wagmi Core](https://wagmi.sh/core/getting-started) or [Viem](https://viem.sh/), which Wagmi uses internally to perform blockchain operations. Wagmi also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi has a [CLI](https://wagmi.sh/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com/), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz/), [Privy](https://privy.io/), and many more, so you can get started quickly without needing to build everything from scratch.

Stability [‚Äã](#stability)
-------------------------

Stability is a fundamental principle for Wagmi. Many organizations, large and small, rely heavily on Wagmi and expect it to be entirely stable for their users and applications.

Wagmi's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi follows semver so developers can upgrade between versions with confidence. Starting with Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi and [related projects](https://github.com/wevm), and is constantly improving Wagmi and keeping it up-to-date with industry trends and changes.</content>
</page>

<page>
  <title>Getting Started | Wagmi</title>
  <url>https://wagmi.sh/vue/getting-started</url>
  <content>Overview [‚Äã](#overview)
-----------------------

Wagmi is a collection of Vue composition utilities for Ethereum. You can learn more about the rationale behind the project in the [Why Wagmi](https://wagmi.sh/vue/why) section.

Automatic Installation [‚Äã](#automatic-installation)
---------------------------------------------------

For new projects, it is recommended to set up your Wagmi app using the [`create-wagmi`](https://wagmi.sh/cli/create-wagmi) command line interface (CLI). This will create a new Wagmi project using TypeScript and install the required dependencies.

pnpmnpmyarnbun

bash

    npm create wagmi@latest

Once the command runs, you'll see some prompts to complete.

    Project name: wagmi-project
    Select a framework: Vue / Vanilla
    ...

After the prompts, `create-wagmi` will create a directory with your project name and install the required dependencies. Check out the `README.md` for further instructions (if required).

Manual Installation [‚Äã](#manual-installation)
---------------------------------------------

To manually add Wagmi to your project, install the required packages.

pnpmnpmyarnbun

bash

    pnpm add @wagmi/vue viem@2.x @tanstack/vue-query

bash

    npm install @wagmi/vue viem@2.x @tanstack/vue-query

bash

    yarn add @wagmi/vue viem@2.x @tanstack/vue-query

bash

    bun add @wagmi/vue viem@2.x @tanstack/vue-query

*   [Viem](https://viem.sh/) is a TypeScript interface for Ethereum that performs blockchain operations.
*   [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
*   [TypeScript](https://wagmi.sh/vue/typescript) is optional, but highly recommended. Learn more about [TypeScript support](https://wagmi.sh/vue/typescript).

### Create Config [‚Äã](#create-config)

Create and export a new Wagmi config using `createConfig`.

config.ts

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

In this example, Wagmi is configured to use the Mainnet and Sepolia chains, and `injected` connector. Check out the [`createConfig` docs](https://wagmi.sh/vue/api/createConfig) for more configuration options.

TypeScript Tip

If you are using TypeScript, you can "register" the Wagmi config or use the hook `config` property to get strong type-safety in places that wouldn't normally have type info.

register confighook config property

ts

    import {  } from '@wagmi/vue'
    
    ({ chainId: 123 })Type '123' is not assignable to type 'DeepMaybeRef<1 | 11155111 | undefined>'.
    declare module '@wagmi/vue' {
      interface Register {
        : typeof 
      }
    }

ts

    import {  } from '@wagmi/vue'
    
    ({ chainId: 123,  })Type '123' is not assignable to type 'DeepMaybeRef<1 | 11155111 | undefined>'.

By registering or using the hook `config` property, `useBlockNumber`'s `chainId` is strongly typed to only allow Mainnet and Sepolia IDs. Learn more by reading the [TypeScript docs](https://wagmi.sh/vue/typescript#config-types).

### Add Plugin to App [‚Äã](#add-plugin-to-app)

Add the `WagmiPlugin` to your app instance and pass the `config` you created earlier to the plugin options.

main.tsApp.vueconfig.ts

tsx

    import { WagmiPlugin } from '@wagmi/vue'
    import { createApp } from 'vue'
    import { config } from './config'
    import App from './App.vue'
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .mount('#app')

vue

    <template>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Check out the [`WagmiPlugin` docs](https://wagmi.sh/vue/api/WagmiPlugin) to learn more about the plugin API.

### Setup TanStack Query [‚Äã](#setup-tanstack-query)

After the `WagmiPlugin`, attach the `VueQueryPlugin` to your app, and pass a new `QueryClient` instance to the `queryClient` property.

main.tsApp.vueconfig.ts

tsx

    import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
    import { WagmiPlugin } from '@wagmi/vue'
    import { createApp } from 'vue'
    import { config } from './config'
    import App from './App.vue'
    
    const queryClient = new QueryClient()
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .use(VueQueryPlugin, { queryClient })
      .mount('#app')

vue

    <template>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Check out the [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/vue) to learn about the library, APIs, and more.

### Use Wagmi [‚Äã](#use-wagmi)

Now that everything is set up, every component inside your app can use Wagmi Vue Composables.

App.vuemain.tsconfig.ts

vue

    <script setup lang="ts">
    import { useAccount, useEnsName } from '@wagmi/vue'
    
    const { address } = useAccount()
    const { data, error, status } = useEnsName({ address })
    </script>
    
    <template>
      <div v-if="status === 'pending'">Loading ENS name</div>
      <div v-else-if="status === 'error'">
        Error fetching ENS name: {{error.message}}
      </div>
      <div v-else>ENS name: {{data}}</div>
    </template>

tsx

    import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
    import { WagmiPlugin } from '@wagmi/vue'
    import { createApp } from 'vue'
    import { config } from './config'
    import App from './App.vue'
    
    const queryClient = new QueryClient()
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .use(VueQueryPlugin, { queryClient })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Next Steps [‚Äã](#next-steps)
---------------------------

For more information on what to do next, check out the following topics.

*   [**TypeScript**](https://wagmi.sh/vue/typescript) Learn how to get the most out of Wagmi's type-safety and inference for an enlightened developer experience.
*   [**Connect Wallet**](https://wagmi.sh/vue/guides/connect-wallet) Learn how to enable wallets to connect to and disconnect from your apps and display information about connected accounts.
*   [**Vue Composables**](https://wagmi.sh/vue/api/composables) Browse the collection of Vue Composables and learn how to use them.
*   [**Viem**](https://wagmi.sh/vue/guides/viem) Learn about Viem and how it works with Wagmi.</content>
</page>

<page>
  <title>TypeScript | Wagmi</title>
  <url>https://wagmi.sh/react/typescript</url>
  <content>Requirements [‚Äã](#requirements)
-------------------------------

Wagmi is designed to be as type-safe as possible! Things to keep in mind:

*   Types currently require using TypeScript >=5.0.4.
*   [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
*   Changes to types in this repository are considered non-breaking and are usually released as patch changes (otherwise every type enhancement would be a major version!).
*   It is highly recommended that you lock your `wagmi` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
*   The non-type-related public API of Wagmi still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

tsconfig.json

json

    {
      "compilerOptions": {
        "strict": true
      }
    }

Config Types [‚Äã](#config-types)
-------------------------------

By default React Context does not work well with type inference. To support strong type-safety across the React Context boundary, there are two options available:

*   Declaration merging to "register" your `config` globally with TypeScript.
*   `config` property to pass your `config` directly to hooks.

### Declaration Merging [‚Äã](#declaration-merging)

[Declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) allows you to "register" your `config` globally with TypeScript. The `Register` type enables Wagmi to infer types in places that wouldn't normally have access to type info via React Context alone.

To set this up, add the following declaration to your project. Below, we co-locate the declaration merging and the `config` set up.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Since the `Register` type is global, you only need to add it once in your project. Once set up, you will get strong type-safety across your entire project. For example, query hooks will type `chainId` based on your `config`'s `chains`.

ts

    import {  } from 'wagmi'
    
    ({ chainId: 123 })Type '123' is not assignable to type '1 | 11155111 | undefined'.

You just saved yourself a runtime error and you didn't even need to pass your `config`. üéâ

### Hook `config` Property [‚Äã](#hook-config-property)

For cases where you have more than one Wagmi `config` or don't want to use the declaration merging approach, you can pass a specific `config` directly to hooks via the `config` property.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, optimism } from 'wagmi/chains'
    
    export const configA = createConfig({ 
      chains: [mainnet], 
      transports: { 
        [mainnet.id]: http(), 
      }, 
    })
    
    export const configB = createConfig({ 
      chains: [optimism], 
      transports: { 
        [optimism.id]: http(), 
      }, 
    })

As you expect, `chainId` is inferred correctly for each `config`.

ts

    import {  } from 'wagmi'
    
    ({ chainId: 123, :  })Type '123' is not assignable to type '1'.({ chainId: 123, :  })Type '123' is not assignable to type '10'.

This approach is more explicit, but works well for advanced use-cases, if you don't want to use React Context or declaration merging, etc.

Const-Assert ABIs & Typed Data [‚Äã](#const-assert-abis-typed-data)
-----------------------------------------------------------------

Wagmi can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh/) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

ts

    const { data } = useReadContract({
      abi: [‚Ä¶], // <--- defined inline
    })

ts

    const abi = [‚Ä¶] as const // <--- const assertion
    const { data } = useReadContract({ abi })

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`useReadContract`](https://wagmi.sh/react/api/hooks/useReadContract) looks like with and without a const-asserted `abi` property.

Const-AssertedNot Const-Asserted

ts

    import {  } from 'wagmi'
    
    const {  } = ({
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      : 'balanceOf',
    
    
    
      : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    
    

ts

    import {  } from 'wagmi'
    
    const {  } = ({
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      : 'balanceOf',
    
    
    
      : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    
    

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. üéâ

ts

    import {  } from 'wagmi'
    
    ({
      : ,
      functionName: 'balanecOf',Type '"balanecOf"' is not assignable to type '"balanceOf" | "isApprovedForAll" | "getApproved" | "ownerOf" | "tokenURI" | undefined'. Did you mean '"balanceOf"'?})

Configure Internal Types [‚Äã](#configure-internal-types)
-------------------------------------------------------

For advanced use-cases, you may want to configure Wagmi's internal types. Most of Wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev/) for more info on how to configure types.</content>
</page>

<page>
  <title>TanStack Query | Wagmi</title>
  <url>https://wagmi.sh/react/guides/tanstack-query</url>
  <content>Wagmi Hooks are not only a wrapper around the core [Wagmi Actions](https://wagmi.sh/core/api/actions), but they also utilize [TanStack Query](https://tanstack.com/query/v5) to enable trivial and intuitive fetching, caching, synchronizing, and updating of asynchronous data in your React applications.

Without an asynchronous data fetching abstraction, you would need to handle all the negative side-effects that comes as a result, such as: representing finite states (loading, error, success), handling race conditions, caching against a deterministic identifier, etc.

Queries & Mutations [‚Äã](#queries-mutations)
-------------------------------------------

Wagmi Hooks represent either a **Query** or a **Mutation**.

**Queries** are used for fetching data (e.g. fetching a block number, reading from a contract, etc), and are typically invoked on mount by default. All queries are coupled to a unique [Query Key](#query-keys), and can be used for further operations such as refetching, prefetching, or modifying the cached data.

**Mutations** are used for mutating data (e.g. connecting/disconnecting accounts, writing to a contract, switching chains, etc), and are typically invoked in response to a user interaction. Unlike **Queries**, they are not coupled with a query key.

Terms [‚Äã](#terms)
-----------------

*   **Query**: An asynchronous data fetching (e.g. read data) operation that is tied against a unique Query Key.
*   **Mutation**: An asynchronous mutating (e.g. create/update/delete data or side-effect) operation.
*   **Query Key**: A unique identifier that is used to deterministically identify a query. It is typically a tuple of the query name and the query arguments.
*   **Stale Data**: Data that is unused or inactive after a certain period of time.
*   **Query Fetching**: The process of invoking an async query function.
*   **Query Refetching**: The process of refetching **rendered** queries.
*   **[Query Invalidation](https://tanstack.com/query/v5/docs/react/guides/query-invalidation)**: The process of marking query data as stale (e.g. inactive/unused), and refetching **rendered** queries.
*   **[Query Prefetching](https://tanstack.com/query/v5/docs/react/guides/prefetching)**: The process of prefetching queries and seeding the cache.

Persistence via External Stores [‚Äã](#persistence-via-external-stores)
---------------------------------------------------------------------

By default, TanStack Query persists all query data in-memory. This means that if you refresh the page, all in-memory query data will be lost.

If you want to persist query data to an external storage, you can utilize TanStack Query's [`createSyncStoragePersister`](https://tanstack.com/query/v5/docs/react/plugins/createSyncStoragePersister) or [`createAsyncStoragePersister`](https://tanstack.com/query/v5/docs/react/plugins/createAsyncStoragePersister) to plug external storage like `localStorage`, `sessionStorage`, [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or [`AsyncStorage`](https://reactnative.dev/docs/asyncstorage) (React Native).

### Sync Storage [‚Äã](#sync-storage)

Below is an example of how to set up Wagmi + TanStack Query with sync external storage like `localStorage` or `sessionStorage`.

#### Install [‚Äã](#install)

pnpmnpmyarnbun

bash

    pnpm i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client

bash

    npm i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client

bash

    yarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client

bash

    bun i @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client

#### Usage [‚Äã](#usage)

tsx

    // 1. Import modules.
    import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'
    import { QueryClient } from '@tanstack/react-query'
    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { WagmiProvider, deserialize, serialize } from 'wagmi'
    
    // 2. Create a new Query Client with a default `gcTime`.
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1_000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // 3. Set up the persister.
    const persister = createSyncStoragePersister({
      serialize,
      storage: window.localStorage,
      deserialize,
    })
    
    function App() {
      return (
        <WagmiProvider config={config}>
          {/* 4. Wrap app in PersistQueryClientProvider */}
          <PersistQueryClientProvider
            client={queryClient}
            persistOptions={{ persister }}
          >
            {/* ... */}
          </PersistQueryClientProvider>
        </WagmiProvider>
      )
    }

Read more about [Sync Storage Persistence](https://tanstack.com/query/v5/docs/react/plugins/createSyncStoragePersister).

### Async Storage [‚Äã](#async-storage)

Below is an example of how to set up Wagmi + TanStack Query with async external storage like [`IndexedDB`](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or [`AsyncStorage`](https://reactnative.dev/docs/asyncstorage).

#### Install [‚Äã](#install-1)

pnpmnpmyarnbun

bash

    pnpm i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

bash

    npm i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

bash

    yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

bash

    bun i @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

#### Usage [‚Äã](#usage-1)

tsx

    // 1. Import modules.
    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    import { QueryClient } from '@tanstack/react-query'
    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { WagmiProvider, deserialize, serialize } from 'wagmi'
    
    // 2. Create a new Query Client with a default `gcTime`.
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1_000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // 3. Set up the persister.
    const persister = createAsyncStoragePersister({
      serialize,
      storage: AsyncStorage,
      deserialize,
    })
    
    function App() {
      return (
        <WagmiProvider config={config}>
          {/* 4. Wrap app in PersistQueryClientProvider */}
          <PersistQueryClientProvider
            client={queryClient}
            persistOptions={{ persister }}
          >
            {/* ... */}
          </PersistQueryClientProvider>
        </WagmiProvider>
      )
    }

Read more about [Async Storage Persistence](https://tanstack.com/query/v5/docs/react/plugins/createAsyncStoragePersister).

Query Keys [‚Äã](#query-keys)
---------------------------

Query Keys are typically used to perform advanced operations on the query such as: invalidation, refetching, prefetching, etc.

Wagmi exports Query Keys for every Hook, and they can be retrieved via the [Hook (React)](#hook-react) or via an [Import (Vanilla JS)](#import-vanilla-js).

Read more about **Query Keys** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/query-keys)

### Hook (React) [‚Äã](#hook-react)

Each Hook returns a `queryKey` value. You would use this approach when you want to utilize the query key in a React component as it handles reactivity for you, unlike the [Import](#import-vanilla-js) method below.

ts

    import { useBlock } from 'wagmi'
    
    function App() {
      const { queryKey } = useBlock()
    }

### Import (Vanilla JS) [‚Äã](#import-vanilla-js)

Each Hook has a corresponding `get<X>QueryOptions` function that returns a query key. You would use this method when you want to utilize the query key outside of a React component in a Vanilla JS context, like in a utility function.

ts

    import { getBlockQueryOptions } from 'wagmi/query'
    import { config } from './config'
    
    function perform() {
      const { queryKey } = getBlockQueryOptions(config, { 
        chainId: config.state.chainId
      })
    }

WARNING

The caveat of this method is that it does not handle reactivity for you (e.g. active account/chain changes, argument changes, etc). You would need to handle this yourself by explicitly passing through the arguments to `get<X>QueryOptions`.

Invalidating Queries [‚Äã](#invalidating-queries)
-----------------------------------------------

Invalidating a query is the process of marking the query data as stale (e.g. inactive/unused), and refetching the queries that are already rendered.

Read more about **Invalidating Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/query-invalidation)

#### Example: Watching a Users' Balance [‚Äã](#example-watching-a-users-balance)

You may want to "watch" a users' balance, and invalidate the balance after each incoming block. We can invoke `invalidateQueries` inside a `useEffect` with the block number as it's only dependency ‚Äì this will refetch all rendered balance queries when the `blockNumber` changes.

tsx

    import { useQueryClient } from '@tanstack/react-query' 
    import { useEffect } from 'react' 
    import { useBlockNumber, useBalance } from 'wagmi' 
    
    function App() {
      const queryClient = useQueryClient()
      const { data: blockNumber } = useBlockNumber({ watch: true })
      const { data: balance, queryKey } = useBalance()
      
      useEffect(() => {
        queryClient.invalidateQueries({ queryKey })
      }, [blockNumber])
    
      return <div>{balance}</div>
    }

#### Example: After User Interaction [‚Äã](#example-after-user-interaction)

Maybe you want to invalidate a users' balance after some interaction. This would mark the balance as stale, and consequently refetch all rendered balance queries.

tsx

    import { useBalance } from 'wagmi'
    
    function App() {
      // 1. Extract `queryKey` from the useBalance Hook.
      const { queryKey } = useBalance()
    
      return (
        <button
          onClick={async () => {
            // 2. Invalidate the query when the user clicks "Invalidate".
            await queryClient.invalidateQueries({ queryKey })
          }}
        >
          Invalidate
        </button>
      )
    }
    
    function Example() {
      // 3. Other `useBalance` Hooks in your rendered React tree will be refetched!
      const { data: balance } = useBalance()
    
      return <div>{balance}</div>
    }

Fetching Queries [‚Äã](#fetching-queries)
---------------------------------------

Fetching a query is the process of invoking the query function to retrieve data. If the query exists and the data is not invalidated or older than a given `staleTime`, then the data from the cache will be returned. Otherwise, the query will fetch for the latest data.

example.tsxapp.tsxconfig.ts

tsx

    import { getBlockQueryOptions } from 'wagmi'
    import { queryClient } from './app'
    import { config } from './config'
    
    export async function fetchBlockData() {
      return queryClient.fetchQuery(
        getBlockQueryOptions(config, {
          chainId: config.state.chainId,
        }
      ))
    }

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import * as React from 'react'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    export const queryClient = new QueryClient()
    
    export function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            {/** ... */}
          </QueryClientProvider>
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Retrieving & Updating Query Data [‚Äã](#retrieving-updating-query-data)
---------------------------------------------------------------------

You can retrieve and update query data imperatively with `getQueryData` and `setQueryData`. This is useful for scenarios where you want to retrieve or update a query outside of a React component.

Note that these functions do not invalidate or refetch queries.

example.tsxapp.tsxconfig.ts

tsx

    import { getBlockQueryOptions } from 'wagmi'
    import type { Block } from 'viem'
    import { queryClient } from './app'
    import { config } from './config'
    
    export function getPendingBlockData() {
      return queryClient.getQueryData(
        getBlockQueryOptions(config, {
          chainId: config.state.chainId,
          tag: 'pending'
        }
      ))
    }
    
    export function setPendingBlockData(data: Block) {
      return queryClient.setQueryData(
        getBlockQueryOptions(config, {
          chainId: config.state.chainId,
          tag: 'pending'
        },
        data
      ))
    }

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import * as React from 'react'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    export const queryClient = new QueryClient()
    
    export function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            {/** ... */}
          </QueryClientProvider>
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Prefetching Queries [‚Äã](#prefetching-queries)
---------------------------------------------

Prefetching a query is the process of fetching the data ahead of time and seeding the cache with the returned data. This is useful for scenarios where you want to fetch data before the user navigates to a page, or fetching data on the server to be reused on client hydration.

Read more about **Prefetching Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/react/guides/prefetching)

#### Example: Prefetching in Event Handler [‚Äã](#example-prefetching-in-event-handler)

tsx

    import { Link } from 'next/link'
    import { getBlockQueryOptions } from 'wagmi'
    
    function App() {
      const config = useConfig()
      const chainId = useChainId()
    
      // 1. Set up a function to prefetch the block data.
      const prefetch = () =>
        queryClient.prefetchQuery(getBlockQueryOptions(config, { chainId }))
      
    
      return (
        <Link
          // 2. Add event handlers to prefetch the block data
          // when user hovers over or focuses on the button.
          onMouseEnter={prefetch}
          onFocus={prefetch}
          to="/block-details"
        >
          Block details
        </Link>
      )
    }

SSR [‚Äã](#ssr)
-------------

It is possible to utilize TanStack Query's SSR strategies with Wagmi Hooks & Query Keys. Check out the [Server Rendering & Hydration](https://tanstack.com/query/v5/docs/react/guides/ssr) & [Advanced Server Rendering](https://tanstack.com/query/v5/docs/react/guides/advanced-ssr) guides.

TanStack Query includes dedicated [Devtools](https://tanstack.com/query/latest/docs/framework/react/devtools) that assist in visualizing and debugging your queries, their cache states, and much more. You will have to pass a custom `queryKeyFn` to your `QueryClient` for Devtools to correctly serialize BigInt values for display. Alternatively, You can use the `hashFn` from `@wagmi/core/query`, which already handles this serialization.

#### Install [‚Äã](#install-2)

pnpmnpmyarnbun

bash

    pnpm i @tanstack/react-query-devtools

bash

    npm i @tanstack/react-query-devtools

bash

    yarn add @tanstack/react-query-devtools

bash

    bun i @tanstack/react-query-devtools

#### Usage [‚Äã](#usage-2)

tsx

    import {
      QueryClient,
      QueryClientProvider,
    } from "@tanstack/react-query";
    import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
    import { hashFn } from "@wagmi/core/query";
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryKeyHashFn: hashFn,
        },
      },
    });</content>
</page>

<page>
  <title>Installation | Wagmi</title>
  <url>https://wagmi.sh/react/installation</url>
  <content>Install Wagmi via your package manager, a `<script>` tag, or build from source.

Package Manager [‚Äã](#package-manager)
-------------------------------------

Install the required packages.

pnpmnpmyarnbun

bash

    pnpm add wagmi viem@2.x @tanstack/react-query

bash

    npm install wagmi viem@2.x @tanstack/react-query

bash

    yarn add wagmi viem@2.x @tanstack/react-query

bash

    bun add wagmi viem@2.x @tanstack/react-query

*   [Viem](https://viem.sh/) is a TypeScript interface for Ethereum that performs blockchain operations.
*   [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
*   [TypeScript](https://wagmi.sh/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](https://wagmi.sh/react/typescript).

CDN [‚Äã](#cdn)
-------------

If you're not using a package manager, you can also use Wagmi via an ESM-compatible CDN such as [esm.sh](https://esm.sh/). Simply add a `<script type="module">` tag to the bottom of your HTML file with the following content.

html

    <script type="module">
      import React from 'https://esm.sh/react@18.2.0'
      import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
      import { createClient } from 'https://esm.sh/viem@2.x'
      import { createConfig } from 'https://esm.sh/wagmi'
    </script>

Check out the React docs for info on how to use [React without JSX](https://react.dev/reference/react/createElement#creating-an-element-without-jsx).

Requirements [‚Äã](#requirements)
-------------------------------

Wagmi is optimized for modern browsers. It is compatible with the latest versions of the following browsers.

Using Unreleased Commits [‚Äã](#using-unreleased-commits)
-------------------------------------------------------

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

pnpmnpmyarnbun

bash

    pnpm add wagmi@canary

bash

    npm install wagmi@canary

bash

    yarn add wagmi@canary

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

bash

    gh repo clone wevm/wagmi
    cd wagmi
    pnpm install
    pnpm build
    cd packages/react
    pnpm link --global

Then go to the project where you are using Wagmi and run `pnpm link --global wagmi` (or the package manager that you used to link Wagmi globally). Make sure you installed any [required peer dependencies](#package-manager) and their versions are correct.

Security [‚Äã](#security)
-----------------------

Ethereum-related projects are often targeted in attacks to steal users' assets. Make sure you follow security best-practices for your project. Some quick things to get started.

*   Pin package versions, upgrade mindfully, and inspect lockfile changes to minimize the risk of [supply-chain attacks](https://nodejs.org/en/guides/security/#supply-chain-attacks).
*   Install the [Socket Security](https://socket.dev/) [GitHub App](https://github.com/apps/socket-security) to help detect and block supply-chain attacks.
*   Add a [Content Security Policy](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) to defend against external scripts running in your app.
*   Pin [GitHub Action](https://x.com/paulmillr/status/1900948425325031448) versions to commits instead of tags.</content>
</page>

<page>
  <title>SSR | Wagmi</title>
  <url>https://wagmi.sh/react/guides/ssr</url>
  <content>Wagmi uses client-only external stores (such as `localStorage` and `mipd`) to show the user the most relevant data as quickly as possible on first render.

However, the caveat of using these external client stores is that frameworks which incorporate SSR (such as Next.js) will throw hydration warnings on the client when it identifies mismatches between the server-rendered HTML and the client-rendered HTML.

To stop this from happening, you can toggle on the [`ssr`](https://wagmi.sh/react/api/createConfig#ssr) property in the Wagmi Config.

tsx

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true,
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Turning on the `ssr` property means that content from the external stores will be hydrated on the client after the initial mount.

Persistence using Cookies [‚Äã](#persistence-using-cookies)
---------------------------------------------------------

As a result of turning on the `ssr` property, external persistent stores like `localStorage` will be hydrated on the client **after the initial mount**.

This means that you will still see a flash of "empty" data on the client (e.g. a `"disconnected"` account instead of a `"reconnecting"` account, or an empty address instead of the last connected address) until after the first mount, when the store hydrates.

In order to persist data between the server and the client, you can use cookies.

### 1\. Set up cookie storage [‚Äã](#_1-set-up-cookie-storage)

First, we will set up cookie storage in the Wagmi Config.

tsx

    import { 
      createConfig, 
      http, 
      cookieStorage,
      createStorage
    } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export function getConfig() {
      return createConfig({
        chains: [mainnet, sepolia],
        ssr: true,
        storage: createStorage({
          storage: cookieStorage,
        }),
        transports: {
          [mainnet.id]: http(),
          [sepolia.id]: http(),
        },
      })
    }

### 2\. Hydrate the cookie [‚Äã](#_2-hydrate-the-cookie)

Next, we will need to add some mechanisms to hydrate the stored cookie in Wagmi.

#### Next.js App Directory [‚Äã](#next-js-app-directory)

In our `app/layout.tsx` file (a [Server Component](https://nextjs.org/docs/app/building-your-application/rendering/server-components)), we will need to extract the cookie from the `headers` function and pass it to [`cookieToInitialState`](https://wagmi.sh/react/api/utilities/cookieToInitialState).

We will need to pass this result to the [`initialState` property](https://wagmi.sh/react/api/WagmiProvider#initialstate) of the `WagmiProvider`. The `WagmiProvider` **must** be in a Client Component tagged with `"use client"` (see `app/providers.tsx` tab).

app/layout.tsxapp/providers.tsxapp/config.ts

tsx

    import { type ReactNode } from 'react'
    import { headers } from 'next/headers'
    import { cookieToInitialState } from 'wagmi'
    
    import { getConfig } from './config'
    import { Providers } from './providers'
    
    export default async function Layout({ children }: { children: ReactNode }) {
      const initialState = cookieToInitialState(
        getConfig(),
        (await headers()).get('cookie')
      )
      return (
        <html lang="en">
          <body>
            <Providers>
            <Providers initialState={initialState}>
              {children}
            </Providers>
          </body>
        </html>
      )
    }

tsx

    'use client'
    
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { type ReactNode, useState } from 'react'
    import { type State, WagmiProvider } from 'wagmi'
    
    import { getConfig } from './config'
    
    type Props = {
      children: ReactNode,
      initialState: State | undefined,
    }
    
    export function Providers({ children }: Props) {
    export function Providers({ children, initialState }: Props) {
      const [config] = useState(() => getConfig())
      const [queryClient] = useState(() => new QueryClient())
    
      return (
        <WagmiProvider config={config}>
        <WagmiProvider config={config} initialState={initialState}>
          <QueryClientProvider client={queryClient}>
            {children}
          </QueryClientProvider>
        </WagmiProvider>
      )
    }

tsx

    import { 
      createConfig, 
      http, 
      cookieStorage,
      createStorage 
    } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export function getConfig() {
      return createConfig({
        chains: [mainnet, sepolia],
        ssr: true,
        storage: createStorage({
          storage: cookieStorage,
        }),
        transports: {
          [mainnet.id]: http(),
          [sepolia.id]: http(),
        },
      })
    }

#### Next.js Pages Directory [‚Äã](#next-js-pages-directory)

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!

#### Vanilla SSR [‚Äã](#vanilla-ssr)

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!</content>
</page>

<page>
  <title>Error Handling | Wagmi</title>
  <url>https://wagmi.sh/react/guides/error-handling</url>
  <content>The `error` property in Wagmi Hooks is strongly typed with it's corresponding error type. This enables you to have granular precision with handling errors in your application.

You can discriminate the error type by using the `name` property on the error object.

index.tsxconfig.ts

tsx

    import {  } from 'wagmi'
    
    function () {
      const { ,  } = ()
    
      ?.
    
    
    
    
    
    
      if (?. === 'HttpRequestError') {
        const {  } = 
    
    
        return <>A HTTP error occurred. Status: {}</>
      }
      if (?. === 'LimitExceededRpcError') {
        const {  } = 
    
        
        return <>Rate limit exceeded. Code: {}</>
      }
      // ...
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })</content>
</page>

<page>
  <title>Comparison | Wagmi</title>
  <url>https://wagmi.sh/react/comparisons</url>
  <content>There are multiple options when it comes to React libraries for Ethereum that help manage wallet connections, provide utility methods/hooks, etc.

TIP

Comparisons strive to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes.

Overview [‚Äã](#overview)
-----------------------

|  | [wagmi](https://github.com/wagmi-dev/wagmi) | [web3-react](https://github.com/NoahZinsmeister/web3-react) | [useDApp](https://github.com/EthWorks/useDApp) |
| --- | --- | --- | --- |
| GitHub Stars |  |  |  |
| Open Issues |  |  |  |
| Downloads |  |  |  |
| License |  |  |  |
| Their Comparison | ‚Äì | none | none |
| Supported Frameworks | React, Vanilla JS | React | React |
| Documentation | ‚úÖ | üõë | ‚úÖ |
| TypeScript | ‚úÖ | üî∂ | üî∂ |
| EIP-6963 Support | ‚úÖ | üî¥ | üî¥ |
| Test Suite | ‚úÖ | üî∂ | üî∂ |
| Examples | ‚úÖ | üî∂ | ‚úÖ |

Comparison Key

1.  Documentation

*   Comprehensive documentation for all library features ‚úÖ
*   No documentation üî¥

2.  Typescript

*   Infer types from ABIs, EIP-712 Typed Data, etc. ‚úÖ
*   Can add types with explicit generics, type annotations, etc. üî∂

3.  Test Suite

*   Runs against forked Ethereum network(s) ‚úÖ
*   Mocking functionality (i.e. RPC calls) is üî∂

4.  EIP-6963 Support

*   Fully compatible with EIP-6963 ‚úÖ
*   Not compatible with EIP-6963 üî¥

5.  Examples

*   Has multiple examples ‚úÖ
*   Has single example üî∂

[Wagmi](https://github.com/wagmi-dev/wagmi) [‚Äã](#wagmi)
-------------------------------------------------------

### Pros [‚Äã](#pros)

*   20+ hooks for working with wallets, ENS, contracts, transactions, signing, etc.
*   Built-in wallet connectors for injected providers (EIP-6963 support), WalletConnect, MetaMask, Coinbase Wallet
*   Caching, request deduplication, and persistence powered by TanStack Query
*   Auto-refresh data on wallet, block, and network changes
*   Multicall support
*   Test suite running against forked Ethereum networks
*   TypeScript ready (infer types from ABIs and EIP-712 Typed Data)
*   Extensive documentation and examples
*   Used by Coinbase, Stripe, Shopify, Uniswap, Optimism, ENS, Sushi, and [many more](https://github.com/wagmi-dev/wagmi/discussions/201)
*   MIT License

### Cons [‚Äã](#cons)

*   Not as many built-in connectors as `web3-react`

[web3-react](https://github.com/Uniswap/web3-react) [‚Äã](#web3-react)
--------------------------------------------------------------------

### Pros [‚Äã](#pros-1)

*   Supports many different connectors (conceptually similar to Wagmi's connectors)
*   Basic hooks for managing account

### Cons [‚Äã](#cons-1)

*   Need to set up connectors and method for connecting wallet on your own
*   Need to install connectors separately
*   Almost no tests or documentation; infrequent updates
*   GPL-3.0 License

[useDApp](https://github.com/EthWorks/useDApp) [‚Äã](#usedapp)
------------------------------------------------------------

### Pros [‚Äã](#pros-2)

*   Auto-refresh on new blocks and wallet changes
*   Multicall support
*   Transaction notifications
*   Chrome extension and Firefox add-on
*   MIT License

### Cons [‚Äã](#cons-2)

*   Non-standard hook API</content>
</page>

<page>
  <title>Viem | Wagmi</title>
  <url>https://wagmi.sh/react/guides/viem</url>
  <content>[Viem](https://viem.sh/) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](https://wagmi.sh/react/api/createConfig) and automatic account management via [Connectors](https://wagmi.sh/react/api/connectors).

Leveraging Viem Actions [‚Äã](#leveraging-viem-actions)
-----------------------------------------------------

All of the core [Wagmi Hooks](https://wagmi.sh/react/api/actions) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](https://wagmi.sh/react/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe a Hook doesn't exist in Wagmi yet). In these cases, you can create your own custom Wagmi Hook by importing Viem Actions directly via `viem/actions` and plugging in a Viem Client returned by the [`useClient` Hook](https://wagmi.sh/react/api/hooks/useClient).

The example below demonstrates two different ways to utilize Viem Actions:

1.  **Tree-shakable Actions (recommended):** Uses `useClient` (for public actions) and `useConnectorClient` (for wallet actions).
2.  **Client Actions:** Uses `usePublicClient` (for public actions) and `useWalletClient` (for wallet actions).

TIP

It is highly recommended to use the **tree-shakable** method to ensure that you are only pulling modules you use, and keep your bundle size low.

Tree-shakable ActionsClient Actions

tsx

    // 1. Import modules. 
    import { useMutation, useQuery } from '@tanstack/react-query'
    import { http, createConfig, useClient, useConnectorClient } from 'wagmi' 
    import { base, mainnet, optimism, zora } from 'wagmi/chains' 
    import { getLogs, watchAsset } from 'viem/actions'
    
    // 2. Set up a Wagmi Config 
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    function Example() {
      // 3. Extract a Viem Client for the current active chain.
      const publicClient = useClient({ config })
    
      // 4. Create a "custom" Query Hook that utilizes the Client.
      const { data: logs } = useQuery({
        queryKey: ['logs', publicClient.uid],
        queryFn: () => getLogs(publicClient, /* ... */)
      })
      
      // 5. Extract a Viem Client for the current active chain & account.
      const { data: walletClient } = useConnectorClient({ config })
    
      // 6. Create a "custom" Mutation Hook that utilizes the Client.
      const { mutate } = useMutation({
        mutationFn: (asset) => watchAsset(walletClient, asset)
      })
    
      return (
        <div>
          {/* ... */}
        </div>
      )
    }

tsx

    // 1. Import modules. 
    import { useMutation, useQuery } from '@tanstack/react-query'
    import { http, createConfig, useClient, useConnectorClient } from 'wagmi' 
    import { base, mainnet, optimism, zora } from 'wagmi/chains' 
    
    // 2. Set up a Wagmi Config 
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    function Example() {
      // 3. Extract a Viem Client for the current active chain.
      const publicClient = useClient({ config })
    
      // 4. Create a "custom" Query Hook that utilizes the Client.
      const { data: logs } = useQuery({
        queryKey: ['logs', publicClient.uid],
        queryFn: () => publicClient.getLogs(/* ... */)
      })
      
      // 5. Extract a Viem Client for the current active chain & account.
      const { data: walletClient } = useConnectorClient({ config })
    
      // 6. Create a "custom" Mutation Hook that utilizes the Client.
      const { mutate } = useMutation({
        mutationFn: (asset) => walletClient.watchAsset(asset)
      })
    
      return (
        <div>
          {/* ... */}
        </div>
      )
    }

Private Key & Mnemonic Accounts [‚Äã](#private-key-mnemonic-accounts)
-------------------------------------------------------------------

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

tsx

    import { http, createConfig, useSendTransaction } from 'wagmi' 
    import { base, mainnet, optimism, zora } from 'wagmi/chains' 
    import { parseEther } from 'viem'
    import { privateKeyToAccount } from 'viem/accounts'
    
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    const account = privateKeyToAccount('0x...')
    
    function Example() {
      const { data: hash } = useSendTransaction({
        account,
        to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        value: parseEther('0.001')
      })
    }

INFO

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config ‚Äì meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open an discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).</content>
</page>

<page>
  <title>Ethers.js Adapters | Wagmi</title>
  <url>https://wagmi.sh/react/guides/ethers</url>
  <content>It is recommended for projects to migrate to [Viem](https://viem.sh/) when using Wagmi, but there are some cases where you might still need to use [Ethers.js](https://ethers.org/) in your project:

*   You may want to **incrementally migrate** Ethers.js usage to Viem
*   Some **third-party libraries & SDKs** may only support Ethers.js
*   Personal preference

We have provided reference implementations for Viem ‚Üí Ethers.js adapters that you can copy + paste in your project.

Client ‚Üí Provider [‚Äã](#client-‚Üí-provider)
-----------------------------------------

### Reference Implementation [‚Äã](#reference-implementation)

Copy the following reference implementation into a file of your choice:

Ethers v5Ethers v6

ts

    import { providers } from 'ethers'
    import { useMemo } from 'react'
    import type { Chain, Client, Transport } from 'viem'
    import { Config, useClient } from 'wagmi'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback')
        return new providers.FallbackProvider(
          (transport.transports as ReturnType<Transport>[]).map(
            ({ value }) => new providers.JsonRpcProvider(value?.url, network),
          ),
        )
      return new providers.JsonRpcProvider(transport.url, network)
    }
    
    /** Hook to convert a viem Client to an ethers.js Provider. */
    export function useEthersProvider({
      chainId,
    }: { chainId?: number | undefined } = {}) {
      const client = useClient<Config>({ chainId })
      return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
    }

ts

    import { FallbackProvider, JsonRpcProvider } from 'ethers'
    import { useMemo } from 'react'
    import type { Chain, Client, Transport } from 'viem'
    import { type Config, useClient } from 'wagmi'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback') {
        const providers = (transport.transports as ReturnType<Transport>[]).map(
          ({ value }) => new JsonRpcProvider(value?.url, network),
        )
        if (providers.length === 1) return providers[0]
        return new FallbackProvider(providers)
      }
      return new JsonRpcProvider(transport.url, network)
    }
    
    /** Action to convert a viem Client to an ethers.js Provider. */
    export function useEthersProvider({ chainId }: { chainId?: number } = {}) {
      const client = useClient<Config>({ chainId })
      return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
    }

### Usage [‚Äã](#usage)

Now you can use the `useEthersProvider` function in your components:

example.tsethers.ts (Ethers v5)ethers.ts (Ethers v6)

ts

    import { useEthersProvider } from './ethers'
    
    function Example() {
      const provider = useEthersProvider()
      ...
    }

ts

    import { providers } from 'ethers'
    import { useMemo } from 'react'
    import type { Chain, Client, Transport } from 'viem'
    import { Config, useClient } from 'wagmi'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback')
        return new providers.FallbackProvider(
          (transport.transports as ReturnType<Transport>[]).map(
            ({ value }) => new providers.JsonRpcProvider(value?.url, network),
          ),
        )
      return new providers.JsonRpcProvider(transport.url, network)
    }
    
    /** Hook to convert a viem Client to an ethers.js Provider. */
    export function useEthersProvider({
      chainId,
    }: { chainId?: number | undefined } = {}) {
      const client = useClient<Config>({ chainId })
      return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
    }

ts

    import { FallbackProvider, JsonRpcProvider } from 'ethers'
    import { useMemo } from 'react'
    import type { Chain, Client, Transport } from 'viem'
    import { type Config, useClient } from 'wagmi'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback') {
        const providers = (transport.transports as ReturnType<Transport>[]).map(
          ({ value }) => new JsonRpcProvider(value?.url, network),
        )
        if (providers.length === 1) return providers[0]
        return new FallbackProvider(providers)
      }
      return new JsonRpcProvider(transport.url, network)
    }
    
    /** Action to convert a viem Client to an ethers.js Provider. */
    export function useEthersProvider({ chainId }: { chainId?: number } = {}) {
      const client = useClient<Config>({ chainId })
      return useMemo(() => (client ? clientToProvider(client) : undefined), [client])
    }

Connector Client ‚Üí Signer [‚Äã](#connector-client-‚Üí-signer)
---------------------------------------------------------

### Reference Implementation [‚Äã](#reference-implementation-1)

Copy the following reference implementation into a file of your choice:

Ethers v5Ethers v6

ts

    import { providers } from 'ethers'
    import { useMemo } from 'react'
    import type { Account, Chain, Client, Transport } from 'viem'
    import { Config, useConnectorClient } from 'wagmi'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new providers.Web3Provider(transport, network)
      const signer = provider.getSigner(account.address)
      return signer
    }
    
    /** Hook to convert a Viem Client to an ethers.js Signer. */
    export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
      const { data: client } = useConnectorClient<Config>({ chainId })
      return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
    }

ts

    import { BrowserProvider, JsonRpcSigner } from 'ethers'
    import { useMemo } from 'react'
    import type { Account, Chain, Client, Transport } from 'viem'
    import { type Config, useConnectorClient } from 'wagmi'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new BrowserProvider(transport, network)
      const signer = new JsonRpcSigner(provider, account.address)
      return signer
    }
    
    /** Hook to convert a viem Wallet Client to an ethers.js Signer. */
    export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
      const { data: client } = useConnectorClient<Config>({ chainId })
      return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
    }

### Usage [‚Äã](#usage-1)

Now you can use the `useEthersSigner` function in your components:

example.tsethers.ts (Ethers v5)ethers.ts (Ethers v6)

ts

    import { useEthersSigner } from './ethers'
    
    function example() {
      const signer = useEthersSigner()
      ...
    }

ts

    import { providers } from 'ethers'
    import { useMemo } from 'react'
    import type { Account, Chain, Client, Transport } from 'viem'
    import { Config, useConnectorClient } from 'wagmi'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new providers.Web3Provider(transport, network)
      const signer = provider.getSigner(account.address)
      return signer
    }
    
    /** Action to convert a Viem Client to an ethers.js Signer. */
    export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
      const { data: client } = useConnectorClient<Config>({ chainId })
      return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
    }

ts

    import { BrowserProvider, JsonRpcSigner } from 'ethers'
    import { useMemo } from 'react'
    import type { Account, Chain, Client, Transport } from 'viem'
    import { type Config, useConnectorClient } from 'wagmi'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new BrowserProvider(transport, network)
      const signer = new JsonRpcSigner(provider, account.address)
      return signer
    }
    
    /** Hook to convert a viem Wallet Client to an ethers.js Signer. */
    export function useEthersSigner({ chainId }: { chainId?: number } = {}) {
      const { data: client } = useConnectorClient<Config>({ chainId })
      return useMemo(() => (client ? clientToSigner(client) : undefined), [client])
    }</content>
</page>

<page>
  <title>Chain Properties | Wagmi</title>
  <url>https://wagmi.sh/react/guides/chain-properties</url>
  <content>Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains all support additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

  

TIP

Make sure you follow the TypeScript guide's [Config Types](https://wagmi.sh/react/typescript#config-types) section before moving on. The easiest way to do this is to use [Declaration Merging](https://wagmi.sh/react/typescript#declaration-merging) to "register" your `config` globally with TypeScript.

ts

    import { http, createConfig } from 'wagmi'
    import { base, celo, mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }

Narrowing Parameters [‚Äã](#narrowing-parameters)
-----------------------------------------------

Once your Config is registered with TypeScript, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

index.tsxconfig.ts

ts

    import { parseEther } from 'viem'
    import { useSimulateContract } from 'wagmi'
    
    const result = useSimulateContract({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
      feeCurrency: '0x‚Ä¶', 
    })

ts

    import { http, createConfig } from 'wagmi'
    import { base, celo, mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

index.tsxconfig.ts

ts

    import { parseEther } from 'viem'
    import { useSimulateContract } from 'wagmi'
    import { celo } from 'wagmi/chains'
    
    const result = useSimulateContract({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
      chainId: celo.id, 
      feeCurrency: '0x‚Ä¶', 
      // ^? (property) feeCurrency?: `0x${string}` | undefined
    })

ts

    import { http, createConfig } from 'wagmi'
    import { base, celo, mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }

Narrowing Return Types [‚Äã](#narrowing-return-types)
---------------------------------------------------

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter [‚Äã](#chainid-parameter)

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

index.tsxconfig.ts

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    import { zkSync } from 'wagmi/chains'
    
    const { data } = useWaitForTransactionReceipt({
      chainId: zkSync.id,
      hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
    })
    
    data?.logs
    //    ^? (property) logs: ZkSyncLog[] | undefined

ts

    import { http, createConfig } from 'wagmi'
    import { base, celo, mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }

### `chainId` Data Property [‚Äã](#chainid-data-property)

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

index.tsxconfig.ts

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    import { zkSync } from 'wagmi/chains'
    
    const { data } = useWaitForTransactionReceipt({
      hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
    })
    
    if (data?.chainId === zkSync.id) {
      data?.logs
      //    ^? (property) logs: ZkSyncLog[] | undefined
    }

ts

    import { http, createConfig } from 'wagmi'
    import { base, celo, mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }

Troubleshooting [‚Äã](#troubleshooting)
-------------------------------------

If chain properties aren't working, make sure [TypeScript](https://wagmi.sh/react/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).</content>
</page>

<page>
  <title>Read from Contract | Wagmi</title>
  <url>https://wagmi.sh/react/guides/read-from-contract</url>
  <content>The [`useReadContract` Hook](https://wagmi.sh/react/api/hooks/useReadContract) allows you to read data on a smart contract, from a `view` or `pure` (read-only) function. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

The component below shows how to retrieve the token balance of an address from the [Wagmi Example](https://etherscan.io/token/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2) contract

read-contract.tsxcontracts.ts

tsx

    import { useReadContract } from 'wagmi'
    import { wagmiContractConfig } from './contracts'
    
    function ReadContract() {
      const { data: balance } = useReadContract({
        ...wagmiContractConfig,
        functionName: 'balanceOf',
        args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
      })
    
      return (
        <div>Balance: {balance?.toString()}</div>
      )
    }

ts

    export const wagmiContractConfig = {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: [
        {
          type: 'function',
          name: 'balanceOf',
          stateMutability: 'view',
          inputs: [{ name: 'account', type: 'address' }],
          outputs: [{ type: 'uint256' }],
        },
        {
          type: 'function',
          name: 'totalSupply',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ name: 'supply', type: 'uint256' }],
        },
      ],
    } as const

If `useReadContract` depends on another value (`address` in the example below), you can use the [`query.enabled`](https://wagmi.sh/react/api/hooks/useReadContract#enabled) option to prevent the query from running until the dependency is ready.

tsx

    const { data: balance } = useReadContract({
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: [address],
      query: {
        enabled: !!address,
      },
    })

Loading & Error States [‚Äã](#loading-error-states)
-------------------------------------------------

The [`useReadContract` Hook](https://wagmi.sh/react/api/hooks/useReadContract) also returns loading & error states, which can be used to display a loading indicator while the data is being fetched, or an error message if contract execution reverts.

read-contract.tsxread-contract.tsx (refetch)read-contract.tsx (invalidate)

tsx

    import { type BaseError, useReadContract } from 'wagmi'
    
    function ReadContract() {
      const { 
        data: balance,
        error,
        isPending
      } = useReadContract({
        ...wagmiContractConfig,
        functionName: 'balanceOf',
        args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
      })
    
      if (isPending) return <div>Loading...</div>
    
      if (error)
        return (
          <div>
            Error: {(error as BaseError).shortMessage || error.message}
          </div>
        )
    
      return (
        <div>Balance: {balance?.toString()}</div>
      )
    }

Refetching On Blocks [‚Äã](#refetching-on-blocks)
-----------------------------------------------

The [`useBlockNumber` Hook](https://wagmi.sh/react/api/hooks/useBlockNumber) can be utilized to refetch or [invalidate](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation) the contract data on a specific block interval.

read-contract.tsx (refetch)read-contract.tsx (invalidate)

tsx

    import { useEffect } from 'react'
    import { useBlockNumber, useReadContract } from 'wagmi'
    
    function ReadContract() {
      const { data: balance, refetch } = useReadContract({
        ...wagmiContractConfig,
        functionName: 'balanceOf',
        args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
      })
      const { data: blockNumber } = useBlockNumber({ watch: true })
    
      useEffect(() => {
        // want to refetch every `n` block instead? use the modulo operator!
        // if (blockNumber % 5 === 0) refetch() // refetch every 5 blocks
        refetch()
      }, [blockNumber])
    
      return (
        <div>Balance: {balance?.toString()}</div>
      )
    }

tsx

    import { useQueryClient } from '@tanstack/react-query'
    import { useEffect } from 'react'
    import { useBlockNumber, useReadContract } from 'wagmi'
    
    function ReadContract() {
      const queryClient = useQueryClient()
      const { data: balance, refetch } = useReadContract({
        ...wagmiContractConfig,
        functionName: 'balanceOf',
        args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
      })
      const { data: blockNumber } = useBlockNumber({ watch: true })
    
      useEffect(() => {
        // if `useReadContract` is in a different hook/component,
        // you can import `readContractQueryKey` from `'wagmi/query'` and
        // construct a one-off query key to use for invalidation
        queryClient.invalidateQueries({ queryKey })
      }, [blockNumber, queryClient])
    
      return (
        <div>Balance: {balance?.toString()}</div>
      )
    }

Calling Multiple Functions [‚Äã](#calling-multiple-functions)
-----------------------------------------------------------

We can use the [`useReadContract` Hook](https://wagmi.sh/react/api/hooks/useReadContract) multiple times in a single component to call multiple functions on the same contract, but this ends up being hard to manage as the number of functions increases, especially when we also want to deal with loading & error states.

Luckily, to make this easier, we can use the [`useReadContracts` Hook](https://wagmi.sh/react/api/hooks/useReadContracts) to call multiple functions in a single call.

read-contract.tsx

tsx

    import { type BaseError, useReadContracts } from 'wagmi'
    
    function ReadContract() {
      const { 
        data,
        error,
        isPending
      } = useReadContracts({ 
        contracts: [{ 
          ...wagmiContractConfig,
          functionName: 'balanceOf',
          args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
        }, { 
          ...wagmiContractConfig, 
          functionName: 'ownerOf', 
          args: [69n], 
        }, { 
          ...wagmiContractConfig, 
          functionName: 'totalSupply', 
        }] 
      }) 
      const [balance, ownerOf, totalSupply] = data || [] 
    
      if (isPending) return <div>Loading...</div>
    
      if (error)
        return (
          <div>
            Error: {(error as BaseError).shortMessage || error.message}
          </div>
        ) 
    
      return (
        <>
          <div>Balance: {balance?.toString()}</div>
          <div>Owner of Token 69: {ownerOf?.toString()}</div> 
          <div>Total Supply: {totalSupply?.toString()}</div> 
        </>
      )
    }</content>
</page>

<page>
  <title>FAQ / Troubleshooting | Wagmi</title>
  <url>https://wagmi.sh/react/guides/faq</url>
  <content>Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

Type inference doesn't work [‚Äã](#type-inference-doesn-t-work)
-------------------------------------------------------------

*   Check that you set up TypeScript correctly with `"strict": true` in your `tsconfig.json` ([TypeScript docs](https://wagmi.sh/react/typescript#requirements))
*   Check that you [const-asserted any ABIs or Typed Data](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) you are using.
*   Restart your language server or IDE, and check for type errors in your code.

My wallet doesn't work [‚Äã](#my-wallet-doesn-t-work)
---------------------------------------------------

If you run into issues with a specific wallet, try another before opening up an issue. There are many different wallets and it's likely that the issue is with the wallet itself, not Wagmi. For example, if you are using Wallet X and sending a transaction doesn't work, try Wallet Y and see if it works.

`BigInt` Serialization [‚Äã](#bigint-serialization)
-------------------------------------------------

Using native `BigInt` with `JSON.stringify` will raise a `TypeError` as [`BigInt` values are not serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json). There are two techniques to mitigate this:

#### Lossless serialization [‚Äã](#lossless-serialization)

Lossless serialization means that `BigInt` will be converted to a format that can be deserialized later (e.g. `69420n` ‚Üí `"#bigint.69420"`). The trade-off is that these values are not human-readable and are not intended to be displayed to the user.

Lossless serialization can be achieved with wagmi's [`serialize`](https://wagmi.sh/react/api/utilities/serialize) and [`deserialize`](https://wagmi.sh/react/api/utilities/deserialize) utilities.

tsx

    import { serialize, deserialize } from 'wagmi'
    
    const serialized = serialize({ value: 69420n })
    // '{"value":"#bigint.69420"}'
    
    const deserialized = deserialize(serialized)
    // { value: 69420n }

#### Lossy serialization [‚Äã](#lossy-serialization)

Lossy serialization means that the `BigInt` will be converted to a normal display string (e.g. `69420n` ‚Üí `'69420'`). The trade-off is that you will not be able to deserialize the `BigInt` with `JSON.parse` as it can not distinguish between a normal string and a `BigInt`.

This method can be achieved by modifying `JSON.stringify` to include a BigInt `replacer`:

tsx

    const replacer = (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    
    JSON.stringify({ value: 69420n }, replacer)
    // '{"value":"69420"}'

How do I support the project? [‚Äã](#how-do-i-support-the-project)
----------------------------------------------------------------

Wagmi is an open source software project and free to use. If you enjoy using Wagmi or would like to support Wagmi development, you can:

*   [Become a sponsor on GitHub](https://github.com/sponsors/wevm)
*   Send us crypto
    *   Mainnet: 0x4557B18E779944BFE9d78A672452331C186a9f48
    *   Multichain: 0xd2135CfB216b74109775236E36d4b433F1DF507B
*   [Become a supporter on Drips](https://www.drips.network/app/projects/github/wevm/wagmi)

If you use Wagmi at work, consider asking your company to sponsor Wagmi. This may not be easy, but **business sponsorships typically make a much larger impact on the sustainability of OSS projects** than individual donations, so you will help us much more if you succeed.

Is Wagmi production ready? [‚Äã](#is-wagmi-production-ready)
----------------------------------------------------------

Yes. Wagmi is very stable and is used in production by thousands of organizations, like [Stripe](https://stripe.com/), [Shopify](https://shopify.com/), [Coinbase](https://coinbase.com/), [Uniswap](https://uniswap.org/), [ENS](https://ens.domains/), [Optimism](https://optimism.com/).

Is Wagmi strict with semver? [‚Äã](#is-wagmi-strict-with-semver)
--------------------------------------------------------------

Yes, Wagmi is very strict with [semantic versioning](https://semver.org/) and we will never introduce breaking changes to the runtime API in a minor version bump.

For exported types, we try our best to not introduce breaking changes in non-major versions, however, [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases that can cause Wagmi type issues. See the [TypeScript docs](https://wagmi.sh/react/typescript#requirements) for more information.

How can I contribute to Wagmi? [‚Äã](#how-can-i-contribute-to-wagmi)
------------------------------------------------------------------

The Wagmi team accepts all sorts of contributions. Check out the [Contributing](https://wagmi.sh/dev/contributing) guide to get started. If you are interested in adding a new connector to Wagmi, check out the [Creating Connectors](https://wagmi.sh/dev/creating-connectors) guide.

Anything else you want to know? [‚Äã](#anything-else-you-want-to-know)
--------------------------------------------------------------------

Please create a new [GitHub Discussion thread](https://github.com/wevm/wagmi). You're also free to suggest changes to this or any other page on the site using the "Suggest changes to this page" button at the bottom of the page.

How does Wagmi work? [‚Äã](#how-does-wagmi-work)
----------------------------------------------

Until there's a more in-depth write-up about Wagmi internals, here is the gist:

*   Wagmi is essentially a wrapper around [Viem](https://viem.sh/) and TanStack Query that adds connector and multichain support.
*   [Connectors](https://wagmi.sh/react/api/connectors) allow Wagmi and Ethereum accounts to communicate with each other.
*   The Wagmi [`Config`](https://wagmi.sh/react/api/createConfig#config) manages connections established between Wagmi and Connectors, as well as some global state. [Connections](https://wagmi.sh/react/api/createConfig#connection) come with one or more addresses and a chain ID.
    *   If there are connections, the Wagmi `Config` listens for connection changes and updates the [`chainId`](https://wagmi.sh/react/api/createConfig#chainid) based on the ["current" connection](https://wagmi.sh/react/api/createConfig#current). (The Wagmi `Config` can have [many connections established](https://wagmi.sh/react/api/createConfig#connections) at once, but only one connection can be the "current" connection. Usually this is the connection from the last connector that is connected, but can change based on event emitted from other connectors or through the [`useSwitchAccount`](https://wagmi.sh/react/api/hooks/useSwitchAccount) hook and [`switchAccount`](https://wagmi.sh/core/api/actions/switchAccount) action.)
    *   If there are no connections, the Wagmi `Config` defaults the global state `chainId` to the first chain it was created with or last established connection.
    *   The global `chainId` can be changed directly using the [`useSwitchChain`](https://wagmi.sh/react/api/hooks/useSwitchChain) hook and [`switchChain`](https://wagmi.sh/core/api/actions/switchChain) action. This works when there are no connections as well as for most connectors (not all connectors support chain switching).
*   Wagmi uses the global `chainId` (from the "current" connection or global state) to internally create Viem Client's, which are used by hooks and actions.
*   Hooks are constructed by TanStack Query options helpers, exported by the `'@wagmi/core/query'` entrypoint, and some additional code to wire up type parameters, hook into React Context, etc.
*   There are three types of hooks: query hooks, mutation hooks, and config hooks. Query hooks, like [`useCall`](https://wagmi.sh/react/api/hooks/useCall), generally read blockchain state and mutation hooks, like [`useSendTransaction`](https://wagmi.sh/react/api/hooks/useSendTransaction), usually change state through sending transactions via the "current" connection. Config hooks are for getting data from and managing the Wagmi `Config` instance, e.g. [`useChainId`](https://wagmi.sh/react/api/hooks/useChainId) and `useSwitchAccount`. Query and mutation hooks usually have corresponding [Viem actions.](https://viem.sh/)</content>
</page>

<page>
  <title>createConfig | Wagmi</title>
  <url>https://wagmi.sh/react/api/createConfig</url>
  <content>Creates new [`Config`](#config) object.

Import [‚Äã](#import)
-------------------

ts

    import { createConfig } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

Integrating a Viem Client

Instead of using [`transports`](#transports), it's possible to provide a function that returns a Viem [`Client`](https://viem.sh/docs/clients/custom.html) via the [`client`](#client) property for more fine-grained control over Wagmi's internal `Client` creation.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { createClient } from 'viem'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      client({ chain }) {
        return createClient({ chain, transport: http() })
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateConfigParameters } from 'wagmi'

### chains [‚Äã](#chains)

`readonly [Chain, ...Chain[]]`

*   Chains used by the `Config`.
*   See [Chains](https://wagmi.sh/react/api/chains) for more details about built-in chains and the `Chain` type.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia], 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### connectors [‚Äã](#connectors)

`CreateConnectorFn[] | undefined`

[Connectors](https://wagmi.sh/react/api/connectors) used by the `Config`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { injected } from 'wagmi/connectors'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()], 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### multiInjectedProviderDiscovery [‚Äã](#multiinjectedproviderdiscovery)

`boolean | undefined`

*   Enables discovery of injected providers via [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) using the [`mipd`](https://github.com/wevm/mipd) library and converting to [injected](https://wagmi.sh/react/api/connectors/injected) connectors.
*   Defaults to `true`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      multiInjectedProviderDiscovery: false, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### ssr [‚Äã](#ssr)

`boolean | undefined`

Flag to indicate if the config is being used in a server-side rendering environment. Defaults to `false`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### storage [‚Äã](#storage)

`Storage | null | undefined`

*   [`Storage`](https://wagmi.sh/react/api/createStorage#storage) used by the config. Persists `Config`'s [`State`](#state-1) between sessions.
*   Defaults to `createStorage({ storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage })`.

ts

    import { createConfig, createStorage, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      storage: createStorage({ storage: window.localStorage }), 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Keep the [`State['chainId']`](#chainid) in sync with the current connection.
*   Defaults to `true`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      syncConnectedChain: false, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

* * *

### batch [‚Äã](#batch)

`{ multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | { [_ in chains[number]["id"]]?: { multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | undefined } | undefined`

*   Batch settings. See [Viem docs](https://viem.sh/docs/clients/custom.html#batch-optional) for more info.
*   Defaults to `{ multicall: true }`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      batch: { multicall: true }, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### cacheTime [‚Äã](#cachetime)

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

*   Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/public.html#cachetime-optional) for more info.
*   Defaults to [`pollingInterval`](#pollinginterval) or `4_000`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      cacheTime: 4_000, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

*   Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/custom.html#pollinginterval-optional) for more info.
*   Defaults to `4_000`.

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      pollingInterval: 4_000, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### transports [‚Äã](#transports)

`Record<chains[number]['id'], Transport>`

Mapping of [chain IDs](#chains) to [`Transport`](https://wagmi.sh/react/api/transports)s. This mapping is used internally when creating chain-aware Viem [`Client`](https://viem.sh/docs/clients/custom.html) objects. See the [Transport docs](https://wagmi.sh/react/api/transports) for more info.

ts

    import { createConfig, fallback, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      transports: { 
        [mainnet.id]: fallback([ 
          http('https://...'), 
          http('https://...'), 
        ]), 
        [sepolia.id]: http('https://...'), 
      }, 
    })

* * *

### client [‚Äã](#client)

`(parameters: { chain: chains[number] }) => Client<Transport, chains[number]>`

Function for creating new Viem [`Client`](https://viem.sh/docs/clients/custom.html) to be used internally. Exposes more control over the internal `Client` creation logic versus using the [`transports`](#transports) property.

ts

    import { createClient, http } from 'viem'
    import { createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      client({ chain }) { 
        return createClient({ chain, transport: http('https://...') }) 
      }, 
    })

WARNING

When using this option, you likely want to pass `parameters.chain` straight through to [`createClient`](https://viem.sh/docs/clients/custom.html#createclient) to ensure the Viem `Client` is in sync with any active connections.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type Config } from 'wagmi'

Config [‚Äã](#config)
-------------------

Object responsible for managing Wagmi state and internals.

ts

    import { type Config } from 'wagmi'

### chains [‚Äã](#chains-1)

`readonly [Chain, ...Chain[]]`

[`chains`](#chains) passed to `createConfig`.

### connectors [‚Äã](#connectors-1)

`readonly Connector[]`

Connectors set up from passing [`connectors`](#connectors) and [`multiInjectedProviderDiscovery`](#multiinjectedproviderdiscovery) to `createConfig`.

### state [‚Äã](#state)

`State<chains>`

The `Config` object's internal state. See [`State`](#state-1) for more info.

### storage [‚Äã](#storage-1)

`Storage | null`

[`storage`](#storage) passed to `createConfig`.

### getClient [‚Äã](#getclient)

`(parameters?: { chainId?: chainId | chains[number]['id'] | undefined }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>`

Creates new Viem [`Client`](https://viem.sh/docs/clients/custom.html) object.

index.tsconfig.ts

ts

    import { config } from './config'
    
    const client = config.getClient({ chainId: 1 })

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### setState [‚Äã](#setstate)

`(value: State<chains> | ((state: State<chains>) => State<chains>)) => void`

Updates the `Config` object's internal state. See [`State`](#state-1) for more info.

index.tsconfig.ts

ts

    import { mainnet } from 'wagmi/chains'
    import { config } from './config'
    
    config.setState((x) => ({
      ...x,
      chainId: x.current ? x.chainId : mainnet.id,
    }))

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

WARNING

Exercise caution when using this method. It is intended for internal and advanced use-cases only. Manually setting state can cause unexpected behavior.

### subscribe [‚Äã](#subscribe)

`(selector: (state: State<chains>) => state, listener: (selectedState: state, previousSelectedState: state) => void, options?: { emitImmediately?: boolean | undefined; equalityFn?: ((a: state, b: state) => boolean) | undefined } | undefined) => (() => void)`

Listens for state changes matching the `selector` function. Returns a function that can be called to unsubscribe the listener.

index.tsconfig.ts

ts

    import { config } from './config'
    
    const unsubscribe = config.subscribe(
      (state) => state.chainId,
      (chainId) => console.log(`Chain ID changed to ${chainId}`),
    )
    unsubscribe()

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

State [‚Äã](#state-1)
-------------------

ts

    import { type State } from 'wagmi'

### chainId [‚Äã](#chainid)

`chains[number]['id']`

Current chain ID. When `syncConnectedChain` is `true`, `chainId` is kept in sync with the current connection. Defaults to first chain in [`chains`](#chains).

### connections [‚Äã](#connections)

`Map<string, Connection>`

Mapping of unique connector identifier to [`Connection`](#connection) object.

### current [‚Äã](#current)

`string | undefined`

Unique identifier of the current connection.

### status [‚Äã](#status)

`'connected' | 'connecting' | 'disconnected' | 'reconnecting'`

Current connection status.

*   `'connecting'` attempting to establish connection.
*   `'reconnecting'` attempting to re-establish connection to one or more connectors.
*   `'connected'` at least one connector is connected.
*   `'disconnected'` no connection to any connector.

Connection [‚Äã](#connection)
---------------------------

ts

    import { type Connection } from 'wagmi'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Array of addresses associated with the connection.

### chainId [‚Äã](#chainid-1)

`number`

Chain ID associated with the connection.

### connector [‚Äã](#connector)

`Connector`

Connector associated with the connection.</content>
</page>

<page>
  <title>Chains | Wagmi</title>
  <url>https://wagmi.sh/react/api/chains</url>
  <content>Viem `Chain` objects. More info at the [Viem docs](https://viem.sh/docs/chains/introduction).

Import [‚Äã](#import)
-------------------

Import via the `'wagmi/chains'` entrypoint (proxies all chains from `'viem/chains'`).

ts

    import { mainnet } from 'wagmi/chains'

Available Chains [‚Äã](#available-chains)
---------------------------------------

Chain definitions as of `viem@2.23.12`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

266 Chains

OP Mainnet

`optimism`

10 - ETH

Flare Mainnet

`flare`

14 - FLR

Coston

`songbirdTestnet`

16 - CFLR

Songbird Mainnet

`songbird`

19 - SGB

Cronos Mainnet

`cronos`

25 - CRO

Rootstock Mainnet

`rootstock`

30 - RBTC

Rootstock Testnet

`rootstockTestnet`

31 - tRBTC

Telos

`telosTestnet`

41 - TLOS

Darwinia Network

`darwinia`

46 - RING

XinFin Network

`xdc`

50 - XDC

Apothem Network

`xdcTestnet`

51 - TXDC

BNB Smart Chain

`bsc`

56 - BNB

Syscoin Mainnet

`syscoin`

57 - SYS

Ethereum Classic

`classic`

61 - ETC

Conflux eSpace Testnet

`confluxESpaceTestnet`

71 - CFX

Meter Testnet

`meterTestnet`

83 - MTR

Binance Smart Chain Testnet

`bscTestnet`

97 - tBNB

Shibarium

`shibarium`

109 - BONE

Coston2

`flareTestnet`

114 - C2FLR

Fuse Sparknet

`fuseSparknet`

123 - SPARK

Polygon

`polygon`

137 - MATIC

Manta Pacific Mainnet

`manta`

169 - ETH

X1 Testnet

`x1Testnet`

195 - OKB

X1 Testnet

`xLayerTestnet`

195 - OKB

X Layer Mainnet

`xLayer`

196 - OKB

BitTorrent

`bitTorrent`

199 - BTT

Edgeless Testnet

`edgelessTestnet`

202 - EwETH

Nexilix Smart Chain

`nexilix`

240 - NEXILIX

Fraxtal

`fraxtal`

252 - frxETH

zkSync InMemory Node

`zkSyncInMemoryNode`

260 - ETH

zkSync CLI Local Node

`zkSyncLocalNode`

270 - ETH

zkSync Era Testnet

`zkSyncTestnet`

280 - ETH

Boba Network

`boba`

288 - ETH

Hedera Mainnet

`hedera`

295 - HBAR

Hedera Testnet

`hederaTestnet`

296 - HBAR

Hedera Previewnet

`hederaPreviewnet`

297 - HBAR

zkSync Sepolia Testnet

`zkSyncSepoliaTestnet`

300 - ETH

Filecoin Mainnet

`filecoin`

314 - FIL

zkSync Era

`zkSync`

324 - ETH

Cronos Testnet

`cronosTestnet`

338 - tCRO

PulseChain

`pulsechain`

369 - PLS

Optimism Goerli

`optimismGoerli`

420 - ETH

Areon Network Testnet

`areonNetworkTestnet`

462 - TAREA

Areon Network

`areonNetwork`

463 - AREA

FlowEVM Testnet

`flowTestnet`

545 - FLOW

Rollux Mainnet

`rollux`

570 - SYS

MetaChain Mainnet

`metachain`

571 - MTC

Mandala TC9

`mandala`

595 - mACA

Metis Goerli

`metisGoerli`

599 - METIS

FlowEVM Previewnet

`flowPreviewnet`

646 - FLOW

FlowEVM Mainnet

`flowMainnet`

747 - FLOW

Taraxa Mainnet

`taraxa`

841 - TARA

Taraxa Testnet

`taraxaTestnet`

842 - TARA

Wanchain

`wanchain`

888 - WAN

Mode Testnet

`modeTestnet`

919 - ETH

PulseChain V4

`pulsechainV4`

943 - v4PLS

5ireChain Thunder Testnet

`thunderTestnet`

997 - 5IRE

Wanchain Testnet

`wanchainTestnet`

999 - WANt

Zora Goerli Testnet

`zoraTestnet`

999 - ETH

Klaytn Baobab Testnet

`klaytnBaobab`

1001 - KLAY

Ekta Testnet

`ektaTestnet`

1004 - EKTA

BNB Greenfield Chain

`bscGreenfield`

1017 - BNB

BitTorrent Chain Testnet

`bitTorrentTestnet`

1028 - BTT

Conflux eSpace

`confluxESpace`

1030 - CFX

Bronos Testnet

`bronosTestnet`

1038 - tBRO

Shimmer Testnet

`shimmerTestnet`

1073 - SMR

Polygon zkEVM

`polygonZkEvm`

1101 - ETH

WEMIX Testnet

`wemixTestnet`

1112 - tWEMIX

Core Dao

`coreDao`

1116 - CORE

DeFiChain EVM Mainnet

`defichainEvm`

1130 - DFI

DeFiChain EVM Testnet

`defichainEvmTestnet`

1131 - DFI

Moonbeam Development Node

`moonbeamDev`

1281 - DEV

Moonbeam

`moonbeam`

1284 - GLMR

Moonriver

`moonriver`

1285 - MOVR

Moonbase Alpha

`moonbaseAlpha`

1287 - DEV

Localhost

`localhost`

1337 - ETH

Polygon zkEVM Testnet

`polygonZkEvmTestnet`

1442 - ETH

MetaChain Istanbul

`metachainIstanbul`

1453 - MTC

Horizen Gobi Testnet

`gobi`

1663 - tZEN

Mint Sepolia Testnet

`mintSepoliaTestnet`

1686 - ETH

Reya Network

`reyaNetwork`

1729 - ETH

LightLink Phoenix Mainnet

`lightlinkPhoenix`

1890 - ETH

LightLink Pegasus Testnet

`lightlinkPegasus`

1891 - ETH

Dogechain

`dogechain`

2000 - DC

Telcoin Adiri Testnet

`telcoinTestnet`

2017 - TEL

Edgeware EdgeEVM Mainnet

`edgeware`

2021 - EDG

Saigon Testnet

`saigon`

2021 - RON

Beresheet BereEVM Testnet

`edgewareTestnet`

2022 - tEDG

Edgeless Network

`edgeless`

2026 - EwETH

Kava EVM Testnet

`kavaTestnet`

2221 - KAVA

RSS3 VSL Sepolia Testnet

`rss3Sepolia`

2331 - RSS3

Kroma Sepolia

`kromaSepolia`

2358 - ETH

Polygon zkEVM Cardona

`polygonZkEvmCardona`

2442 - ETH

Fraxtal Testnet

`fraxtalTestnet`

2522 - frxETH

inEVM Mainnet

`inEVM`

2525 - INJ

Morph Sepolia

`morphSepolia`

2710 - ETH

Filecoin Hyperspace

`filecoinHyperspace`

3141 - tFIL

Crossbell

`crossbell`

3737 - CSB

Astar zkEVM

`astarZkEVM`

3776 - ETH

APEX Testnet

`apexTestnet`

3993 - ETH

Fantom Testnet

`fantomTestnet`

4002 - FTM

Oasis Testnet

`oasisTestnet`

4090 - FTN

LUKSO Testnet

`luksoTestnet`

4201 - LYXt

Lisk Sepolia

`liskSepolia`

4202 - ETH

IoTeX Testnet

`iotexTestnet`

4690 - IOTX

MEVerse Chain Testnet

`mevTestnet`

4759 - MEV

BlackFort Exchange Network Testnet

`bxnTestnet`

4777 - TBXN

BlackFort Exchange Network

`bxn`

4999 - BXN

Mantle Testnet

`mantleTestnet`

5001 - MNT

Mantle Sepolia Testnet

`mantleSepoliaTestnet`

5003 - MNT

opBNB Testnet

`opBNBTestnet`

5611 - tBNB

Syscoin Tanenbaum Testnet

`syscoinTestnet`

5700 - SYS

ZetaChain

`zetachain`

7000 - ZETA

ZetaChain Athens Testnet

`zetachainAthensTestnet`

7001 - aZETA

MEVerse Chain Mainnet

`mev`

7518 - MEV

Shardeum Sphinx

`shardeumSphinx`

8082 - SHM

Evmos Testnet

`evmosTestnet`

9000 - EVMOS

OORT MainnetDev

`oortMainnetDev`

9700 - OORT

Gnosis Chiado

`gnosisChiado`

10200 - xDAI

HAQQ Mainnet

`haqqMainnet`

11235 - ISLM

BEVM Mainnet

`bevmMainnet`

11501 - BTC

Fibo Chain

`fibo`

12306 - FIBO

RSS3 VSL Mainnet

`rss3`

12553 - RSS3

Beam Testnet

`beamTestnet`

13337 - BEAM

Immutable zkEVM

`immutableZkEvm`

13371 - IMX

Phoenix Blockchain

`phoenix`

13381 - PHX

Immutable zkEVM Testnet

`immutableZkEvmTestnet`

13473 - IMX

EOS EVM Testnet

`eosTestnet`

15557 - EOS

Holesky

`holesky`

17000 - ETH

Oasis Sapphire

`sapphire`

23294 - ROSE

Oasis Sapphire Testnet

`sapphireTestnet`

23295 - TEST

DreyerX Mainnet

`dreyerxMainnet`

23451 - DRX

Foundry

`foundry`

31337 - ETH

Hardhat

`hardhat`

31337 - ETH

Zilliqa

`zilliqa`

32769 - ZIL

Zilliqa Testnet

`zilliqaTestnet`

33101 - ZIL

Mode Mainnet

`mode`

34443 - ETH

Q Mainnet

`qMainnet`

35441 - Q

Q Testnet

`qTestnet`

35443 - Q

Arbitrum One

`arbitrum`

42161 - ETH

Arbitrum Nova

`arbitrumNova`

42170 - ETH

ZKFair Mainnet

`zkFair`

42766 - USDC

Avalanche Fuji

`avalancheFuji`

43113 - AVAX

Avalanche

`avalanche`

43114 - AVAX

ZKFair Testnet

`zkFairTestnet`

43851 - USDC

Alfajores

`celoAlfajores`

44787 - A-CELO

Yooldo Verse

`yooldoVerse`

50005 - OAS

Yooldo Verse Testnet

`yooldoVerseTestnet`

50006 - OAS

DODOchain Testnet

`dodochainTestnet`

53457 - DODO

DFK Chain

`dfk`

53935 - JEWEL

HAQQ Testedge 2

`haqqTestedge2`

54211 - ISLMT

Rollux Testnet

`rolluxTestnet`

57000 - SYS

PGN

`pgnTestnet`

58008 - ETH

Linea Goerli Testnet

`lineaGoerli`

59140 - ETH

Linea Goerli Testnet

`lineaTestnet`

59140 - ETH

Linea Sepolia Testnet

`lineaSepolia`

59141 - ETH

Linea Mainnet

`linea`

59144 - ETH

Fantom Sonic Open Testnet

`fantomSonicTestnet`

64240 - FTM

Polygon Mumbai

`polygonMumbai`

80001 - MATIC

Polygon Amoy

`polygonAmoy`

80002 - MATIC

Berachain Artio

`berachainTestnet`

80085 - BERA

Base Goerli

`baseGoerli`

84531 - ETH

Base Sepolia

`baseSepolia`

84532 - ETH

Chiliz Spicy Testnet

`spicy`

88882 - CHZ

Chiliz Chain

`chiliz`

88888 - CHZ

Jibchain Testnet

`jbcTestnet`

88991 - tJBC

Vechain

`vechain`

100009 - VET

Stratis Mainnet

`stratis`

105105 - STRAX

Etherlink Testnet

`etherlinkTestnet`

128123 - XTZ

Taiko (Alpha-3 Testnet)

`taikoTestnetSepolia`

167005 - ETH

Taiko Jolnir (Alpha-5 Testnet)

`taikoJolnir`

167007 - ETH

Taiko Katla (Alpha-6 Testnet)

`taikoKatla`

167008 - ETH

Taiko Hekla L2

`taikoHekla`

167009 - ETH

Bitlayer Testnet

`btrTestnet`

200810 - ETH

Auroria Testnet

`auroria`

205205 - tSTRAX

Filecoin Calibration

`filecoinCalibration`

314159 - tFIL

Arbitrum Goerli

`arbitrumGoerli`

421613 - ETH

Arbitrum Sepolia

`arbitrumSepolia`

421614 - ETH

Scroll Sepolia

`scrollSepolia`

534351 - ETH

Scroll Testnet

`scrollTestnet`

534353 - ETH

Bear Network Chain Mainnet

`bearNetworkChainMainnet`

641230 - BRNKC

Sei Devnet

`seiDevnet`

713715 - SEI

Bear Network Chain Testnet

`bearNetworkChainTestnet`

751230 - tBRNKC

Zhejiang

`zhejiang`

1337803 - ZhejETH

PlayFi Albireo Testnet

`playfiAlbireo`

1612127 - ETH

Manta Pacific Testnet

`mantaTestnet`

3441005 - ETH

Manta Pacific Sepolia Testnet

`mantaSepoliaTestnet`

3441006 - ETH

Astar zkEVM Testnet zKyoto

`astarZkyoto`

6038361 - ETH

Sepolia

`sepolia`

11155111 - ETH

OP Sepolia

`optimismSepolia`

11155420 - ETH

Ancient8 Testnet

`ancient8Sepolia`

28122024 - ETH

SKALE Nebula Testnet

`skaleNebulaTestnet`

37084624 - sFUEL

Otim Devnet

`otimDevnet`

41144114 - ETH

Cyber Testnet

`cyberTestnet`

111557560 - ETH

Plume Testnet

`plumeTestnet`

161221135 - ETH

Blast Sepolia

`blastSepolia`

168587773 - ETH

Neon EVM DevNet

`neonDevnet`

245022926 - NEON

Neon EVM MainNet

`neonMainnet`

245022934 - NEON

SKALE | Razor Network

`skaleRazor`

278611351 - sFUEL

SKALE | Block Brawlers

`skaleBlockBrawlers`

391845894 - BRAWL

Degen

`degen`

666666666 - DEGEN

Ancient8

`ancient8`

888888888 - ETH

SKALE Calypso Testnet

`skaleCalypsoTestnet`

974399131 - sFUEL

Zora Sepolia

`zoraSepolia`

999999999 - ETH

SKALE Titan Hub

`skaleTitanTestnet`

1020352220 - sFUEL

SKALE | CryptoBlades

`skaleCryptoBlades`

1026062157 - sFUEL

SKALE | Crypto Colosseum

`skaleCryptoColosseum`

1032942172 - sFUEL

SKALE | Human Protocol

`skaleHumanProtocol`

1273227453 - sFUEL

Aurora

`aurora`

1313161554 - ETH

Aurora Testnet

`auroraTestnet`

1313161555 - ETH

SKALE | Titan Community Hub

`skaleTitan`

1350216234 - sFUEL

SKALE Europa Testnet

`skaleEuropaTestnet`

1444673419 - sFUEL

SKALE | Nebula Gaming Hub

`skaleNebula`

1482601649 - sFUEL

SKALE | Calypso NFT Hub

`skaleCalypso`

1564830818 - sFUEL

Harmony One

`harmonyOne`

1666600000 - ONE

SKALE | Europa Liquidity Hub

`skaleEuropa`

2046399126 - sFUEL

SKALE | Exorde

`skaleExorde`

2139927552 - sFUEL

Palm Testnet

`palmTestnet`

11297108099 - PALM

Palm

`palm`

11297108109 - PALM

Kakarot Sepolia

`kakarotSepolia`

107107114116 - ETH

Create Chain [‚Äã](#create-chain)
-------------------------------

Import the `Chain` type from Viem and create a new object that is asserted `as const` and `satisfies` the type. You can also use the `defineChain` function from Viem.

as const satisfies ChaindefineChain

ts

    import { type  } from 'viem'
    
    export const  = {} as  satisfies Type '{}' does not satisfy the expected type 'Chain'.
      Type '{}' is missing the following properties from type 'Chain': id, name, nativeCurrency, rpcUrls

ts

    import {  } from 'viem'
    
    export const  = ({})Argument of type '{}' is not assignable to parameter of type 'Chain<ChainFormatters>'.
      Type '{}' is missing the following properties from type 'Chain<ChainFormatters>': id, name, nativeCurrency, rpcUrls

Now, add the missing required properties to the object until the error goes away.

as const satisfies ChaindefineChain

ts

    import { type  } from 'viem'
    
    export const  = {
      : 1,
      : 'Ethereum',
      : { : 'Ether', : 'ETH', : 18 },
      : {
        : { : ['https://eth.merkle.io'] },
      },
      : {
        : { : 'Etherscan', : 'https://etherscan.io' },
      },
      : {
        : {
          : '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        : {
          : '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
          : 16773775,
        },
        : {
          : '0xca11bde05977b3631167028862be2a173976ca11',
          : 14353601,
        },
      },
    } as  satisfies 

ts

    import {  } from 'viem'
    
    export const  = ({
      : 1,
      : 'Ethereum',
      : { : 'Ether', : 'ETH', : 18 },
      : {
        : { : ['https://eth.merkle.io'] },
      },
      : {
        : { : 'Etherscan', : 'https://etherscan.io' },
      },
      : {
        : {
          : '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        : {
          : '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
          : 16773775,
        },
        : {
          : '0xca11bde05977b3631167028862be2a173976ca11',
          : 14353601,
        },
      },
    })

The more properties you add, the better the chain will be to use with Wagmi. Most of these attributes exist within the [`ethereum-lists/chains` repository](https://github.com/ethereum-lists/chains/tree/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains).

*   `id`: The chain ID for the network. This can be found by typing the network name into [ChainList](https://chainlist.org/). Example: "Ethereum Mainnet" has a Chain ID of `1`.
*   `name`: Human-readable name for the chain. Example: "Ethereum Mainnet"
*   `nativeCurrency`: The native currency of the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L20-L24).
*   `rpcUrls`: At least one public, credible RPC URL. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L4-L18).
*   `blockExplorers`: A set of block explorers for the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L30-L36).
*   `contracts`: A set of deployed contracts for the chain. If you are deploying one of the following contracts yourself, make sure it is verified.
    *   `multicall3` is optional, but it's address is most likely `0xca11bde05977b3631167028862be2a173976ca11` ‚Äì you can find the deployed block number on the block explorer. Check out [`mds1/multicall`](https://github.com/mds1/multicall#multicall3-contract-addresses) for more info.
    *   `ensRegistry` is optional ‚Äì not all Chains have a ENS Registry. See [ENS Deployments](https://docs.ens.domains/ens-deployments) for more info.
    *   `ensUniversalResolver` is optional ‚Äì not all Chains have a ENS Universal Resolver.
*   `sourceId`: Source Chain ID (e.g. the L1 chain).
*   `testnet`: Whether or not the chain is a testnet.</content>
</page>

<page>
  <title>injected | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors/injected</url>
  <content>Connector for [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Providers.

Import [‚Äã](#import)
-------------------

ts

    import { injected } from 'wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { injected } from 'wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type InjectedParameters } from 'wagmi/connectors'

### shimDisconnect [‚Äã](#shimdisconnect)

`boolean | undefined`

*   MetaMask and other injected providers do not support programmatic disconnect.
*   This flag simulates the disconnect behavior by keeping track of connection status in storage. See [GitHub issue](https://github.com/MetaMask/metamask-extension/issues/10353) for more info.
*   Defaults to `true`.

ts

    import { injected } from 'wagmi/connectors'
    
    const connector = injected({
      shimDisconnect: false, 
    })

### target [‚Äã](#target)

`TargetId | (TargetMap[TargetId] & { id: string }) | (() => (TargetMap[TargetId] & { id: string }) | undefined) | undefined`

*   [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target.
*   [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) supported via `createConfig`'s [`multiInjectedProviderDiscovery`](https://wagmi.sh/react/api/createConfig#multiinjectedproviderdiscovery) property.

ts

    import { injected } from 'wagmi/connectors'
    
    const connector = injected({
      target() { 
        return { 
          id: 'windowProvider', 
          name: 'Window Provider', 
          provider: window.ethereum, 
        } 
      }, 
    })

### unstable\_shimAsyncInject [‚Äã](#unstable-shimasyncinject)

`boolean | number | undefined`

Watches for async provider injection via the `ethereum#initialized` event. When `true`, defaults to `1_000` milliseconds. Otherwise, uses a provided value of milliseconds.

ts

    import { injected } from 'wagmi/connectors'
    
    const connector = injected({
      unstable_shimAsyncInject: 2_000, 
    })</content>
</page>

<page>
  <title>createStorage | Wagmi</title>
  <url>https://wagmi.sh/react/api/createStorage</url>
  <content>Creates new [`Storage`](#storage) object.

Import [‚Äã](#import)
-------------------

ts

    import { createStorage } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { createStorage } from 'wagmi'
    
    const storage = createStorage({ storage: localStorage })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateStorageParameters } from 'wagmi'

### deserialize [‚Äã](#deserialize)

`(<T>(value: string) => T) | undefined`

*   Function to deserialize data from storage.
*   Defaults to [`deserialize`](https://wagmi.sh/react/api/utilities/deserialize).

ts

    import { createStorage, deserialize } from 'wagmi'
    
    const storage = createStorage({
      deserialize, 
      storage: localStorage,
    })

WARNING

If you use a custom `deserialize` function, make sure it can handle `bigint` and `Map` values.

### key [‚Äã](#key)

`string | undefined`

*   Key prefix to use when persisting data.
*   Defaults to `'wagmi'`.

ts

    import { createStorage } from 'wagmi'
    
    const storage = createStorage({
      key: 'my-app', 
      storage: localStorage,
    })

### serialize [‚Äã](#serialize)

`(<T>(value: T) => string) | undefined`

*   Function to serialize data for storage.
*   Defaults to [`serialize`](https://wagmi.sh/react/api/utilities/serialize).

ts

    import { createStorage, serialize } from 'wagmi'
    
    const storage = createStorage({
      serialize, 
      storage: localStorage,
    })

WARNING

If you use a custom `serialize` function, make sure it can handle `bigint` and `Map` values.

### storage [‚Äã](#storage)

`{ getItem(key: string): string | null | undefined | Promise<string | null | undefined>; setItem(key: string, value: string): void | Promise<void>; removeItem(key: string): void | Promise<void>; }`

*   Storage interface to use for persisting data.
*   Defaults to `localStorage`.
*   Supports synchronous and asynchronous storage methods.

ts

    import { createStorage } from 'wagmi'
    // Using IndexedDB via https://github.com/jakearchibald/idb-keyval
    import { del, get, set } from 'idb-keyval'
    
    const storage = createStorage({
      storage: { 
        async getItem(name) { 
          return get(name)
        }, 
        async setItem(name, value) { 
          await set(name, value) 
        }, 
        async removeItem(name) { 
          await del(name) 
        }, 
      }, 
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type Storage } from 'wagmi'

Storage [‚Äã](#storage-1)
-----------------------

Object responsible for persisting Wagmi [`State`](https://wagmi.sh/react/api/createConfig#state-1) and other data.

ts

    import { type Storage } from 'wagmi'

### getItem [‚Äã](#getitem)

`getItem(key: string, defaultValue?: value | null | undefined): value | null | Promise<value | null>`

ts

    import { createStorage } from 'wagmi'
    
    const storage = createStorage({ storage: localStorage })
    const recentConnectorId = storage.getItem('recentConnectorId')

### setItem [‚Äã](#setitem)

`setItem(key: string, value: any): void | Promise<void>`

ts

    import { createStorage } from 'wagmi'
    
    const storage = createStorage({ storage: localStorage })
    storage.setItem('recentConnectorId', 'foo')

### removeItem [‚Äã](#removeitem)

`removeItem(key: string): void | Promise<void>`

ts

    import { createStorage } from 'wagmi'
    
    const storage = createStorage({ storage: localStorage })
    storage.removeItem('recentConnectorId')</content>
</page>

<page>
  <title>coinbaseWallet | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors/coinbaseWallet</url>
  <content>Connector for the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk).

Import [‚Äã](#import)
-------------------

ts

    import { coinbaseWallet } from 'wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { coinbaseWallet } from 'wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [coinbaseWallet()], 
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Before going to production, it is highly recommended to set an [`appName`](#appname) and [`appLogoUrl`](#applogourl) for your application that can be displayed upon connection to the wallet.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CoinbaseWalletParameters } from 'wagmi/connectors'

Check out the [Coinbase Wallet SDK docs](https://github.com/coinbase/coinbase-wallet-sdk) for more info.

### appName [‚Äã](#appname)

`string`

Application name.

ts

    import { coinbaseWallet } from 'wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App', 
    })

### appLogoUrl [‚Äã](#applogourl)

`string | null | undefined`

Application logo image URL; favicon is used if unspecified.

ts

    import { coinbaseWallet } from 'wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      appLogoUrl: 'https://example.com/myLogoUrl.png', 
    })

### headlessMode deprecated [‚Äã](#headlessmode)

`boolean | undefined`

*   Whether or not onboarding overlay popup should be displayed.
*   `headlessMode` will be removed in the next major version. Upgrade to [`version: '4'`](#version).

ts

    import { coinbaseWallet } from 'wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      headlessMode: false, 
    })

### preference \>=2.9.0 [‚Äã](#preference)

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

*   `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
*   `'smartWalletOnly'`: Displays Smart Wallet popup.
*   `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

ts

    import { coinbaseWallet } from 'wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      preference: 'smartWalletOnly', 
    })

WARNING

Passing `preference` as a string is deprecated and will be removed in the next major version. Instead you should use [`preference#options`](#options).

ts

    import { coinbaseWallet } from 'wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      preference: { 
        options: 'smartWalletOnly'
      }, 
    })

#### attribution \>=2.12.33 [‚Äã](#attribution)

``{ auto?: boolean | undefined; dataSuffix?: `0x${string}` | undefined }``

This option only applies to Coinbase Smart Wallet. When a valid data suffix is supplied, it is appended to the `initCode` and `executeBatch` calldata. Coinbase Smart Wallet expects a 16 byte hex string. If the data suffix is not a 16 byte hex string, the Smart Wallet will ignore the property. If auto is true, the Smart Wallet will generate a 16 byte hex string from the apps origin.

#### keysUrl \>=2.12.33 [‚Äã](#keysurl)

`string`

*   The URL for the keys popup.
*   By default, `https://keys.coinbase.com/connect` is used for production. Use `https://keys-dev.coinbase.com/connect` for development environments.

#### options \>=2.12.33 [‚Äã](#options)

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

*   `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
*   `'smartWalletOnly'`: Displays Smart Wallet popup.
*   `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

### version \>=2.13.0 [‚Äã](#version)

*   Coinbase Wallet SDK version
*   Defaults to `'4'`. If [`headlessMode: true`](#headlessmode), defaults to `'3'`.

ts

    import { coinbaseWallet } from 'wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      version: '4', 
    })</content>
</page>

<page>
  <title>metaMask | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors/metaMask</url>
  <content>Connector for [MetaMask SDK](https://github.com/MetaMask/metamask-sdk).

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/metamask-sdk/javascript) for more information.

Import [‚Äã](#import)
-------------------

ts

    import { metaMask } from 'wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { metaMask } from 'wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [metaMask()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MetaMaskParameters } from 'wagmi/connectors'

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/3rd-party-libraries/wagmi/) for more info. A few options are omitted that Wagmi manages internally.

### dappMetadata [‚Äã](#dappmetadata)

`DappMetadata | undefined`

Metadata is used to fill details for the UX on confirmation screens in MetaMask, including the following fields:

*   `name`: `string` - The name of the dapp.
*   `url`: `string` - URL of the dapp (defaults to `window.location.origin`).
*   `iconUrl`: `string` - URL to the dapp's favicon or icon.

ts

    import { metaMask } from 'wagmi/connectors'
    
    const connector = metaMask({
      dappMetadata: { 
        name: 'My Wagmi App', 
        url: 'https://example.com', 
        iconUrl: 'https://example.com/favicon.ico', 
      }
    })

### logging [‚Äã](#logging)

`SDKLoggingOptions | undefined`

Enables SDK-side logging to provide visibility into:

*   RPC methods being called.
*   Events received for syncing the chain or active account.
*   Raw RPC responses.

In this context, this is especially useful to observe what calls are made through Wagmi hooks.

Relevant options:

ts

    {
      developerMode: boolean, // Enables developer mode logs
      sdk: boolean           // Enables SDK-specific logs
    }

ts

    import { metaMask } from '{{connectorsPackageName}}'
    
    const connector = metaMask({
      logging: { developerMode: true, sdk: true } 
    })

### headless [‚Äã](#headless)

`boolean | undefined`

*   Enables headless mode, disabling MetaMask's built-in modal.
*   Allows developers to create their own modal, such as for displaying a QR code.

This is particularly relevant for web-only setups using Wagmi, where developers want complete control over the UI.

To get the deeplink to display in the QR code, listen to the `display_uri` event.

The default is `false`.

ts

    import { metaMask } from 'wagmi/connectors'
    
    const connector = metaMask({
      headless: true
    })

Advanced [‚Äã](#advanced)
-----------------------

By default, if the EIP-6963 MetaMask injected provider is detected, this connector will replace it.

EIP-6963 defines a standard way for dapps to interact with multiple wallets simultaneously by injecting providers into the browser. Wallets that implement this standard can make their presence known to dapps in a consistent and predictable manner.

When MetaMask SDK detects an EIP-6963-compliant provider (such as MetaMask itself), the connector will automatically replace the default injected provider (like `window.ethereum`) with the one provided by MetaMask SDK.

See the [`rdns` property](https://wagmi.sh/dev/creating-connectors#properties) for more information.</content>
</page>

<page>
  <title>Migrate from v1 to v2</title>
  <url>https://wagmi.sh/react/guides/migrate-from-v1-to-v2</url>
  <content>Overview [‚Äã](#overview)
-----------------------

Wagmi v2 redesigns the core APIs to mesh better with [Viem](https://viem.sh/) and [TanStack Query](https://tanstack.com/query/v5/docs/react). This major version transforms Wagmi into a light wrapper around these libraries, sprinkling in multichain support and account management. As such, there are some breaking changes and deprecations to be aware of outlined in this guide.

To get started, install the latest version of Wagmi and it's required peer dependencies.

pnpmnpmyarnbun

bash

    pnpm add wagmi viem@2.x @tanstack/react-query

bash

    npm install wagmi viem@2.x @tanstack/react-query

bash

    yarn add wagmi viem@2.x @tanstack/react-query

bash

    bun add wagmi viem@2.x @tanstack/react-query

Wagmi v2 should be the last major version that will have this many actionable breaking changes.

Moving forward after Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Dependencies [‚Äã](#dependencies)
-------------------------------

### Moved TanStack Query to peer dependencies [‚Äã](#moved-tanstack-query-to-peer-dependencies)

Wagmi uses [TanStack Query](https://tanstack.com/query/v5/docs/react) to manage async state, handling requests, caching, and more. With Wagmi v1, TanStack Query was an internal implementation detail. With Wagmi v2, TanStack Query is a peer dependency. A lot of Wagmi users also use TanStack Query in their apps so making it a peer dependency gives them more control and removes some custom Wagmi code internally.

If you don't normally use TanStack Query, all you need to do is set it up and mostly forget about it (we'll provide guidance around version updates).

app.tsxconfig.ts

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    const queryClient = new QueryClient()
    
    function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            {/** ... */}
          </QueryClientProvider>
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

For more information on setting up TanStack Query for Wagmi, follow the [Getting Started docs](https://wagmi.sh/react/getting-started#setup-tanstack-query). If you want to set up persistence for your query cache (default behavior before Wagmi v2), check out the [TanStack Query docs](https://tanstack.com/query/v5/docs/react/plugins/persistQueryClient#usage-with-react).

### Dropped CommonJS support [‚Äã](#dropped-commonjs-support)

Wagmi v2 no longer publishes a separate `cjs` tag since very few people use this tag and ESM is the future. See [Sindre Sorhus' guide](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c) for more info about switching to ESM.

Hooks [‚Äã](#hooks)
-----------------

### Removed mutation setup arguments [‚Äã](#removed-mutation-setup-arguments)

Mutation hooks are hooks that change network or application state, sign data, or perform write operations through mutation functions. With Wagmi v1, you could pass arguments directly to these hooks instead of using them with their mutation functions. For example:

ts

    // Wagmi v1
    const { signMessage } = useSignMessage({
      message: 'foo bar baz',
    })

With Wagmi v2, you must pass arguments to the mutation function instead. This follows the same behavior as [TanStack Query](https://tanstack.com/query/v5/docs/react/guides/mutations) mutations and improves type-safety.

tsx

    import { useSignMessage } from 'wagmi'
    
    const { signMessage } = useSignMessage({ message: 'foo bar baz' })
    const { signMessage } = useSignMessage()
    
    <button
      onClick={() => signMessage()}
      onClick={() => signMessage({ message: 'foo bar baz' })}
    >
      Sign message
    </button>

### Moved TanStack Query parameters to `query` property [‚Äã](#moved-tanstack-query-parameters-to-query-property)

Previously, you could pass TanStack Query parameters, like `enabled` and `staleTime`, directly to hooks. In Wagmi v2, TanStack Query parameters are now moved to the `query` property. This allows Wagmi to better support TanStack Query type inference, control for future breaking changes since [TanStack Query is now a peer dependency](#moved-tanstack-query-to-peer-dependencies), and expose Wagmi-related hook property at the top-level of editor features, like autocomplete.

tsx

    useReadContract({
      enabled: false,
      staleTime: 1_000,
      query: {
        enabled: false,
        staleTime: 1_000,
      },
    })

### Removed watch property [‚Äã](#removed-watch-property)

The `watch` property was removed from all hooks besides [`useBlock`](https://wagmi.sh/react/api/hooks/useBlock) and [`useBlockNumber`](https://wagmi.sh/react/api/hooks/useBlockNumber). This property allowed hooks to internally listen for block changes and automatically refresh their data. In Wagmi v2, you can compose `useBlock` or `useBlockNumber` along with [`React.useEffect`](https://react.dev/reference/react/useEffect) to achieve the same behavior. Two different approaches are outlined for `useBalance` below.

invalidateQueriesrefetch

ts

    import { useQueryClient } from '@tanstack/react-query'
    import { useEffect } from 'react'
    import { useBlockNumber, useBalance } from 'wagmi'
    
    const queryClient = useQueryClient()
    const { data: blockNumber } = useBlockNumber({ watch: true })
    const { data: balance, queryKey } = useBalance({ 
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      watch: true, 
    })
    
    useEffect(() => {
      queryClient.invalidateQueries({ queryKey })
    }, [blockNumber, queryClient])

ts

    import { useEffect } from 'react'
    import { useBlockNumber, useBalance } from 'wagmi'
    
    const { data: blockNumber } = useBlockNumber({ watch: true })
    const { data: balance, refetch } = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      watch: true, 
    })
    
    useEffect(() => {
      refetch()
    }, [blockNumber])

This is a bit more code, but removes a lot of internal code from hooks that can slow down your app when not used and gives you more control. For example, you can easily refresh data every five blocks instead of every block.

ts

    const { data: blockNumber } = useBlockNumber({ watch: true })
    const { data: balance, queryKey } = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    })
    
    useEffect(() => {
      if (blockNumber % 5 === 0)
        queryClient.invalidateQueries({ queryKey })
    }, [blockNumber, queryClient])

### Removed suspense property [‚Äã](#removed-suspense-property)

Wagmi used to support an experimental `suspense` property via TanStack Query. Since TanStack Query [removed `suspense`](https://tanstack.com/query/v5/docs/react/guides/migrating-to-v5#new-hooks-for-suspense) from its `useQuery` hook, it is no longer supported by Wagmi Hooks.

Instead, you can use `useSuspenseQuery` along with TanStack Query-related exports from the `'wagmi/query'` entrypoint.

ts

    import { useSuspenseQuery } from '@tanstack/react-query'
    import { useConfig } from 'wagmi'
    import { getBalanceQueryOptions } from 'wagmi/query'
    import { useBalance } from 'wagmi'
    
    const config = useConfig()
    const options = getBalanceQueryOptions(config, { address: '0x‚Ä¶' })
    const result = useSuspenseQuery(options)
    const result = useBalance({ 
      address: '0x‚Ä¶', 
      suspense: true, 
    })

### Removed prepare hooks [‚Äã](#removed-prepare-hooks)

`usePrepareContractWrite` and `usePrepareSendTransaction` were removed and replaced with idiomatic Viem alternatives. For `usePrepareContractWrite`, use [`useSimulateContract`](https://wagmi.sh/react/api/hooks/useSimulateContract). Similar to `usePrepareContractWrite`, `useSimulateContract` composes well with `useWriteContract`

tsx

    import { usePrepareContractWrite, useWriteContract } from 'wagmi'
    import { useSimulateContract, useWriteContract } from 'wagmi'
    
    const { config } = usePrepareContractWrite({
    const { data } = useSimulateContract({
      address: '0x',
      abi: [{
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      }],
      functionName: 'transferFrom',
      args: ['0x', '0x', 123n],
    })
    const { write } = useWriteContract(config)
    const { writeContract } = useWriteContract()
    
    <button
      disabled={!Boolean(write)}
      onClick={() => write()}
      disabled={!Boolean(data?.request)}
      onClick={() => writeContract(data!.request)}
    >
      Write contract
    </button>

Instead of `usePrepareSendTransaction`, use [`useEstimateGas`](https://wagmi.sh/react/api/hooks/useEstimateGas). You can pass `useEstimateGas` `data` to `useSendTransaction` to compose the two hooks.

tsx

    import { usePrepareSendTransaction, useSendTransaction } from 'wagmi'
    import { useEstimateGas, useSendTransaction } from 'wagmi'
    import { parseEther } from 'viem'
    
    const { config } = usePrepareSendTransaction({
    const { data } = useEstimateGas({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    const { sendTransaction } = useSendTransaction(config)
    const { sendTransaction } = useSendTransaction()
    
    <button
      disabled={!Boolean(sendTransaction)}
      onClick={() => sendTransaction()}
      disabled={!Boolean(data)}
      onClick={() => sendTransaction({
        gas: data,
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })}
    >
      Send transaction
    </button>

This might seem like more work, but it gives you more control and is more accurate representation of what is happening under the hood.

### Removed `useNetwork` hook [‚Äã](#removed-usenetwork-hook)

The `useNetwork` hook was removed since the connected chain is typically based on the connected account. Use [`useAccount`](https://wagmi.sh/react/api/hooks/useAccount) to get the connected `chain`.

ts

    import { useNetwork } from 'wagmi'
    import { useAccount } from 'wagmi'
    
    const { chain } = useNetwork()
    const { chain } = useAccount()

Use `useConfig` for the list of `chains` set up with the Wagmi [`Config`](https://wagmi.sh/react/api/createConfig#chains).

ts

    import { useNetwork } from 'wagmi'
    import { useConfig } from 'wagmi'
    
    const { chains } = useNetwork()
    const { chains } = useConfig()

### Removed `onConnect` and `onDisconnect` callbacks from `useAccount` [‚Äã](#removed-onconnect-and-ondisconnect-callbacks-from-useaccount)

The `onConnect` and `onDisconnect` callbacks were removed from the `useAccount` hook since it is frequently used without these callbacks so it made sense to extract these into a new API, [`useAccountEffect`](https://wagmi.sh/react/api/hooks/useAccountEffect), rather than clutter the `useAccount` hook.

ts

    import { useAccount } from 'wagmi'
    import { useAccountEffect } from 'wagmi'
    
    useAccount({ 
    useAccountEffect({ 
      onConnect(data) {
        console.log('connected', data)
      },
      onDisconnect() {
        console.log('disconnected')
      },
    })

### Removed `useWebSocketPublicClient` [‚Äã](#removed-usewebsocketpublicclient)

The Wagmi [`Config`](https://wagmi.sh/react/api/createConfig) does not separate transport types anymore. Simply use Viem's [`webSocket`](https://viem.sh/docs/clients/transports/websocket.html) transport instead when setting up your Wagmi `Config`. You can get Viem `Client` instance with this transport attached by using [`useClient`](https://wagmi.sh/react/api/hooks/useClient) or [`usePublicClient`](https://wagmi.sh/react/api/hooks/usePublicClient).

### Removed `useInfiniteReadContracts` `paginatedIndexesConfig` [‚Äã](#removed-useinfinitereadcontracts-paginatedindexesconfig)

In the spirit of removing unnecessary abstractions, `paginatedIndexesConfig` was removed. Use `useInfiniteReadContracts`'s `initialPageParam` and `getNextPageParam` parameters along with `fetchNextPage`/`fetchPreviousPage` from the result instead or copy `paginatedIndexesConfig`'s implementation to your codebase.

See the [TanStack Query docs](https://tanstack.com/query/v5/docs/react/guides/infinite-queries) for more information on infinite queries.

### Updated `useSendTransaction` and `useWriteContract` return type [‚Äã](#updated-usesendtransaction-and-usewritecontract-return-type)

Updated [`useSendTransaction`](https://wagmi.sh/react/api/hooks/useSendTransaction) and [`useWriteContract`](https://wagmi.sh/react/api/hooks/useWriteContract) return type from ``{ hash: `0x${string}` }`` to `` `0x${string}` ``.

ts

    const result = useSendTransaction()
    result.data?.hash
    result.data

### Updated `useConnect` return type [‚Äã](#updated-useconnect-return-type)

Updated [`useConnect`](https://wagmi.sh/react/api/hooks/useConnect) return type from `{ account: Address; chain: { id: number; unsupported?: boolean }; connector: Connector }` to `{ accounts: readonly Address[]; chainId: number }`. This better reflects the ability to have multiple accounts per connector.

### Renamed parameters and return types [‚Äã](#renamed-parameters-and-return-types)

All hook parameters and return types follow the naming pattern of `[PascalCaseHookName]Parameters` and `[PascalCaseHookName]ReturnType`. For example, `UseAccountParameters` and `UseAccountReturnType`.

ts

    import { UseAccountConfig, UseAccountResult } from 'wagmi'
    import { UseAccountParameters, UseAccountReturnType } from 'wagmi'

Connectors [‚Äã](#connectors)
---------------------------

### Updated connector API [‚Äã](#updated-connector-api)

In order to maximize type-safety and ease of creating connectors, the connector API changed. Follow the [Creating Connectors guide](https://wagmi.sh/dev/creating-connectors) for more info on creating new connectors and converting Wagmi v1 connectors.

### Removed individual entrypoints [‚Äã](#removed-individual-entrypoints)

Previously, each connector had it's own entrypoint to optimize tree-shaking. Since all connectors now have [`package.json#sideEffects`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) enabled, this is no longer necessary and the entrypoint is unified. Use the `'wagmi/connectors'` entrypoint instead.

ts

    import { InjectedConnector } from 'wagmi/connectors/injected'
    import { CoinbaseWalletConnector } from 'wagmi/connectors/coinbaseWallet'
    import { coinbaseWallet, injected } from 'wagmi/connectors'

### Removed `MetaMaskConnector` [‚Äã](#removed-metamaskconnector)

The `MetaMaskConnector` was removed since it was nearly the same thing as the `InjectedConnector`. Use the [`injected`](https://wagmi.sh/react/api/connectors/injected) connector instead, along with the [`target`](https://wagmi.sh/react/api/connectors/injected#target) parameter set to `'metaMask'`, for the same behavior.

ts

    import { MetaMaskConnector } from 'wagmi/connectors/metaMask'
    import { injected } from 'wagmi/connectors'
    
    const connector = new MetaMaskConnector()
    const connector = injected({ target: 'metaMask' })

### Renamed connectors [‚Äã](#renamed-connectors)

In Wagmi v1, connectors were classes you needed to instantiate. In Wagmi v2, connectors are functions. As a result, the API has changed. Connectors have the following new names:

*   `CoinbaseWalletConnector` is now [`coinbaseWallet`](https://wagmi.sh/react/api/connectors/coinbaseWallet).
*   `InjectedConnector` is now [`injected`](https://wagmi.sh/react/api/connectors/injected).
*   `SafeConnector` is now [`safe`](https://wagmi.sh/react/api/connectors/safe).
*   `WalletConnectConnector` is now [`walletConnect`](https://wagmi.sh/react/api/connectors/walletConnect).

To create a connector, you now call the connector function with parameters.

ts

    import { WalletConnectConnector } from 'wagmi/connectors/walletConnect'
    import { walletConnect } from 'wagmi/connectors'
    
    const connector = new WalletConnectConnector({ 
    const connector = walletConnect({ 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### Removed `WalletConnectLegacyConnector` [‚Äã](#removed-walletconnectlegacyconnector)

WalletConnect v1 was sunset June 28, 2023. Use the [`walletConnect`](https://wagmi.sh/react/api/connectors/walletConnect) connector instead.

ts

    import { WalletConnectLegacyConnector } from 'wagmi/connectors/walletConnectLegacy'
    import { walletConnect } from 'wagmi/connectors'
    
    const connector = new WalletConnectLegacyConnector({ 
    const connector = walletConnect({ 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

Chains [‚Äã](#chains)
-------------------

### Updated `'wagmi/chains'` entrypoint [‚Äã](#updated-wagmi-chains-entrypoint)

Chains now live in the [Viem repository](https://github.com/wevm/viem). As a result, the `'wagmi/chains'` entrypoint now proxies all chains from `'viem/chains'` directly.

### Removed `mainnet` and `sepolia` from main entrypoint [‚Äã](#removed-mainnet-and-sepolia-from-main-entrypoint)

Since the `'wagmi/chains'` entrypoint now proxies `'viem/chains'`, `mainnet` and `sepolia` were removed from the main entrypoint. Use the `'wagmi/chains'` entrypoint instead.

ts

    import { mainnet, sepolia } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'

Errors [‚Äã](#errors)
-------------------

A number of errors were renamed to better reflect their functionality or replaced by Viem errors.

Miscellaneous [‚Äã](#miscellaneous)
---------------------------------

### Removed internal ENS name normalization [‚Äã](#removed-internal-ens-name-normalization)

Before v2, Wagmi handled ENS name normalization internally for `useEnsAddress`, `useEnsAvatar`, and `useEnsResolver`, using Viem's [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function. This added extra bundle size as full normalization is quite heavy. For v2, you must normalize ENS names yourself before passing them to these hooks. You can use Viem's `normalize` function or any other function that performs [UTS-46 normalization](https://unicode.org/reports/tr46).

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      name: 'wevm.eth', 
      name: normalize('wevm.eth'), 
    })

By inverting control, Wagmi let's you choose how much normalization to do. For example, maybe your project only allows ENS names that are numeric so no normalization is not needed. Check out the [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) for more information on normalizing names.

### Removed `configureChains` [‚Äã](#removed-configurechains)

The Wagmi v2 `Config` now has native multichain support using the [`chains`](https://wagmi.sh/react/api/createConfig) parameter so the `configureChains` function is no longer required.

ts

    import { configureChains, createConfig } from 'wagmi'
    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    const { chains, publicClient } = configureChains(
      [mainnet, sepolia],
      [publicProvider(), publicProvider()],
    )
    
    export const config = createConfig({
      publicClient, 
      chains: [mainnet, sepolia], 
      transports: { 
        [mainnet.id]: http(), 
        [sepolia.id]: http(), 
      }, 
    })

### Removed ABI exports [‚Äã](#removed-abi-exports)

Import from Viem instead.

ts

    import { erc20ABI } from 'wagmi'
    import { erc20Abi } from 'viem'

### Removed `'wagmi/providers/*` entrypoints [‚Äã](#removed-wagmi-providers-entrypoints)

It never made sense that we would have provider URLs hardcoded in the Wagmi codebase. Use [Viem transports](https://viem.sh/docs/clients/intro.html#transports) along with RPC provider URLs instead.

ts

    import { alchemyProvider } from 'wagmi/providers/alchemy'
    import { http } from 'viem'
    
    const transport = http('https://mainnet.example.com')

### Updated `createConfig` parameters [‚Äã](#updated-createconfig-parameters)

*   Removed `autoConnect`. The reconnecting behavior is now managed by React and not related to the Wagmi `Config`. Use `WagmiProvider` [`reconnectOnMount`](https://wagmi.sh/react/api/WagmiProvider#reconnectonmount) or [`useReconnect`](https://wagmi.sh/react/api/hooks/useReconnect) hook instead.
*   Removed `publicClient` and `webSocketPublicClient`. Use [`transports`](https://wagmi.sh/react/api/createConfig#transports) or [`client`](https://wagmi.sh/react/api/createConfig#client) instead.
*   Removed `logger`. Wagmi no longer logs debug information to console.

### Updated `Config` object [‚Äã](#updated-config-object)

*   Removed `config.connector`. Use `config.state.connections.get(config.state.current)?.connector` instead.
*   Removed `config.data`. Use `config.state.connections.get(config.state.current)` instead.
*   Removed `config.error`. Was unused and not needed.
*   Removed `config.lastUsedChainId`. Use `config.state.connections.get(config.state.current)?.chainId` instead.
*   Removed `config.publicClient`. Use [`config.getClient()`](https://wagmi.sh/react/api/createConfig#getclient) or [`getPublicClient`](https://wagmi.sh/core/api/actions/getPublicClient) instead.
*   Removed `config.status`. Use [`config.state.status`](https://wagmi.sh/react/api/createConfig#status) instead.
*   Removed `config.webSocketClient`. Use [`config.getClient()`](https://wagmi.sh/react/api/createConfig#getclient) or [`getPublicClient`](https://wagmi.sh/core/api/actions/getPublicClient) instead.
*   Removed `config.clearState`. Was unused and not needed.
*   Removed `config.autoConnect()`. Use [`reconnect`](https://wagmi.sh/core/api/actions/reconnect) action instead.
*   Renamed `config.setConnectors`. Use `config._internal.setConnectors` instead.
*   Removed `config.setLastUsedConnector`. Use `config.storage?.setItem('recentConnectorId', connectorId)` instead.
*   Removed `getConfig`. `config` should be passed explicitly to actions instead of using global `config`.

Deprecations [‚Äã](#deprecations)
-------------------------------

### Renamed `WagmiConfig` [‚Äã](#renamed-wagmiconfig)

`WagmiConfig` was renamed to [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider) to reduce confusion with the Wagmi [`Config`](https://wagmi.sh/react/api/createConfig) type. React Context Providers usually follow the naming schema `*Provider` so this is a more idiomatic name. Now that Wagmi no longer uses Ethers.js (since Wagmi v1), the term "Provider" is less overloaded.

app.tsxconfig.ts

tsx

    import { WagmiConfig } from 'wagmi'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    function App() {
      return (
        <WagmiConfig config={config}>
        <WagmiProvider config={config}>
          {/** ... */}
        </WagmiProvider>
        </WagmiConfig>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### Deprecated `useBalance` `token` parameter [‚Äã](#deprecated-usebalance-token-parameter)

Moving forward, `useBalance` will only work for native currencies, thus the `token` parameter is no longer supported. Use [`useReadContracts`](https://wagmi.sh/react/api/hooks/useReadContracts) instead.

ts

    import { useBalance } from 'wagmi'
    import { useReadContracts } from 'wagmi'
    import { erc20Abi } from 'viem'
    
    const result = useBalance({ 
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48', 
      token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })
    const result = useReadContracts({ 
      allowFailure: false, 
      contracts: [ 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'balanceOf', 
          args: ['0x4557B18E779944BFE9d78A672452331C186a9f48'], 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'decimals', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'symbol', 
        }, 
      ] 
    })

### Deprecated `useBalance` `unit` parameter and `formatted` return value [‚Äã](#deprecated-usebalance-unit-parameter-and-formatted-return-value)

Moving forward, `useBalance` will not accept the `unit` parameter or return a `formatted` value. Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

ts

    import { formatUnits } from 'viem'
    import { useBalance } from 'wagmi'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      unit: 'ether', 
    })
    result.data!.formatted
    formatUnits(result.data!.value, result.data!.decimals)

### Deprecated `useToken` [‚Äã](#deprecated-usetoken)

Moving forward, `useToken` is no longer supported. Use [`useReadContracts`](https://wagmi.sh/react/api/hooks/useReadContracts) instead.

ts

    import { useToken } from 'wagmi'
    import { useReadContracts } from 'wagmi'
    import { erc20Abi } from 'viem'
    
    const result = useToken({ 
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })
    const result = useReadContracts({ 
      allowFailure: false, 
      contracts: [ 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'decimals', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'name', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'symbol', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'totalSupply', 
        }, 
      ] 
    })

### Deprecated `formatUnits` parameters and return values [‚Äã](#deprecated-formatunits-parameters-and-return-values)

The `formatUnits` parameter and related return values (e.g. `result.formatted`) are deprecated for the following hooks:

*   [`useEstimateFeesPerGas`](https://wagmi.sh/react/api/hooks/useEstimateFeesPerGas)
*   [`useToken`](https://wagmi.sh/react/api/hooks/useToken)

Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

ts

    import { formatUnits } from 'viem'
    
    const result = useToken({
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
      formatUnits: 'ether',
    })
    result.data!.totalSupply.formatted
    formatUnits(result.data!.totalSupply.value, 18)

This allows us to invert control to users so they can handle number formatting however they want, taking into account precision, localization, and more.

### Renamed hooks [‚Äã](#renamed-hooks)

The following hooks were renamed to better reflect their functionality and underlying [Viem](https://viem.sh/) actions:

*   `useContractRead` is now [`useReadContract`](https://wagmi.sh/react/api/hooks/useReadContract)
*   `useContractReads` is now [`useReadContracts`](https://wagmi.sh/react/api/hooks/useReadContracts)
*   `useContractWrite` is now [`useWriteContract`](https://wagmi.sh/react/api/hooks/useWriteContract)
*   `useContractEvent` is now [`useWatchContractEvent`](https://wagmi.sh/react/api/hooks/useWatchContractEvent)
*   `useContractInfiniteReads` is now [`useInfiniteReadContracts`](https://wagmi.sh/react/api/hooks/useInfiniteReadContracts)
*   `useFeeData` is now [`useEstimateFeesPerGas`](https://wagmi.sh/react/api/hooks/useEstimateFeesPerGas)
*   `useSwitchNetwork` is now [`useSwitchChain`](https://wagmi.sh/react/api/hooks/useSwitchChain)
*   `useWaitForTransaction` is now [`useWaitForTransactionReceipt`](https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt)

### Miscellaneous [‚Äã](#miscellaneous-1)

*   `WagmiConfigProps` renamed to [`WagmiProviderProps`](https://wagmi.sh/react/api/WagmiProvider#parameters).
*   `Context` renamed to [`WagmiContext`](https://wagmi.sh/react/api/WagmiProvider#context).</content>
</page>

<page>
  <title>mock | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors/mock</url>
  <content>Connector for mocking Wagmi functionality.

Import [‚Äã](#import)
-------------------

ts

    import { mock } from 'wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { mock } from 'wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [
        mock({
          accounts: [
            '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
            '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
            '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
          ],
        }),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MockParameters } from 'wagmi/connectors'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Accounts to use with the connector.

ts

    import { mock } from 'wagmi/connectors'
    
    const connector = mock({
      accounts: [ 
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', 
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', 
        '0x90F79bf6EB2c4f870365E785982E1f101E93b906', 
        '0x15d34aaf54267db7d7c367839aaf71a00a2c6a65', 
        '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', 
        '0x976EA74026E726554dB657fA54763abd0C3a0aa9', 
        '0x14dC79964da2C08b23698B3D3cc7Ca32193d9955', 
        '0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f', 
        '0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', 
      ], 
    })

### features [‚Äã](#features)

`{ connectError?: boolean | Error | undefined; reconnect?: boolean | undefined; signMessageError?: boolean | Error | undefined; signTypedDataError?: boolean | Error | undefined; switchChainError?: boolean | Error | undefined; } | undefined`

Feature flags that change behavior of Wagmi internals.

ts

    import { mock } from 'wagmi/connectors'
    import { UserRejectedRequestError } from 'viem'
    
    const connector = mock({
      accounts: [
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
      ],
      features: { 
        connectError: new UserRejectedRequestError(new Error('Failed to connect.')), 
        reconnect: false, 
      }, 
    })

#### defaultConnected [‚Äã](#defaultconnected)

`boolean | undefined`

Whether the connector is connected by default.

#### connectError [‚Äã](#connecterror)

`boolean | Error | undefined`

Whether to throw an error when `connector.connect` is called.

#### reconnect [‚Äã](#reconnect)

`boolean | undefined`

Enables reconnecting to connector.

#### signMessageError [‚Äã](#signmessageerror)

`boolean | Error | undefined`

Whether to throw an error when `'personal_sign'` is called.

#### signTypedDataError [‚Äã](#signtypeddataerror)

`boolean | Error | undefined`

Whether to throw an error when `'eth_signTypedData_v4'` is called.

#### switchChainError [‚Äã](#switchchainerror)

`boolean | Error | undefined`

Whether to throw an error when `connector.switchChain` is called.</content>
</page>

<page>
  <title>walletConnect | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors/walletConnect</url>
  <content>Connector for [WalletConnect](https://walletconnect.com/).

Import [‚Äã](#import)
-------------------

ts

    import { walletConnect } from 'wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { walletConnect } from 'wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [
        walletConnect({
          projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
        }),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WalletConnectParameters } from 'wagmi/connectors'

Check out the [WalletConnect docs](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/providers/ethereum-provider) for more info. A few options are omitted that Wagmi manages internally.

### customStoragePrefix wagmi@>=2.12.8 [‚Äã](#customstorageprefix)

`string | undefined`

Custom storage prefix for persisting provider state.

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      customStoragePrefix: 'wagmi', 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### disableProviderPing [‚Äã](#disableproviderping)

`boolean | undefined`

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      disableProviderPing: false, 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### isNewChainsStale [‚Äã](#isnewchainsstale)

`boolean | undefined`

*   If a new chain is added to a previously existing configured connector `chains`, this flag will determine if that chain should be considered as stale. A stale chain is a chain that WalletConnect has yet to establish a relationship with (e.g. the user has not approved or rejected the chain).
*   Defaults to `true`.

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      isNewChainsStale: true, 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

More info

Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when a user tries to switch to a chain that they have not approved.

This flag mainly affects the behavior when a wallet does not support dynamic chain authorization with WalletConnect v2.

If `true` (default), the new chain will be treated as a stale chain. If the user has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect session, the connector will disconnect upon the dapp auto-connecting, and the user will have to reconnect to the dapp (revalidate the chain) in order to approve the newly added chain. This is the default behavior to avoid an unexpected error upon switching chains which may be a confusing user experience (e.g. the user will not know they have to reconnect unless the dapp handles these types of errors).

If `false`, the new chain will be treated as a validated chain. This means that if the user has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully auto-connect the user. This comes with the trade-off that the connector will throw an error when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly modifies their configured chains, and they do not want to disconnect the user upon auto-connecting. If the user decides to switch to the unapproved chain, it is important that the dapp handles this error and prompts the user to reconnect to the dapp in order to approve the newly added chain.

### metadata [‚Äã](#metadata)

`CoreTypes.Metadata | undefined`

Metadata related to the app requesting the connection.

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      metadata: { 
        name: 'Example', 
        description: 'Example website', 
        url: 'https://example.com', 
      }, 
    })

### projectId [‚Äã](#projectid)

`string`

WalletConnect Cloud project identifier. You can find your `projectId` on your [WalletConnect dashboard](https://cloud.reown.com/sign-in).

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68', 
    })

### qrModalOptions [‚Äã](#qrmodaloptions)

`QrModalOptions | undefined`

Options for rendering QR modal.

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      qrModalOptions: { 
        themeMode: 'dark', 
      }, 
    })

### relayUrl [‚Äã](#relayurl)

`string | undefined`

*   WalletConnect relay URL to use.
*   Defaults to `'wss://relay.walletconnect.com'`.

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      relayUrl: 'wss://relay.walletconnect.org', 
    })

### storageOptions [‚Äã](#storageoptions)

`KeyValueStorageOptions | undefined`

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      storageOptions: {}, 
    })

### showQrModal [‚Äã](#showqrmodal)

`boolean | undefined`

*   Whether to show the QR code modal upon calling `connector.connect()`.
*   Defaults to `true`.

ts

    import { walletConnect } from 'wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      showQrModal: true, 
    })

TIP

This can be disabled and you can listen for a `'message'` event with payload `{ type: 'display_uri'; data: string }` if you want to render your own QR code.</content>
</page>

<page>
  <title>Transports | Wagmi</title>
  <url>https://wagmi.sh/react/api/transports</url>
  <content>[`createConfig`](https://wagmi.sh/react/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

Import [‚Äã](#import)
-------------------

ts

    import { http } from 'wagmi'

Built-In Transports [‚Äã](#built-in-transports)
---------------------------------------------

Available via the `'wagmi'` entrypoint.

*   [custom (EIP-1193)](https://wagmi.sh/core/api/transports/custom)
*   [fallback](https://wagmi.sh/core/api/transports/fallback)
*   [http](https://wagmi.sh/core/api/transports/http)
*   [unstable\_connector](https://wagmi.sh/core/api/transports/unstable_connector)
*   [webSocket](https://wagmi.sh/core/api/transports/webSocket)</content>
</page>

<page>
  <title>safe | Wagmi</title>
  <url>https://wagmi.sh/react/api/connectors/safe</url>
  <content>Connector for [Safe Apps SDK](https://github.com/safe-global/safe-apps-sdk).

Import [‚Äã](#import)
-------------------

ts

    import { safe } from 'wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { safe } from 'wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [safe()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SafeParameters } from 'wagmi/connectors'

Check out the [Safe docs](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-sdk) for more info.

### allowedDomains [‚Äã](#alloweddomains)

`RegExp[] | undefined`

ts

    import { safe } from 'wagmi/connectors'
    
    const connector = safe({
      allowedDomains: [/app.safe.global$/], 
    })

### debug [‚Äã](#debug)

`boolean | undefined`

ts

    import { safe } from 'wagmi/connectors'
    
    const connector = safe({
      debug: true, 
    })

### shimDisconnect [‚Äã](#shimdisconnect)

`boolean | undefined`

*   This flag simulates disconnect behavior by keeping track of connection status in storage.
*   Defaults to `false`.

ts

    import { safe } from 'wagmi/connectors'
    
    const connector = safe({
      shimDisconnect: true, 
    })</content>
</page>

<page>
  <title>custom | Wagmi</title>
  <url>https://wagmi.sh/react/api/transports/custom</url>
  <content>The `custom` Transport connects to a JSON-RPC API via custom. Wraps Viem's [`custom` Transport](https://viem.sh/docs/clients/transports/custom.html).

Import [‚Äã](#import)
-------------------

ts

    import { custom } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      custom
    } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { customRpc } from './rpc'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: custom({ 
          async request({ method, params }) { 
            const response = await customRpc.request(method, params)
            return response
          } 
        }) 
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

### provider [‚Äã](#provider)

`{ request({ method: string, params: unknown[] }): Promise<unknown> }`

An [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request) function.

ts

    import { customRpc } from './rpc'
    
    const transport = custom({
      async request({ method, params }) { 
        const response = await customRpc.request(method, params)
        return response
      }
    })

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"custom"`.

ts

    const transport = custom(
      provider,
      { 
        key: 'windowProvider', 
      }
    )

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"Ethereum Provider"`.

ts

    const transport = custom(
      provider,
      { 
        name: 'Window Ethereum Provider', 
      }
    )

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = custom(provider, {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = custom(provider, {
      retryDelay: 100, 
    })</content>
</page>

<page>
  <title>fallback | Wagmi</title>
  <url>https://wagmi.sh/react/api/transports/fallback</url>
  <content>The `fallback` Transport consumes **multiple** Transports. If a Transport request fails, it will fall back to the next one in the list. Wraps Viem's [`fallback` Transport](https://viem.sh/docs/clients/transports/fallback.html).

Import [‚Äã](#import)
-------------------

ts

    import { fallback } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      fallback,
      http,
    } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: fallback([ 
          http('https://foo-bar-baz.quiknode.pro/...'), 
          http('https://mainnet.infura.io/v3/...'), 
        ]) 
      },
    })</content>
</page>

<page>
  <title>WagmiProvider | Wagmi</title>
  <url>https://wagmi.sh/react/api/WagmiProvider</url>
  <content>React Context Provider for Wagmi.

Import [‚Äã](#import)
-------------------

ts

    import { WagmiProvider } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

app.tsxconfig.ts

tsx

    import { WagmiProvider } from 'wagmi'
    import { config } from './config' 
    
    function App() {
      return (
        <WagmiProvider config={config}> 
          {/** ... */}
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WagmiProviderProps } from 'wagmi'

### config [‚Äã](#config)

[`Config`](https://wagmi.sh/react/api/createConfig#config) object to inject with context.

app.tsxconfig.ts

tsx

    import { WagmiProvider } from 'wagmi'
    import { config } from './config' 
    
    function App() {
      return (
        <WagmiProvider
          config={config}
        >
          {/** ... */}
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### initialState [‚Äã](#initialstate)

`State | undefined`

*   Initial state to hydrate into the [Wagmi Config](https://wagmi.sh/react/api/createConfig). Useful for SSR.

app.tsxconfig.ts

tsx

    import { WagmiProvider } from 'wagmi'
    import { config } from './config' 
    
    function App() {
      return (
        <WagmiProvider
          config={config}
          initialState={/* ... /*}
        >
          {/** ... */}
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### reconnectOnMount [‚Äã](#reconnectonmount)

`boolean | undefined`

*   Whether or not to reconnect previously connected [connectors](https://wagmi.sh/react/api/createConfig#connectors) on mount.
*   Defaults to `true`.

app.tsxconfig.ts

tsx

    import { WagmiProvider } from 'wagmi'
    import { config } from './config' 
    
    function App() {
      return (
        <WagmiProvider
          config={config}
          reconnectOnMount={false}
        >
          {/** ... */}
        </WagmiProvider>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Context [‚Äã](#context)
---------------------

ts

    import { type WagmiContext } from 'wagmi'</content>
</page>

<page>
  <title>http | Wagmi</title>
  <url>https://wagmi.sh/react/api/transports/http</url>
  <content>The `http` Transport connects to a JSON-RPC API via HTTP. Wraps Viem's [`http` Transport](https://viem.sh/docs/clients/transports/http.html).

Import [‚Äã](#import)
-------------------

ts

    import { http } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      http
    } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: http('https://foo-bar-baz.quiknode.pro/...'), 
        [sepolia.id]: http('https://foo-bar-sep.quiknode.pro/...'), 
      },
    })

WARNING

If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.

### Batch JSON-RPC [‚Äã](#batch-json-rpc)

The `http` Transport supports Batch JSON-RPC. This means that multiple JSON-RPC requests can be sent in a single HTTP request.

The Transport will batch up Actions over a given period and execute them in a single Batch JSON-RPC HTTP request. By default, this period is a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays) meaning that the batch request will be executed at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue). Consumers can specify a custom time period `wait` (in ms).

You can enable Batch JSON-RPC by setting the `batch` flag to `true`:

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: true
    })

Parameters [‚Äã](#parameters)
---------------------------

### url [‚Äã](#url)

`string`

URL of the JSON-RPC API. Defaults to `chain.rpcUrls.default.http[0]`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...')

### batch [‚Äã](#batch)

`boolean | BatchOptions`

Toggle to enable Batch JSON-RPC. Defaults to `false`

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: true
    })

### batch.batchSize [‚Äã](#batch-batchsize)

`number`

The maximum number of JSON-RPC requests to send in a batch. Defaults to `1_000`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: {
        batchSize: 2_000
      }
    })

### batch.wait [‚Äã](#batch-wait)

`number`

The maximum number of milliseconds to wait before sending a batch. Defaults to `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays)).

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: {
        wait: 16
      }
    })

### fetchOptions [‚Äã](#fetchoptions)

[`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)

[Fetch options](https://developer.mozilla.org/en-US/docs/Web/API/fetch) to pass to the internal `fetch` function. Useful for passing auth headers or cache options.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      fetchOptions: { 
        headers: {
          'Authorization': 'Bearer ...'
        }
      }
    })

### key [‚Äã](#key)

`string`

A key for the Transport. Defaults to `"http"`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      key: 'alchemy', 
    })

### name [‚Äã](#name)

`string`

A name for the Transport. Defaults to `"HTTP JSON-RPC"`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      name: 'Alchemy HTTP Provider', 
    })

### retryCount [‚Äã](#retrycount)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      retryCount: 5, 
    })

### retryDelay [‚Äã](#retrydelay)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      retryDelay: 100, 
    })

### timeout [‚Äã](#timeout)

`number`

The timeout for requests. Defaults to `10_000`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      timeout: 60_000, 
    })</content>
</page>

<page>
  <title>useAccount | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useAccount</url>
  <content>Hook for getting current account.

Import [‚Äã](#import)
-------------------

ts

    import { useAccount } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useAccount } from 'wagmi'
    
    function App() {
      const account = useAccount()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseAccountParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useAccount } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const account = useAccount({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseAccountReturnType } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

*   Connected address from connector.
*   Defaults to first address in [`addresses`](#addresses).

### addresses [‚Äã](#addresses)

`readonly Address[] | undefined`

Connected addresses from connector.

### chain [‚Äã](#chain)

`Chain | undefined`

Connected chain from connector. If chain is not configured by config, it will be `undefined`.

### chainId [‚Äã](#chainid)

`number | undefined`

Connected chain id from connector.

### connector [‚Äã](#connector)

`Connector | undefined`

Connected connector.

### isConnecting / isReconnecting / isConnected / isDisconnected [‚Äã](#isconnecting-isreconnecting-isconnected-isdisconnected)

`boolean`

Boolean variables derived from [`status`](#status).

### status [‚Äã](#status)

`'connecting' | 'reconnecting' | 'connected' | 'disconnected'`

*   `'connecting'` attempting to establish connection.
*   `'reconnecting'` attempting to re-establish connection to one or more connectors.
*   `'connected'` at least one connector is connected.
*   `'disconnected'` no connection to any connector.

You can use `status` to narrow the return type.

For example, when `status` is `'connected'` properties like `address` are guaranteed to be defined.

ts

    if (. === 'connected') {
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

Or when status is `'disconnected'` properties like `address` are guaranteed to be `undefined`:

ts

    if (. === 'disconnected') {
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

Action [‚Äã](#action)
-------------------

*   [`getAccount`](https://wagmi.sh/core/api/actions/getAccount)</content>
</page>

<page>
  <title>useAccountEffect | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useAccountEffect</url>
  <content>Hook for listening to account lifecycle events.

Import [‚Äã](#import)
-------------------

ts

    import { useAccountEffect } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useAccountEffect } from 'wagmi'
    
    function App() {
      useAccountEffect({
        onConnect(data) {
          console.log('Connected!', data)
        },
        onDisconnect() {
          console.log('Disconnected!')
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseAccountEffectParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useAccountEffect } from 'wagmi'
    import { config } from './config'
    
    function App() {
      useAccountEffect({
        config,
        onConnect(data) {
          console.log('Connected!', data)
        },
        onDisconnect() {
          console.log('Disconnected!')
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onConnect [‚Äã](#onconnect)

``((data: { address: `0x${string}`; addresses: readonly [`0x${string}`, ...`0x${string}`[]]; chain: Chain | undefined chainId: number; connector: Connector; isReconnected: boolean }) => void) | undefined``

Callback that is called when accounts are connected.

index.tsxconfig.ts

tsx

    import { useAccountEffect } from 'wagmi'
    
    function App() {
      useAccountEffect({
        onConnect(data) {
          console.log('Connected!', data)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onDisconnect [‚Äã](#ondisconnect)

`(() => void) | undefined`

Callback that is called when no more accounts are connected.

index.tsxconfig.ts

tsx

    import { useAccountEffect } from 'wagmi'
    
    function App() {
      useAccountEffect({
        onDisconnect() {
          console.log('Disconnected!')
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Action [‚Äã](#action)
-------------------

*   [`getAccount`](https://wagmi.sh/core/api/actions/getAccount)
*   [`watchAccount`](https://wagmi.sh/core/api/actions/watchAccount)</content>
</page>

<page>
  <title>webSocket | Wagmi</title>
  <url>https://wagmi.sh/react/api/transports/webSocket</url>
  <content>The `webSocket` Transport connects to a JSON-RPC API via a WebSocket. Wraps Viem's [`webSocket` Transport](https://viem.sh/docs/clients/transports/webSocket.html).

Import [‚Äã](#import)
-------------------

ts

    import { webSocket } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      webSocket
    } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: webSocket('wss://foo-bar-baz.quiknode.pro/...'), 
        [sepolia.id]: webSocket('wss://foo-bar-sep.quicknode.pro/...'), 
      },
    })

WARNING

If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.

Parameters [‚Äã](#parameters)
---------------------------

### url [‚Äã](#url)

`string`

URL of the JSON-RPC API.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...')

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"webSocket"`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
      key: 'alchemy',  
    })

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"WebSocket JSON-RPC"`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
      name: 'Alchemy WebSocket Provider',  
    })

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      retryDelay: 100, 
    })

### timeout (optional) [‚Äã](#timeout-optional)

`number`

The timeout for async WebSocket requests. Defaults to `10_000`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      timeout: 60_000, 
    })</content>
</page>

<page>
  <title>useBalance | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useBalance</url>
  <content>Hook for fetching native currency or token balance.

Import [‚Äã](#import)
-------------------

ts

    import { useBalance } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useBalance } from 'wagmi'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBalanceParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

Address to get balance for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

index.tsxconfig.ts

tsx

    import { useBalance } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get balance at.

index.tsconfig.ts

ts

    import { useBalance } from 'wagmi'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        blockNumber: 17829139n, 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

index.tsconfig.ts

ts

    import { useBalance } from 'wagmi'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        blockTag: 'latest', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useBalance } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useBalance } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useBalance } from 'wagmi'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### token [deprecated](https://wagmi.sh/react/guides/migrate-from-v1-to-v2#deprecated-usebalance-token-parameter) [‚Äã](#token-deprecated)

`Address | undefined`

ERC-20 token address to get balance for.

index.tsconfig.ts

ts

    import { useBalance } from 'wagmi'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### unit [deprecated](https://wagmi.sh/react/guides/migrate-from-v1-to-v2#deprecated-usebalance-unit-parameter-and-formatted-return-value) [‚Äã](#unit-deprecated)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.tsconfig.ts

ts

    import { useBalance } from 'wagmi'
    
    function App() {
      const result = useBalance({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        unit: 'ether', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`{ decimals: number; formatted: string; symbol: string; value: bigint; } | (() => { decimals: number; formatted: string; symbol: string; value: bigint; }) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`{ decimals: number; formatted: string; symbol: string; value: bigint; } | ((previousValue: { decimals: number; formatted: string; symbol: string; value: bigint; } | undefined; previousQuery: Query | undefined) => { decimals: number; formatted: string; symbol: string; value: bigint; }) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: { decimals: number; formatted: string; symbol: string; value: bigint; } | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBalanceErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBalanceErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: { decimals: number; formatted: string; symbol: string; value: bigint; }) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: { decimals: number; formatted: string; symbol: string; value: bigint; } | undefined, newData: { decimals: number; formatted: string; symbol: string; value: bigint; }) => { decimals: number; formatted: string; symbol: string; value: bigint; })) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBalanceReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`{ decimals: number; formatted: string; symbol: string; value: bigint; }`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBalanceErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBalanceErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<{ decimals: number; formatted: string; symbol: string; value: bigint; }, GetBalanceErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBalanceData,
      type GetBalanceOptions,
      type GetBalanceQueryFnData,
      type GetBalanceQueryKey,
      getBalanceQueryKey,
      getBalanceQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getBalance`](https://wagmi.sh/core/api/actions/getBalance)</content>
</page>

<page>
  <title>Connect Wallet | Wagmi</title>
  <url>https://wagmi.sh/react/guides/connect-wallet</url>
  <content>The ability for a user to connect their wallet is a core function for any Dapp. It allows users to perform tasks such as: writing to contracts, signing messages, or sending transactions.

Wagmi contains everything you need to get started with building a Connect Wallet module. To get started, you can either use a [third-party library](#third-party-libraries) or [build your own](#build-your-own).

Third-party Libraries [‚Äã](#third-party-libraries)
-------------------------------------------------

You can use a pre-built Connect Wallet module from a third-party library such as:

*   [ConnectKit](https://docs.family.co/connectkit) - [Guide](https://docs.family.co/connectkit/getting-started)
*   [AppKit](https://walletconnect.com/appkit) - [Guide](https://docs.walletconnect.com/appkit/next/core/installation)
*   [RainbowKit](https://www.rainbowkit.com/) - [Guide](https://www.rainbowkit.com/docs/installation)
*   [Dynamic](https://www.dynamic.xyz/) - [Guide](https://docs.dynamic.xyz/quickstart)
*   [Privy](https://privy.io/) - [Guide](https://docs.privy.io/guide/react/wallets/usage/wagmi)

The above libraries are all built on top of Wagmi, handle all the edge cases around wallet connection, and provide a seamless Connect Wallet UX that you can use in your Dapp.

Build Your Own [‚Äã](#build-your-own)
-----------------------------------

Wagmi provides you with the Hooks to get started building your own Connect Wallet module.

It takes less than five minutes to get up and running with Browser Wallets, WalletConnect, and Coinbase Wallet.

### 1\. Configure Wagmi [‚Äã](#_1-configure-wagmi)

Before we get started with building the functionality of the Connect Wallet module, we will need to set up the Wagmi configuration.

Let's create a `config.ts` file and export a `config` object.

config.ts

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

In the above configuration, we want to set up connectors for Injected (browser), WalletConnect (browser + mobile), MetaMask, and Safe wallets. This configuration uses the **Mainnet** and **Base** chains, but you can use whatever you want.

WARNING

Make sure to replace the `projectId` with your own WalletConnect Project ID, if you wish to use WalletConnect!

[Get your Project ID](https://cloud.walletconnect.com/)

### 2\. Wrap App in Context Provider [‚Äã](#_2-wrap-app-in-context-provider)

Next, we will need to wrap our React App with Context so that our application is aware of Wagmi & React Query's reactive state and in-memory caching.

app.tsxconfig.ts

tsx

     // 1. Import modules
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    // 2. Set up a React Query client.
    const queryClient = new QueryClient()
    
    function App() {
      // 3. Wrap app with Wagmi and React Query context.
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}> 
            {/** ... */} 
          </QueryClientProvider> 
        </WagmiProvider>
      )
    }

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### 3\. Display Wallet Options [‚Äã](#_3-display-wallet-options)

After that, we will create a `WalletOptions` component that will display our connectors. This will allow users to select a wallet and connect.

Below, we are rendering a list of `connectors` retrieved from `useConnect`. When the user clicks on a connector, the `connect` function will connect the users' wallet.

wallet-options.tsxapp.tsxconfig.ts

tsx

    import * as React from 'react'
    import { Connector, useConnect } from 'wagmi'
    
    export function WalletOptions() {
      const { connectors, connect } = useConnect()
    
      return connectors.map((connector) => (
        <button key={connector.uid} onClick={() => connect({ connector })}>
          {connector.name}
        </button>
      ))
    }

tsx

     // 1. Import modules
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    // 2. Set up a React Query client.
    const queryClient = new QueryClient()
    
    function App() {
      // 3. Wrap app with Wagmi and React Query context.
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}> 
            {/* ... */}
          </QueryClientProvider> 
        </WagmiProvider>
      )
    }

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### 4\. Display Connected Account [‚Äã](#_4-display-connected-account)

Lastly, if an account is connected, we want to show some basic information, like the connected address and ENS name and avatar.

Below, we are using hooks like `useAccount`, `useEnsAvatar` and `useEnsName` to extract this information.

We are also utilizing `useDisconnect` to show a "Disconnect" button so a user can disconnect their wallet.

account.tsxwallet-options.tsxapp.tsxconfig.ts

tsx

    import { useAccount, useDisconnect, useEnsAvatar, useEnsName } from 'wagmi'
    
    export function Account() {
      const { address } = useAccount()
      const { disconnect } = useDisconnect()
      const { data: ensName } = useEnsName({ address })
      const { data: ensAvatar } = useEnsAvatar({ name: ensName! })
    
      return (
        <div>
          {ensAvatar && <img alt="ENS Avatar" src={ensAvatar} />}
          {address && <div>{ensName ? `${ensName} (${address})` : address}</div>}
          <button onClick={() => disconnect()}>Disconnect</button>
        </div>
      )
    }

tsx

    import * as React from 'react'
    import { Connector, useConnect } from 'wagmi'
    
    export function WalletOptions() {
      const { connectors, connect } = useConnect()
    
      return connectors.map((connector) => (
        <WalletOption
          key={connector.uid}
          connector={connector}
          onClick={() => connect({ connector })}
        />
      ))
    }
    
    function WalletOption({
      connector,
      onClick,
    }: {
      connector: Connector
      onClick: () => void
    }) {
      const [ready, setReady] = React.useState(false)
    
      React.useEffect(() => {
        ;(async () => {
          const provider = await connector.getProvider()
          setReady(!!provider)
        })()
      }, [connector])
    
      return (
        <button disabled={!ready} onClick={onClick}>
          {connector.name}
        </button>
      )
    }

tsx

     // 1. Import modules
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider } from 'wagmi'
    import { config } from './config'
    
    // 2. Set up a React Query client.
    const queryClient = new QueryClient()
    
    function App() {
      // 3. Wrap app with Wagmi and React Query context.
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}> 
            {/* ... */}
          </QueryClientProvider> 
        </WagmiProvider>
      )
    }

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### 5\. Wire it up! [‚Äã](#_5-wire-it-up)

Finally, we can wire up our Wallet Options and Account components to our application's entrypoint.

app.tsxaccount.tsxwallet-options.tsxconfig.ts

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider, useAccount } from 'wagmi'
    import { config } from './config'
    import { Account } from './account'
    import { WalletOptions } from './wallet-options'
    
    const queryClient = new QueryClient()
    
    function ConnectWallet() {
      const { isConnected } = useAccount()
      if (isConnected) return <Account />
      return <WalletOptions />
    }
    
    function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}> 
            <ConnectWallet />
          </QueryClientProvider> 
        </WagmiProvider>
      )
    }

tsx

    import { useAccount, useDisconnect, useEnsAvatar, useEnsName } from 'wagmi'
    
    export function Account() {
      const { address } = useAccount()
      const { disconnect } = useDisconnect()
      const { data: ensName } = useEnsName({ address })
      const { data: ensAvatar } = useEnsAvatar({ name: ensName! })
    
      return (
        <div>
          {ensAvatar && <img alt="ENS Avatar" src={ensAvatar} />}
          {address && <div>{ensName ? `${ensName} (${address})` : address}</div>}
          <button onClick={() => disconnect()}>Disconnect</button>
        </div>
      )
    }

tsx

    import * as React from 'react'
    import { Connector, useConnect } from 'wagmi'
    
    export function WalletOptions() {
      const { connectors, connect } = useConnect()
    
      return connectors.map((connector) => (
        <WalletOption
          key={connector.uid}
          connector={connector}
          onClick={() => connect({ connector })}
        />
      ))
    }
    
    function WalletOption({
      connector,
      onClick,
    }: {
      connector: Connector
      onClick: () => void
    }) {
      const [ready, setReady] = React.useState(false)
    
      React.useEffect(() => {
        ;(async () => {
          const provider = await connector.getProvider()
          setReady(!!provider)
        })()
      }, [connector])
    
      return (
        <button disabled={!ready} onClick={onClick}>
          {connector.name}
        </button>
      )
    }

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### Playground [‚Äã](#playground)

Want to see the above steps all wired up together in an end-to-end example? Check out the below StackBlitz playground.</content>
</page>

<page>
  <title>Send Transaction | Wagmi</title>
  <url>https://wagmi.sh/react/guides/send-transaction</url>
  <content>The following guide teaches you how to send transactions in Wagmi. The example below builds on the [Connect Wallet guide](https://wagmi.sh/react/guides/connect-wallet) and uses the [useSendTransaction](https://wagmi.sh/react/api/hooks/useSendTransaction) & [useWaitForTransaction](https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt) hooks.

Example [‚Äã](#example)
---------------------

Feel free to check out the example before moving on:

Steps [‚Äã](#steps)
-----------------

### 1\. Connect Wallet [‚Äã](#_1-connect-wallet)

Follow the [Connect Wallet guide](https://wagmi.sh/react/guides/connect-wallet) guide to get this set up.

### 2\. Create a new component [‚Äã](#_2-create-a-new-component)

Create your `SendTransaction` component that will contain the send transaction logic.

send-transaction.tsx

tsx

    import * as React from 'react'
     
    export function SendTransaction() {
      return (
        <form>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button type="submit">Send</button>
        </form>
      )
    }

### 3\. Add a form handler [‚Äã](#_3-add-a-form-handler)

Next, we will need to add a handler to the form that will send the transaction when the user hits "Send". This will be a basic handler in this step.

send-transaction.tsx

tsx

    import * as React from 'react'
     
    export function SendTransaction() {
      async function submit(e: React.FormEvent<HTMLFormElement>) {
        e.preventDefault()
        const formData = new FormData(e.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
      }
    
      return (
        <form>
        <form onSubmit={submit}>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button type="submit">Send</button>
        </form>
      )
    }

### 4\. Hook up the `useSendTransaction` Hook [‚Äã](#_4-hook-up-the-usesendtransaction-hook)

Now that we have the form handler, we can hook up the [`useSendTransaction` Hook](https://wagmi.sh/react/api/hooks/useSendTransaction) to send the transaction.

send-transaction.tsx

tsx

    import * as React from 'react'
    import { useSendTransaction } from 'wagmi'
    import { parseEther } from 'viem'
     
    export function SendTransaction() {
      const { data: hash, sendTransaction } = useSendTransaction()
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const to = formData.get('address') as `0x${string}` 
        const value = formData.get('value') as string 
        sendTransaction({ to, value: parseEther(value) })
      } 
    
      return (
        <form onSubmit={submit}>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button type="submit">Send</button>
          {hash && <div>Transaction Hash: {hash}</div>}
        </form>
      )
    }

### 5\. Add loading state (optional) [‚Äã](#_5-add-loading-state-optional)

We can optionally add a loading state to the "Send" button while we are waiting confirmation from the user's wallet.

send-transaction.tsx

tsx

    import * as React from 'react'
    import { useSendTransaction } from 'wagmi' 
    import { parseEther } from 'viem' 
     
    export function SendTransaction() {
      const { 
        data: hash, 
        isPending,
        sendTransaction 
      } = useSendTransaction() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const to = formData.get('address') as `0x${string}` 
        const value = formData.get('value') as string 
        sendTransaction({ to, value: parseEther(value) }) 
      } 
    
      return (
        <form onSubmit={submit}>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button 
            disabled={isPending}
            type="submit"
          >
            Send
            {isPending ? 'Confirming...' : 'Send'}
          </button>
          {hash && <div>Transaction Hash: {hash}</div>} 
        </form>
      )
    }

### 6\. Wait for transaction receipt (optional) [‚Äã](#_6-wait-for-transaction-receipt-optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Hook](https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt).

send-transaction.tsx

tsx

    import * as React from 'react'
    import { 
      useSendTransaction, 
      useWaitForTransactionReceipt
    } from 'wagmi' 
    import { parseEther } from 'viem' 
     
    export function SendTransaction() {
      const { 
        data: hash, 
        isPending, 
        sendTransaction 
      } = useSendTransaction() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const to = formData.get('address') as `0x${string}` 
        const value = formData.get('value') as string 
        sendTransaction({ to, value: parseEther(value) }) 
      } 
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } =
        useWaitForTransactionReceipt({
          hash,
        })
    
      return (
        <form onSubmit={submit}>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button 
            disabled={isPending} 
            type="submit"
          >
            {isPending ? 'Confirming...' : 'Send'} 
          </button>
          {hash && <div>Transaction Hash: {hash}</div>} 
          {isConfirming && <div>Waiting for confirmation...</div>}
          {isConfirmed && <div>Transaction confirmed.</div>}
        </form>
      )
    }

### 7\. Handle errors (optional) [‚Äã](#_7-handle-errors-optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

send-transaction.tsx

tsx

    import * as React from 'react'
    import { 
      type BaseError,
      useSendTransaction, 
      useWaitForTransactionReceipt 
    } from 'wagmi' 
    import { parseEther } from 'viem' 
     
    export function SendTransaction() {
      const { 
        data: hash,
        error,
        isPending, 
        sendTransaction 
      } = useSendTransaction() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const to = formData.get('address') as `0x${string}` 
        const value = formData.get('value') as string 
        sendTransaction({ to, value: parseEther(value) }) 
      } 
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } = 
        useWaitForTransactionReceipt({ 
          hash, 
        }) 
    
      return (
        <form onSubmit={submit}>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button 
            disabled={isPending} 
            type="submit"
          >
            {isPending ? 'Confirming...' : 'Send'} 
          </button>
          {hash && <div>Transaction Hash: {hash}</div>} 
          {isConfirming && <div>Waiting for confirmation...</div>} 
          {isConfirmed && <div>Transaction confirmed.</div>} 
          {error && (
            <div>Error: {(error as BaseError).shortMessage || error.message}</div>
          )}
        </form>
      )
    }

### 8\. Wire it up! [‚Äã](#_8-wire-it-up)

Finally, we can wire up our Send Transaction component to our application's entrypoint.

app.tsxsend-transaction.tsxconfig.ts

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider, useAccount } from 'wagmi'
    import { config } from './config'
    import { SendTransaction } from './send-transaction'
    
    const queryClient = new QueryClient()
    
    function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}> 
            <SendTransaction />
          </QueryClientProvider> 
        </WagmiProvider>
      )
    }

tsx

    import * as React from 'react'
    import { 
      type BaseError, 
      useSendTransaction, 
      useWaitForTransactionReceipt 
    } from 'wagmi' 
    import { parseEther } from 'viem' 
     
    export function SendTransaction() {
      const { 
        data: hash,
        error, 
        isPending, 
        sendTransaction 
      } = useSendTransaction() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const to = formData.get('address') as `0x${string}` 
        const value = formData.get('value') as string 
        sendTransaction({ to, value: parseEther(value) }) 
      } 
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } = 
        useWaitForTransactionReceipt({ 
          hash, 
        }) 
    
      return (
        <form onSubmit={submit}>
          <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
          <input name="value" placeholder="0.05" required />
          <button 
            disabled={isPending} 
            type="submit"
          >
            {isPending ? 'Confirming...' : 'Send'} 
          </button>
          {hash && <div>Transaction Hash: {hash}</div>} 
          {isConfirming && <div>Waiting for confirmation...</div>} 
          {isConfirmed && <div>Transaction confirmed.</div>} 
          {error && ( 
            <div>Error: {(error as BaseError).shortMessage || error.message}</div> 
          )} 
        </form>
      )
    }

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

[See the Example.](#example)</content>
</page>

<page>
  <title>useBlockNumber | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useBlockNumber</url>
  <content>Hook for fetching the number of the most recent block seen.

Import [‚Äã](#import)
-------------------

ts

    import { useBlockNumber } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useBlockNumber } from 'wagmi'
    
    function App() {
      const result = useBlockNumber()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBlockNumberParameters } from 'wagmi'

### cacheTime [‚Äã](#cachetime)

`number | undefined`

Time in milliseconds that cached block number will remain in memory.

index.tsxconfig.ts

tsx

    import { useBlockNumber } from 'wagmi'
    
    function App() {
      const result = useBlockNumber({
        cacheTime: 4_000,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useBlockNumber } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useBlockNumber({
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useBlockNumber } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlockNumber({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useBlockNumber } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlockNumber({
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### watch [‚Äã](#watch)

`boolean | UseWatchBlockNumberParameters | undefined`

*   Enables/disables listening for block number changes.
*   Can pass a subset of [`UseWatchBlockNumberParameters`](https://wagmi.sh/react/api/hooks/useWatchBlockNumber#parameters)directly to [`useWatchBlockNumber`](https://wagmi.sh/react/api/hooks/useWatchBlockNumber).

index.tsxindex-2.tsxconfig.ts

tsx

    import { useBlockNumber } from 'wagmi'
    
    function App() {
      const result = useBlockNumber({
        watch: true,
      })
    }

tsx

    import { useBlockNumber } from 'wagmi'
    
    function App() {
      const result = useBlockNumber({
        watch: {
          pollingInterval: 4_000,
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBlockNumberErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBlockNumberErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBlockNumberReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBlockNumberErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBlockNumberErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, GetBlockNumberErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockNumberData,
      type GetBlockNumberOptions,
      type GetBlockNumberQueryFnData,
      type GetBlockNumberQueryKey,
      getBlockNumberQueryKey,
      getBlockNumberQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getBlockNumber`](https://wagmi.sh/core/api/actions/getBlockNumber)
*   [`watchBlockNumber`](https://wagmi.sh/core/api/actions/watchBlockNumber)</content>
</page>

<page>
  <title>Write to Contract | Wagmi</title>
  <url>https://wagmi.sh/react/guides/write-to-contract</url>
  <content>The [`useWriteContract` Hook](https://wagmi.sh/react/api/hooks/useWriteContract) allows you to mutate data on a smart contract, from a `payable` or `nonpayable` (write) function. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

In the guide below, we will teach you how to implement a "Mint NFT" form that takes in a dynamic argument (token ID) using Wagmi. The example below builds on the [Connect Wallet guide](https://wagmi.sh/react/guides/connect-wallet) and uses the [useWriteContract](https://wagmi.sh/react/api/hooks/useWriteContract) & [useWaitForTransaction](https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt) hooks.

If you have already completed the [Sending Transactions guide](https://wagmi.sh/react/guides/send-transaction), this guide will look very similar! That's because writing to a contract internally broadcasts & sends a transaction.

Example [‚Äã](#example)
---------------------

Feel free to check out the example before moving on:

Steps [‚Äã](#steps)
-----------------

### 1\. Connect Wallet [‚Äã](#_1-connect-wallet)

Follow the [Connect Wallet guide](https://wagmi.sh/react/guides/connect-wallet) guide to get this set up.

### 2\. Create a new component [‚Äã](#_2-create-a-new-component)

Create your `MintNFT` component that will contain the Mint NFT logic.

mint-nft.tsx

tsx

    import * as React from 'react'
     
    export function MintNFT() {
      return (
        <form>
          <input name="tokenId" placeholder="69420" required />
          <button type="submit">Mint</button>
        </form>
      )
    }

### 3\. Add a form handler [‚Äã](#_3-add-a-form-handler)

Next, we will need to add a handler to the form that will send the transaction when the user hits "Mint". This will be a basic handler in this step.

mint-nft.tsx

tsx

    import * as React from 'react'
     
    export function MintNFT() {
      async function submit(e: React.FormEvent<HTMLFormElement>) {
        e.preventDefault()
        const formData = new FormData(e.target as HTMLFormElement)
        const tokenId = formData.get('tokenId') as string
      }
    
      return (
        <form>
        <form onSubmit={submit}>
          <input name="tokenId" placeholder="69420" required />
          <button type="submit">Mint</button>
        </form>
      )
    }

### 4\. Hook up the `useWriteContract` Hook [‚Äã](#_4-hook-up-the-usewritecontract-hook)

Now that we have the form handler, we can hook up the [`useWriteContract` Hook](https://wagmi.sh/react/api/hooks/useWriteContract) to send the transaction.

mint-nft.tsxabi.ts

tsx

    import * as React from 'react'
    import { useWriteContract } from 'wagmi'
    import { abi } from './abi'
     
    export function MintNFT() {
      const { data: hash, writeContract } = useWriteContract()
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const tokenId = formData.get('tokenId') as string 
        writeContract({
          address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
          abi,
          functionName: 'mint',
          args: [BigInt(tokenId)],
        })
      } 
    
      return (
        <form onSubmit={submit}>
          <input name="tokenId" placeholder="69420" required />
          <button type="submit">Mint</button>
          {hash && <div>Transaction Hash: {hash}</div>}
        </form>
      )
    }

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 5\. Add loading state (optional) [‚Äã](#_5-add-loading-state-optional)

We can optionally add a loading state to the "Mint" button while we are waiting confirmation from the user's wallet.

mint-nft.tsxabi.ts

tsx

    import * as React from 'react'
    import { useWriteContract } from 'wagmi'
    import { abi } from './abi'
     
    export function MintNFT() {
      const { 
        data: hash, 
        isPending,
        writeContract 
      } = useWriteContract() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const tokenId = formData.get('tokenId') as string 
        writeContract({
          address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
          abi,
          functionName: 'mint',
          args: [BigInt(tokenId)],
        })
      } 
    
      return (
        <form onSubmit={submit}>
          <input name="tokenId" placeholder="69420" required />
          <button 
            disabled={isPending}
            type="submit"
          >
            Mint
            {isPending ? 'Confirming...' : 'Mint'}
          </button>
          {hash && <div>Transaction Hash: {hash}</div>}
        </form>
      )
    }

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 6\. Wait for transaction receipt (optional) [‚Äã](#_6-wait-for-transaction-receipt-optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Hook](https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt).

mint-nft.tsxabi.ts

tsx

    import * as React from 'react'
    import { 
      useWaitForTransactionReceipt,
      useWriteContract 
    } from 'wagmi'
    import { abi } from './abi'
     
    export function MintNFT() {
      const { 
        data: hash, 
        isPending, 
        writeContract 
      } = useWriteContract() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const tokenId = formData.get('tokenId') as string 
        writeContract({
          address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
          abi,
          functionName: 'mint',
          args: [BigInt(tokenId)],
        })
      } 
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } =
        useWaitForTransactionReceipt({
          hash,
        })
    
      return (
        <form onSubmit={submit}>
          <input name="tokenId" placeholder="69420" required />
          <button 
            disabled={isPending} 
            type="submit"
          >
            {isPending ? 'Confirming...' : 'Mint'} 
          </button>
          {hash && <div>Transaction Hash: {hash}</div>}
          {isConfirming && <div>Waiting for confirmation...</div>}
          {isConfirmed && <div>Transaction confirmed.</div>}
        </form>
      )
    }

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 7\. Handle errors (optional) [‚Äã](#_7-handle-errors-optional)

If the user rejects the transaction, or the contract reverts, we can display an error message to the user.

mint-nft.tsxabi.ts

tsx

    import * as React from 'react'
    import { 
      type BaseError,
      useWaitForTransactionReceipt, 
      useWriteContract 
    } from 'wagmi'
    import { abi } from './abi'
     
    export function MintNFT() {
      const { 
        data: hash,
        error,
        isPending, 
        writeContract 
      } = useWriteContract() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const tokenId = formData.get('tokenId') as string 
        writeContract({
          address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
          abi,
          functionName: 'mint',
          args: [BigInt(tokenId)],
        })
      } 
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } = 
        useWaitForTransactionReceipt({ 
          hash, 
        }) 
    
      return (
        <form onSubmit={submit}>
          <input name="tokenId" placeholder="69420" required />
          <button 
            disabled={isPending} 
            type="submit"
          >
            {isPending ? 'Confirming...' : 'Mint'} 
          </button>
          {hash && <div>Transaction Hash: {hash}</div>}
          {isConfirming && <div>Waiting for confirmation...</div>} 
          {isConfirmed && <div>Transaction confirmed.</div>} 
          {error && (
            <div>Error: {(error as BaseError).shortMessage || error.message}</div>
          )}
        </form>
      )
    }

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 8\. Wire it up! [‚Äã](#_8-wire-it-up)

Finally, we can wire up our Mint NFT component to our application's entrypoint.

app.tsxmint-nft.tsxabi.tsconfig.ts

tsx

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { WagmiProvider, useAccount } from 'wagmi'
    import { config } from './config'
    import { MintNft } from './mint-nft'
    
    const queryClient = new QueryClient()
    
    function App() {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}> 
            <MintNft />
          </QueryClientProvider> 
        </WagmiProvider>
      )
    }

tsx

    import * as React from 'react'
    import { 
      type BaseError, 
      useWaitForTransactionReceipt, 
      useWriteContract 
    } from 'wagmi'
    import { abi } from './abi'
     
    export function MintNFT() {
      const { 
        data: hash,
        error,   
        isPending, 
        writeContract 
      } = useWriteContract() 
    
      async function submit(e: React.FormEvent<HTMLFormElement>) { 
        e.preventDefault() 
        const formData = new FormData(e.target as HTMLFormElement) 
        const tokenId = formData.get('tokenId') as string 
        writeContract({
          address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
          abi,
          functionName: 'mint',
          args: [BigInt(tokenId)],
        })
      } 
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } = 
        useWaitForTransactionReceipt({ 
          hash, 
        }) 
    
      return (
        <form onSubmit={submit}>
          <input name="tokenId" placeholder="69420" required />
          <button 
            disabled={isPending} 
            type="submit"
          >
            {isPending ? 'Confirming...' : 'Mint'} 
          </button>
          {hash && <div>Transaction Hash: {hash}</div>}
          {isConfirming && <div>Waiting for confirmation...</div>} 
          {isConfirmed && <div>Transaction confirmed.</div>} 
          {error && ( 
            <div>Error: {(error as BaseError).shortMessage || error.message}</div> 
          )} 
        </form>
      )
    }

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

tsx

    import { http, createConfig } from 'wagmi'
    import { base, mainnet, optimism } from 'wagmi/chains'
    import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

[See the Example.](#example)</content>
</page>

<page>
  <title>useBlockTransactionCount | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useBlockTransactionCount</url>
  <content>Hook for fetching the number of Transactions at a block number, hash or tag.

Import [‚Äã](#import)
-------------------

ts

    import { useBlockTransactionCount } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useBlockTransactionCount } from 'wagmi'
    
    function App() {
      const result = useBlockTransactionCount()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBlockTransactionCountParameters } from 'wagmi'

### blockHash [‚Äã](#blockhash)

`` `0x${string}` ``

Transaction count at a given block hash.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d'
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint`

Transaction count at a given block number.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        blockNumber: 42069n
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Transaction count at a given block tag. Defaults to `'latest'`.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        blockTag: 'pending'
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useBlock({
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useBlockTransactionCount } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlockTransactionCount({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useBlockTransactionCount } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlockTransactionCount({
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBlockTransactionCountErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBlockTransactionCountErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBlockTransactionCountReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBlockTransactionCountErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBlockTransactionCountErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, GetBlockTransactionCountErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockTransactionCountData,
      type GetBlockTransactionCountOptions,
      type GetBlockTransactionCountQueryFnData,
      type GetBlockTransactionCountQueryKey,
      getBlockTransactionCountQueryKey,
      getBlockTransactionCountQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getBlockTransactionCount`](https://wagmi.sh/core/api/actions/getBlockTransactionCount)</content>
</page>

<page>
  <title>unstable_connector | Wagmi</title>
  <url>https://wagmi.sh/react/api/transports/unstable_connector</url>
  <content>The `unstable_connector` Transport connects to a JSON-RPC API via the provided [Connector](https://wagmi.sh/react/api/connectors).

For example, if the provided Connector is [`injected`](https://wagmi.sh/react/api/connectors/injected) and the end-user uses MetaMask, then outgoing JSON-RPC requests will be sent via the MetaMask EIP-1193 Provider (`window.ethereum`).

Import [‚Äã](#import)
-------------------

ts

    import { unstable_connector } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      fallback,
      unstable_connector,
    } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: fallback([
          unstable_connector(injected), 
          http('https://foo-bar-baz.quiknode.pro/...')
        ])
      },
    })

WARNING

It is **highly recommended** to use the `unstable_connector` Transport inside of a [`fallback` Transport](https://wagmi.sh/react/api/transports/fallback). This ensures that if the Connector request fails, the Transport will fall back to a different Transport in the fallback set.

Some common cases for a Connector request to fail are:

*   Chain ID mismatches,
*   Connector RPC not supporting the requested method and/or only supporting a subset of methods for connected accounts,
*   Rate-limiting of Connector RPC.

Parameters [‚Äã](#parameters)
---------------------------

### connector [‚Äã](#connector)

`Connector`

The Connector to use for the Transport.

ts

    import { unstable_connector } from 'wagmi'
    import { safe } from 'wagmi/connectors'
    
    const transport = unstable_connector(safe)

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"connector"`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, { 
      key: 'injected',  
    })

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"Connector"`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, { 
      name: 'Injected',  
    })

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, {
      retryDelay: 100, 
    })</content>
</page>

<page>
  <title>useChainId | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useChainId</url>
  <content>Hook for getting current chain ID.

Import [‚Äã](#import)
-------------------

ts

    import { useChainId } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useChainId } from 'wagmi'
    
    function App() {
      const chainId = useChainId()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseChainIdParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useChainId } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const chainId = useChainId({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseChainIdReturnType } from 'wagmi'

`number`

Current chain ID from [`config.state.chainId`](https://wagmi.sh/react/api/createConfig#chainid).

INFO

Only returns chain IDs for chains configured via `createConfig`'s [`chains`](https://wagmi.sh/react/api/createConfig#chains) parameter.

If the active [connection](https://wagmi.sh/react/api/createConfig#connection) [`chainId`](https://wagmi.sh/react/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `useChainId` will return the last configured chain ID.

Action [‚Äã](#action)
-------------------

*   [`getChainId`](https://wagmi.sh/core/api/actions/getChainId)
*   [`watchChainId`](https://wagmi.sh/core/api/actions/watchChainId)</content>
</page>

<page>
  <title>useChains | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useChains</url>
  <content>Hook for getting configured chains

Import [‚Äã](#import)
-------------------

ts

    import { useChains } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useChains } from 'wagmi'
    
    function App() {
      const chains = useChains()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseChainsParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useChains } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const chains = useChains({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseChainsReturnType } from 'wagmi'

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](https://wagmi.sh/react/api/createConfig#chains).

Action [‚Äã](#action)
-------------------

*   [`getChains`](https://wagmi.sh/core/api/actions/getChains)</content>
</page>

<page>
  <title>useBlock | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useBlock</url>
  <content>Hook for fetching information about a block at a block number, hash or tag.

Import [‚Äã](#import)
-------------------

ts

    import { useBlock } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBlockParameters } from 'wagmi'

### blockHash [‚Äã](#blockhash)

`` `0x${string}` ``

Information at a given block hash.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d'
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint`

Information at a given block number.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        blockNumber: 42069n
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Information at a given block tag. Defaults to `'latest'`.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        blockTag: 'pending'
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useBlock({
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlock({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### includeTransactions [‚Äã](#includetransactions)

`boolean`

Whether or not to include transactions as objects.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlock({
        includeTransactions: true
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBlock({
        scopeKey: 'foo'
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### watch [‚Äã](#watch)

`boolean | UseWatchBlockParameters | undefined`

*   Enables/disables listening for block changes.
*   Can pass a subset of [`UseWatchBlocksParameters`](https://wagmi.sh/react/api/hooks/useWatchBlocks#parameters) directly to [`useWatchBlocks`](https://wagmi.sh/react/api/hooks/useWatchBlocks).

index.tsxindex-2.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        watch: true,
      })
    }

tsx

    import { useBlock } from 'wagmi'
    
    function App() {
      const result = useBlock({
        watch: {
          pollingInterval: 4_000,
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetBlockData | (() => GetBlockData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetBlockData | ((previousValue: GetBlockData | undefined; previousQuery: Query | undefined) => GetBlockData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetBlockData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBlockErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBlockErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetBlockData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetBlockData | undefined, newData: GetBlockData) => GetBlockData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBlockReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetBlockData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBlockErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBlockErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetBlockData, GetBlockErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockData,
      type GetBlockOptions,
      type GetBlockQueryFnData,
      type GetBlockQueryKey,
      getBlockQueryKey,
      getBlockQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getBlock`](https://wagmi.sh/core/api/actions/getBlock)
*   [`watchBlockNumber`](https://wagmi.sh/core/api/actions/watchBlockNumber)</content>
</page>

<page>
  <title>useConfig | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useConfig</url>
  <content>Hook for getting [`Config`](https://wagmi.sh/react/api/createConfig#config) from nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

Import [‚Äã](#import)
-------------------

ts

    import { useConfig } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsx

tsx

    import { useConfig } from 'wagmi'
    
    function App() {
      const config = useConfig()
    }

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConfigReturnType } from 'wagmi'

If you use TypeScript and [register your `Config`](https://wagmi.sh/react/typescript#register-config), the return type will be inferred.

index.tsxconfig.ts

ts

    import {  } from 'wagmi'
    
    function () {
      const  = ()
    }

ts

    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    declare module 'wagmi' {
      interface Register {
        config: typeof config
      }
    }
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })</content>
</page>

<page>
  <title>useBytecode | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useBytecode</url>
  <content>Hook for retrieving the bytecode at an address.

Import [‚Äã](#import)
-------------------

ts

    import { useBytecode } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    
    function App() {
      const result = useBytecode({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBytecodeParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

The contract address.

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    
    function App() {
      const result = useBytecode({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

The block number to check the bytecode at.

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    
    function App() {
      const result = useBytecode({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        blockNumber: 16280770n,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    
    function App() {
      const result = useBytecode({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        blockTag: 'safe',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useBytecode({
        chainId: mainnet.id,
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBytecode({
        config,
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useBytecode } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useBytecode({
        scopeKey: 'foo'
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetBytecodeData | (() => GetBytecodeData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetBytecodeData | ((previousValue: GetBytecodeData | undefined; previousQuery: Query | undefined) => GetBytecodeData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetBytecodeData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBytecodeErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBytecodeErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetBytecodeData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetBytecodeData | undefined, newData: GetBytecodeData) => GetBytecodeData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBytecodeReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetBytecodeData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBytecodeErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBytecodeErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetBytecodeData, GetBytecodeErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBytecodeData,
      type GetBytecodeOptions,
      type GetBytecodeQueryFnData,
      type GetBytecodeQueryKey,
      getBytecodeQueryKey,
      getBytecodeQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getBytecode`](https://wagmi.sh/core/api/actions/getBytecode)</content>
</page>

<page>
  <title>useCall | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useCall</url>
  <content>Hook for executing a new message call immediately without submitting a transaction to the network.

Import [‚Äã](#import)
-------------------

ts

    import { useCall } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseCallParameters } from 'wagmi'

### account [‚Äã](#account)

`Account | Address | undefined`

The Account to call from.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`0x${string} | undefined`

A contract hashed method call with encoded args.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`Address | undefined`

The contract address or recipient.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        accessList: [
          {
            address: '0x1',
            storageKeys: ['0x1'],
          },
        ],
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

The gas provided for transaction execution.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        gas: 1_000_000n,
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        gasPrice: parseGwei('20'),
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        maxFeePerGas: parseGwei('20'),
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        maxFeePerGas: parseGwei('20'),
        maxPriorityFeePerGas: parseGwei('2'),
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### nonce [‚Äã](#nonce)

`number | undefined`

Unique number identifying this transaction.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        nonce: 420,
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value (in wei) sent with this transaction.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`number | undefined`

The block number to perform the call against.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        blockNumber: 15121123n,
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to perform the call against.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    
    function App() {
      const result = useCall({
        blockTag: 'safe',
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The block tag to perform the call against.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    import { mainnet } from '@wagmi/core/chains'
    
    function App() {
      const result = useCall({
        chainId: mainnet.id,
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useCall({
        config,
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useCall } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useCall({
        scopeKey: 'foo'
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`CallData | (() => CallData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`CallData | ((previousValue: CallData | undefined; previousQuery: Query | undefined) => CallData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: CallData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: CallErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: CallErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: CallData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: CallData | undefined, newData: CallData) => CallData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseCallReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data-1)

`CallData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | CallErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | CallErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<CallData, CallErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type CallData,
      type CallOptions,
      type CallQueryFnData,
      type CallQueryKey,
      callQueryKey,
      callQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`call`](https://wagmi.sh/core/api/actions/call)</content>
</page>

<page>
  <title>useConnect | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useConnect</url>
  <content>Hook for connecting accounts with [connectors](https://wagmi.sh/react/api/connectors).

Import [‚Äã](#import)
-------------------

ts

    import { useConnect } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useConnect } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    function App() {
      const { connect } = useConnect()
    
      return (
        <button onClick={() => connect({ connector: injected() })}>
          Connect
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseConnectParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useConnect } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useConnect({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`connect`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: ConnectErrorType, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; }, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; }, error: ConnectErrorType, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ConnectErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ConnectErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectReturnType } from 'wagmi'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Globally configured connectors via [`createConfig`](https://wagmi.sh/react/api/createConfig#connectors). Useful for rendering a list of available connectors.

index.tsxconfig.ts

tsx

    import { useConnect } from 'wagmi'
    
    function App() {
      const { connect, connectors } = useConnect()
    
      return (
        <div>
          {connectors.map((connector) => (
            <button key={connector.id} onClick={() => connect({ connector })}>
              {connector.name}
            </button>
          ))}
        </div>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### connect [‚Äã](#mutate)

`(variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }`
    
    The variables object to pass to the [`connect`](https://wagmi.sh/core/api/actions/connect#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; }, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: ConnectErrorType, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; } | undefined, error: ConnectErrorType | null, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### connectAsync [‚Äã](#mutate-async)

`(variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, { onSuccess, onSettled, onError }) => Promise<{ accounts: readonly [Address, ...Address[]]; chainId: number; }>`

Similar to [`connect`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`{ accounts: readonly [Address, ...Address[]]; chainId: number; } | undefined`

*   [`connect` return type](https://wagmi.sh/core/api/actions/connect#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`ConnectErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`ConnectErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; } | undefined`

*   The variables object passed to [`connect`](#mutate).
*   Defaults to `undefined`.

TIP

Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider (e.g. wallet) is connected to.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ConnectData,
      type ConnectVariables,
      type ConnectMutate,
      type ConnectMutateAsync,
      connectMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`connect`](https://wagmi.sh/core/api/actions/connect)</content>
</page>

<page>
  <title>useClient | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useClient</url>
  <content>Hook for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

Import [‚Äã](#import)
-------------------

ts

    import { useClient } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useClient } from 'wagmi'
    
    function App() {
      const client = useClient()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseClientParameters } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

index.tsconfig.ts

ts

    import { useClient } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { config } from './config'
    
    function App() {
      const client = useClient({
        chainId: mainnet.id, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useClient } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const client = useClient({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseClientReturnType } from 'wagmi'

`Client | undefined`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

Action [‚Äã](#action)
-------------------

*   [`getClient`](https://wagmi.sh/core/api/actions/getClient)
*   [`watchClient`](https://wagmi.sh/core/api/actions/watchClient)</content>
</page>

<page>
  <title>useConnections | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useConnections</url>
  <content>Hook for getting active connections.

Import [‚Äã](#import)
-------------------

ts

    import { useConnections } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useConnections } from 'wagmi'
    
    function App() {
      const connections = useConnections()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseConnectionsParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useConnections } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const connections = useConnections({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectionsReturnType } from 'wagmi'

Action [‚Äã](#action)
-------------------

*   [`getConnections`](https://wagmi.sh/core/api/actions/getConnections)
*   [`watchConnections`](https://wagmi.sh/core/api/actions/watchConnections)</content>
</page>

<page>
  <title>useConnectors | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useConnectors</url>
  <content>Hook for getting configured connectors.

Import [‚Äã](#import)
-------------------

ts

    import { useConnectors } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useConnectors } from 'wagmi'
    
    function App() {
      const connectors = useConnectors()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectorsReturnType } from 'wagmi'

`readonly Connector[]`

Connectors from [`config.connectors`](https://wagmi.sh/react/api/createConfig#connectors-1).

Action [‚Äã](#action)
-------------------

*   [`getConnectors`](https://wagmi.sh/core/api/actions/getConnectors)</content>
</page>

<page>
  <title>useConnectorClient | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useConnectorClient</url>
  <content>Hook for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

Import [‚Äã](#import)
-------------------

ts

    import { useConnectorClient } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useConnectorClient } from 'wagmi'
    
    function App() {
      const result = useConnectorClient()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseConnectorClientParameters } from 'wagmi'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

ts

    import { useConnectorClient } from 'wagmi'
    
    function App() {
      const result = useConnectorClient({
        account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      })
    }

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

ts

    import { useConnectorClient } from 'wagmi'
    
    function App() {
      const result = useConnectorClient({
        chainId: mainnet.id, 
      })
    }

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useConnectorClient } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useConnectorClient({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to get client for.
*   Defaults to current connector.

ts

    import { useConnections, useConnectorClient } from 'wagmi'
    
    function App() {
      const connections = useConnections(config)
      const result = useConnectorClient({
        connector: connections[0]?.connector, 
      })
    }

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### initialData [‚Äã](#initialdata)

`Client | (() => Client) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`Client | ((previousValue: Client | undefined; previousQuery: Query | undefined) => Client) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: Client | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetConnectorClientErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetConnectorClientErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: Client) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: Client | undefined, newData: Client) => Client)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectorClientReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`Client`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetConnectorClientErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetConnectorClientErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<Client, GetConnectorClientErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetConnectorClientData,
      type GetConnectorClientOptions,
      type GetConnectorClientQueryFnData,
      type GetConnectorClientQueryKey,
      getConnectorClientQueryKey,
      getConnectorClientQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getConnectorClient`](https://wagmi.sh/core/api/actions/getConnectorClient)</content>
</page>

<page>
  <title>useDeployContract | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useDeployContract</url>
  <content>useDeployContract viem@>=2.8.18 [‚Äã](#usedeploycontract)
-------------------------------------------------------

Hook for deploying a contract to the network, given bytecode, and constructor arguments.

Import [‚Äã](#import)
-------------------

ts

    import { useDeployContract } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxabi.tsconfig.ts

tsx

    import { useDeployContract } from 'wagmi'
    import { parseEther } from 'viem'
    import { wagmiAbi } from './abi'
    
    function App() {
      const { deployContract } = useDeployContract()
    
      return (
        <button
          onClick={() =>
            deployContract({
              abi: wagmiAbi,
              bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
            })
          }
        >
          Deploy Contract
        </button>
      )
    }

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Deploying with Constructor Args [‚Äã](#deploying-with-constructor-args)
---------------------------------------------------------------------

index.tsxabi.tsconfig.ts

tsx

    import { useDeployContract } from 'wagmi'
    import { parseEther } from 'viem'
    import { wagmiAbi } from './abi'
    
    function App() {
      const { deployContract } = useDeployContract()
    
      return (
        <button
          onClick={() =>
            deployContract({
              abi: wagmiAbi,
              args: [69420],
              bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
            })
          }
        >
          Deploy Contract
        </button>
      )
    }

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type useDeployContractParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useDeployContract } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useDeployContract({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`deployContract`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: DeployContractErrorType, variables: DeployContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: DeployContractVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: DeployContractData, variables: DeployContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: DeployContractData, error: DeployContractErrorType, variables: DeployContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: DeployContractErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: DeployContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type useDeployContractReturnType } from 'wagmi'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### deployContract [‚Äã](#mutate)

`(variables: DeployContractVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `DeployContractVariables`
    
    The variables object to pass to the [`deployContract`](https://wagmi.sh/core/api/actions/deployContract#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: DeployContractData, variables: DeployContractVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: DeployContractErrorType, variables: DeployContractVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: DeployContractData | undefined, error: DeployContractErrorType | null, variables: DeployContractVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### deployContractAsync [‚Äã](#mutate-async)

`(variables: DeployContractVariables, { onSuccess, onSettled, onError }) => Promise<DeployContractData>`

Similar to [`deployContract`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`DeployContractData | undefined`

*   [`deployContract` return type](https://wagmi.sh/core/api/actions/deployContract#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`DeployContractErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`DeployContractErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`DeployContractVariables | undefined`

*   The variables object passed to [`deployContract`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type DeployContractData,
      type DeployContractVariables,
      type DeployContractMutate,
      type DeployContractMutateAsync,
      deployContractMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`deployContract`](https://wagmi.sh/core/api/actions/deployContract)</content>
</page>

<page>
  <title>useDisconnect | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useDisconnect</url>
  <content>Hook for disconnecting connections.

Import [‚Äã](#import)
-------------------

ts

    import { useDisconnect } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useDisconnect } from 'wagmi'
    
    function App() {
      const { disconnect } = useDisconnect()
    
      return (
        <button onClick={() => disconnect()}>
          Disconnect
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseDisconnectParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useDisconnect } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useDisconnect({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`disconnect`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: DisconnectErrorType, variables: { connector?: Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: { connector?: Connector | undefined; }) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: void, variables: { connector?: Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: void, error: DisconnectErrorType, variables: { connector?: Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: DisconnectErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: DisconnectErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseDisconnectReturnType } from 'wagmi'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Connectors that are currently connected. Useful for rendering a list of connectors to disconnect.

index.tsxconfig.ts

tsx

    import { useDisconnect } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const { connectors, disconnect } = useDisconnect()
    
      return (
        <div>
          {connectors.map((connector) => (
            <button key={connector.id} onClick={() => disconnect({ connector })}>
              {connector.name}
            </button>
          ))}
        </div>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### disconnect [‚Äã](#mutate)

`(variables: { connector?: Connector | undefined; }, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `{ connector?: Connector | undefined; }`
    
    The variables object to pass to the [`disconnect`](https://wagmi.sh/core/api/actions/disconnect#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: void, variables: { connector?: Connector | undefined; }, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: DisconnectErrorType, variables: { connector?: Connector | undefined; }, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: void | undefined, error: DisconnectErrorType | null, variables: { connector?: Connector | undefined; }, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### disconnectAsync [‚Äã](#mutate-async)

`(variables: { connector?: Connector | undefined; }, { onSuccess, onSettled, onError }) => Promise<void>`

Similar to [`disconnect`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`void | undefined`

*   [`disconnect` return type](https://wagmi.sh/core/api/actions/disconnect#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`DisconnectErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`DisconnectErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`{ connector?: Connector | undefined; } | undefined`

*   The variables object passed to [`disconnect`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type DisconnectData,
      type DisconnectVariables,
      type DisconnectMutate,
      type DisconnectMutateAsync,
      disconnectMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`disconnect`](https://wagmi.sh/core/api/actions/disconnect)</content>
</page>

<page>
  <title>useEnsAvatar | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEnsAvatar</url>
  <content>Hook for fetching ENS avatar for name.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsAvatar } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsAvatarParameters } from 'wagmi'

* * *

### assetGatewayUrls viem@>=2.3.1 [‚Äã](#assetgatewayurls)

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    function App() {
      const result = useEnsAvatar({
        assetGatewayUrls: { 
          ipfs: 'https://cloudflare-ipfs.com', 
        }, 
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS avatar at.

index.tsconfig.ts

ts

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        blockNumber: 17829139n, 
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS avatar at.

index.tsconfig.ts

ts

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        name: normalize('wevm.eth'),
        blockTag: 'latest', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEnsAvatar } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        chainId: mainnet.id, // [!code focus],
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    function App() {
      const result = useEnsAvatar({
        config,
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gatewayUrls [‚Äã](#gatewayurls)

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

index.tsconfig.ts

ts

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        gatewayUrls: ['https://cloudflare-ipfs.com'] { 
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string | undefined`

Name to get the avatar for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

index.tsconfig.ts

ts

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        name: normalize('wevm.eth'), 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        name: normalize('wevm.eth'),
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { useEnsAvatar } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAvatar({
        name: normalize('wevm.eth'),
        universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | null | (() => string | null) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | null | ((previousValue: string | null | undefined; previousQuery: Query | undefined) => string | null) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | null | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsAvatarErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsAvatarErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string | null) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | null | undefined, newData: string | null) => string | null)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsAvatarReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string | null`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsAvatarErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsAvatarErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string | null, GetEnsAvatarErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsAvatarData,
      type GetEnsAvatarOptions,
      type GetEnsAvatarQueryFnData,
      type GetEnsAvatarQueryKey,
      getEnsAvatarQueryKey,
      getEnsAvatarQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsAvatar`](https://wagmi.sh/core/api/actions/getEnsAvatar)</content>
</page>

<page>
  <title>useEnsAddress | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEnsAddress</url>
  <content>Hook for fetching ENS address for name.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsAddress } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsAddressParameters } from 'wagmi'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS address at.

index.tsconfig.ts

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        blockNumber: 17829139n, 
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

index.tsconfig.ts

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        name: normalize('wevm.eth'),
        blockTag: 'latest', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEnsAddress } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        chainId: mainnet.id,
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### coinType [‚Äã](#cointype)

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

index.tsconfig.ts

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        coinType: 60, 
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    function App() {
      const result = useEnsAddress({
        config,
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string | undefined`

Name to get the address for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

index.tsconfig.ts

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        name: normalize('wevm.eth'), 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        name: normalize('wevm.eth'),
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { useEnsAddress } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsAddress({
        name: normalize('wevm.eth'),
        universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | (() => string) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | ((previousValue: string | undefined; previousQuery: Query | undefined) => string) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsAddressErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsAddressErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | undefined, newData: string) => string)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsAddressReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsAddressErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsAddressErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string, GetEnsAddressErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsAddressData,
      type GetEnsAddressOptions,
      type GetEnsAddressQueryFnData,
      type GetEnsAddressQueryKey,
      getEnsAddressQueryKey,
      getEnsAddressQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsAddress`](https://wagmi.sh/core/api/actions/getEnsAddress)</content>
</page>

<page>
  <title>useEnsName | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEnsName</url>
  <content>Hook for fetching primary ENS name for address.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsName } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEnsName } from 'wagmi'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsNameParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

index.tsconfig.ts

ts

    import { useEnsName } from 'wagmi'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS name at.

index.tsconfig.ts

ts

    import { useEnsName } from 'wagmi'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        blockNumber: 17829139n, 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS name at.

index.tsconfig.ts

ts

    import { useEnsName } from 'wagmi'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        blockTag: 'latest', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEnsName } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEnsName } from 'wagmi'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEnsName } from 'wagmi'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { useEnsName } from 'wagmi'
    
    function App() {
      const result = useEnsName({
        address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | null | (() => string | null) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | null | ((previousValue: string | null | undefined; previousQuery: Query | undefined) => string | null) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | null | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsNameErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsNameErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string | null) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | null | undefined, newData: string | null) => string | null)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsNameReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string | null`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsNameErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsNameErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string | null, GetEnsNameErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsNameData,
      type GetEnsNameOptions,
      type GetEnsNameQueryFnData,
      type GetEnsNameQueryKey,
      getEnsNameQueryKey,
      getEnsNameQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsName`](https://wagmi.sh/core/api/actions/getEnsName)</content>
</page>

<page>
  <title>usePublicClient | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/usePublicClient</url>
  <content>Hook for getting Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

Import [‚Äã](#import)
-------------------

ts

    import { usePublicClient } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { usePublicClient } from 'wagmi'
    
    function App() {
      const client = usePublicClient()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

If you want to optimize bundle size, you should use [`useClient`](https://wagmi.sh/react/api/hooks/useClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Public Client has all public actions attached directly to it.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UsePublicClientParameters } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Public Client.

index.tsconfig.ts

ts

    import { usePublicClient } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { config } from './config'
    
    function App() {
      const client = usePublicClient({
        chainId: mainnet.id, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { usePublicClient } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const client = usePublicClient({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UsePublicClientReturnType } from 'wagmi'

`PublicClient | undefined`

Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

Action [‚Äã](#action)
-------------------

*   [`getPublicClient`](https://wagmi.sh/core/api/actions/getPublicClient)
*   [`watchPublicClient`](https://wagmi.sh/core/api/actions/watchPublicClient)</content>
</page>

<page>
  <title>useFeeHistory | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useFeeHistory</url>
  <content>Hook for fetching a collection of historical gas information.

Import [‚Äã](#import)
-------------------

ts

    import { useFeeHistory } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        rewardPercentiles: [25, 75]
    })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseFeeHistoryParameters } from 'wagmi'

### blockCount [‚Äã](#blockcount)

`number | undefined`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        rewardPercentiles: [25, 75]
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### rewardPercentiles [‚Äã](#rewardpercentiles)

`number[] | undefined`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        rewardPercentiles: [25, 75]
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Highest number block of the requested range.

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        blockNumber: 1551231n,
        rewardPercentiles: [25, 75]
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag of the highest number block of the requested range.

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        blockTag: 'safe',
        rewardPercentiles: [25, 75]
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    import { mainnet } from '@wagmi/core/chains'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        chainId: mainnet.id,
        rewardPercentiles: [25, 75]
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        rewardPercentiles: [25, 75]
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useFeeHistory } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useFeeHistory({
        blockCount: 4,
        rewardPercentiles: [25, 75]
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetFeeHistoryErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetFeeHistoryErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseFeeHistoryReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetFeeHistoryErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetFeeHistoryErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, GetFeeHistoryErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetFeeHistoryData,
      type GetFeeHistoryOptions,
      type GetFeeHistoryQueryFnData,
      type GetFeeHistoryQueryKey,
      getFeeHistoryQueryKey,
      getFeeHistoryQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getFeeHistory`](https://wagmi.sh/core/api/actions/getFeeHistory)</content>
</page>

<page>
  <title>useEstimateFeesPerGas | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEstimateFeesPerGas</url>
  <content>Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

Import [‚Äã](#import)
-------------------

ts

    import { useEstimateFeesPerGas } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEstimateFeesPerGas } from 'wagmi'
    
    function App() {
      const result = useEstimateFeesPerGas()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEstimateFeesPerGas } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEstimateFeesPerGas } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useEstimateFeesPerGas({
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEstimateFeesPerGas } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useEstimateFeesPerGas({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### formatUnits [‚Äã](#formatunits)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.tsconfig.ts

ts

    import { useEstimateFeesPerGas } from 'wagmi'
    
    function App() {
      const result = useEstimateFeesPerGas({
        formatUnits: 'ether', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEstimateFeesPerGas } from 'wagmi'
    
    function App() {
      const result = useEstimateFeesPerGas({
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559'`

*   Defaults to `'eip1559'`

index.tsconfig.ts

ts

    import { useEstimateFeesPerGas } from 'wagmi'
    
    function App() {
      const result = useEstimateFeesPerGas({
        type: 'legacy', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`{ formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; } | (() => { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`{ formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; } | ((previousValue: { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; } | undefined; previousQuery: Query | undefined) => { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; } | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: EstimateFeesPerGasErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: EstimateFeesPerGasErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; } | undefined, newData: { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }) => { formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; })) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEstimateFeesPerGasReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`{ formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | EstimateFeesPerGasErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | EstimateFeesPerGasErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<{ formatted: { gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }; gasPrice: bigint | undefined; maxFeePerGas: bigint | undefined; maxPriorityFeePerGas: bigint | undefined; }, EstimateFeesPerGasErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateFeesPerGasData,
      type EstimateFeesPerGasOptions,
      type EstimateFeesPerGasQueryFnData,
      type EstimateFeesPerGasQueryKey,
      estimateFeesPerGasQueryKey,
      estimateFeesPerGasQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`estimateFeesPerGas`](https://wagmi.sh/core/api/actions/estimateFeesPerGas)</content>
</page>

<page>
  <title>useEnsText | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEnsText</url>
  <content>Hook for fetching a text record for a specified ENS name and key.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsText } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        name: normalize('wevm.eth'),
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsText`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsTextParameters } from 'wagmi'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get the text at.

index.tsconfig.ts

ts

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        blockNumber: 17829139n, 
        name: normalize('wevm.eth'),
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the text at.

index.tsconfig.ts

ts

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        blockTag: 'latest', 
        name: normalize('wevm.eth'),
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEnsText } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        chainId: mainnet.id,
        name: normalize('wevm.eth'),
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### key [‚Äã](#key)

`string | undefined`

ENS key to get Text for.

index.tsconfig.ts

ts

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        name: normalize('wevm.eth'),
        key: 'com.twitter', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string | undefined`

Name to get the text for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

index.tsconfig.ts

ts

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        name: normalize('wevm.eth'), 
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    function App() {
      const result = useEnsText({
        config,
        name: normalize('wevm.eth'),
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        scopeKey: 'foo', 
        name: normalize('wevm.eth'),
        key: 'com.twitter',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Resolver of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { useEnsText } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsText({
        name: normalize('wevm.eth'),
        key: 'com.twitter',
        universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | null | (() => string | null) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | null | ((previousValue: string | null | undefined; previousQuery: Query | undefined) => string | null) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | null | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsTextErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsTextErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string | null) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | null | undefined, newData: string | null) => string | null)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsTextReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string | null`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsTextErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsTextErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string | null, GetEnsTextErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsTextData,
      type GetEnsTextOptions,
      type GetEnsTextQueryFnData,
      type GetEnsTextQueryKey,
      getEnsTextQueryKey,
      getEnsTextQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsText`](https://wagmi.sh/core/api/actions/getEnsText)</content>
</page>

<page>
  <title>useEstimateMaxPriorityFeePerGas | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEstimateMaxPriorityFeePerGas</url>
  <content>Hook for fetching an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

Import [‚Äã](#import)
-------------------

ts

    import { useEstimateMaxPriorityFeePerGas } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
    
    function App() {
      const result = useEstimateMaxPriorityFeePerGas()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEstimateMaxPriorityFeePerGas } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useEstimateMaxPriorityFeePerGas({
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useEstimateMaxPriorityFeePerGas({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEstimateMaxPriorityFeePerGas } from 'wagmi'
    
    function App() {
      const result = useEstimateMaxPriorityFeePerGas({
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: EstimateMaxPriorityFeePerGasErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: EstimateMaxPriorityFeePerGasErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEstimateMaxPriorityFeePerGasReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | EstimateMaxPriorityFeePerGasErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | EstimateMaxPriorityFeePerGasErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, EstimateMaxPriorityFeePerGasErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateMaxPriorityFeePerGasData,
      type EstimateMaxPriorityFeePerGasOptions,
      type EstimateMaxPriorityFeePerGasQueryFnData,
      type EstimateMaxPriorityFeePerGasQueryKey,
      estimateMaxPriorityFeePerGasQueryKey,
      estimateMaxPriorityFeePerGasQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`estimateMaxPriorityFeePerGas`](https://wagmi.sh/core/api/actions/estimateMaxPriorityFeePerGas)</content>
</page>

<page>
  <title>useProof | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useProof</url>
  <content>Hook for return the account and storage values of the specified account including the Merkle-proof.

Import [‚Äã](#import)
-------------------

ts

    import { useProof } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    
    function App() {
      const result = useProof({
        address: '0x4200000000000000000000000000000000000016',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseProofParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

The account address to get the proof for.

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    
    function App() {
      const result = useProof({
        address: '0x4200000000000000000000000000000000000016',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### storageKeys [‚Äã](#storagekeys)

`` `0x${string}`[] | undefined ``

Array of storage-keys that should be proofed and included.

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    
    function App() {
      const result = useProof({
        address: '0x4200000000000000000000000000000000000016',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Proof at a given block number.

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    
    function App() {
      const result = useProof({
        address: '0x4200000000000000000000000000000000000016',
        blockNumber: 42069n,
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Proof at a given block tag.

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    
    function App() {
      const result = useProof({
        address: '0x4200000000000000000000000000000000000016',
        blockTag: 'latest',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The ID of chain to get the proof for.

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    import { optimism } from 'wagmi/chains'
    
    function App() {
      const result = useProof({
        chainId: optimism.id,
        address: '0x4200000000000000000000000000000000000016',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useProof({
        config,
        address: '0x4200000000000000000000000000000000000016',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useProof } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useProof({
        scopeKey: 'foo'
        address: '0x4200000000000000000000000000000000000016',
        storageKeys: [
          '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetProofData | (() => GetProofData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetProofData | ((previousValue: GetProofData | undefined; previousQuery: Query | undefined) => GetProofData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetProofData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetProofErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetProofErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetProofData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetProofData | undefined, newData: GetProofData) => GetProofData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseProofReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetProofData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetProofErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetProofErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetProofData, GetProofErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetProofData,
      type GetProofOptions,
      type GetProofQueryFnData,
      type GetProofQueryKey,
      getProofQueryKey,
      getProofQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getProof`](https://wagmi.sh/core/api/actions/getProof)</content>
</page>

<page>
  <title>useEnsResolver | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEnsResolver</url>
  <content>Hook for fetching ENS resolver for name.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsResolver } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsResolver`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsResolverParameters } from 'wagmi'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS resolver at.

index.tsconfig.ts

ts

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        blockNumber: 17829139n, 
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS resolver at.

index.tsconfig.ts

ts

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        name: normalize('wevm.eth'),
        blockTag: 'latest', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useEnsResolver } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        chainId: mainnet.id,
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    function App() {
      const result = useEnsResolver({
        config,
        name: normalize('wevm.eth'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string | undefined`

Name to get the resolver for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

index.tsconfig.ts

ts

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        name: normalize('wevm.eth'), 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        name: normalize('wevm.eth'),
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Resolver of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { useEnsResolver } from 'wagmi'
    import { normalize } from 'viem/ens'
    
    function App() {
      const result = useEnsResolver({
        name: normalize('wevm.eth'),
        universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | null | (() => string | null) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | null | ((previousValue: string | null | undefined; previousQuery: Query | undefined) => string | null) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | null | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsResolverErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsResolverErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string | null) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | null | undefined, newData: string | null) => string | null)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsResolverReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string | null`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsResolverErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsResolverErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string | null, GetEnsResolverErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsResolverData,
      type GetEnsResolverOptions,
      type GetEnsResolverQueryFnData,
      type GetEnsResolverQueryKey,
      getEnsResolverQueryKey,
      getEnsResolverQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsResolver`](https://wagmi.sh/core/api/actions/getEnsResolver)</content>
</page>

<page>
  <title>useEstimateGas | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useEstimateGas</url>
  <content>Hook for estimating the gas necessary to complete a transaction without submitting it to the network.

Import [‚Äã](#import)
-------------------

ts

    import { useEstimateGas } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useEstimateGas } from 'wagmi'
    
    function App() {
      const result = useEstimateGas()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEstimateGasParameters } from 'wagmi'

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        accessList: [{ 
          address: '0x1', 
          storageKeys: ['0x1'], 
        }], 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when estimating gas.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { mainnet } from '@wagmi/core/chains'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        chainId: mainnet.id, 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

index.tsconfig.ts

ts

    import { getConnections, estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const connections = getConnections(config)
      const result = useEstimateGas({
        connector: connections[0]?.connector, 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded function data.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        gas: parseGwei('20'), 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        gasPrice: parseGwei('20'), 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        maxFeePerGas: parseGwei('20'), 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        maxFeePerGas: parseGwei('20'),
        maxPriorityFeePerGas: parseGwei('2'), 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        nonce: 123, 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        scopeKey: 'foo', 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`Address | undefined`

The transaction recipient or contract address.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        type: 'eip1559', 
        value: parseEther('0.01'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsconfig.ts

ts

    import { useEstimateGas } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = useEstimateGas({
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
        value: parseEther('0.01'), 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: EstimateGasErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: EstimateGasErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEstimateGasReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data-1)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | EstimateGasErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | EstimateGasErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, EstimateGasErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateGasData,
      type EstimateGasOptions,
      type EstimateGasQueryFnData,
      type EstimateGasQueryKey,
      estimateGasQueryKey,
      estimateGasQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`estimateGas`](https://wagmi.sh/core/api/actions/estimateGas)</content>
</page>

<page>
  <title>useGasPrice | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useGasPrice</url>
  <content>Hook for fetching the current price of gas (in wei).

Import [‚Äã](#import)
-------------------

ts

    import { useGasPrice } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useGasPrice } from 'wagmi'
    
    function App() {
      const result = useGasPrice()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseGasPriceParameters } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useGasPrice } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useGasPrice({
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useGasPrice } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useGasPrice({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useGasPrice } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useGasPrice({
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetGasPriceErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetGasPriceErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseGasPriceReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetGasPriceErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetGasPriceErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, GetGasPriceErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetGasPriceData,
      type GetGasPriceOptions,
      type GetGasPriceQueryFnData,
      type GetGasPriceQueryKey,
      getGasPriceQueryKey,
      getGasPriceQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getGasPrice`](https://wagmi.sh/core/api/actions/getGasPrice)</content>
</page>

<page>
  <title>usePrepareTransactionRequest | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/usePrepareTransactionRequest</url>
  <content>Hook for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

Import [‚Äã](#import)
-------------------

ts

    import { usePrepareTransactionRequest } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UsePrepareTransactionRequestParameters } from 'wagmi'

### account [‚Äã](#account)

`Account | Address | undefined`

The Account to send the transaction from.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`` `0x${string}` | undefined ``

The transaction recipient or contract address.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        accessList: [
          {
            address: '0x1',
            storageKeys: ['0x1'],
          },
        ],
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to prepare the transaction request for.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        chainId: mainnet.id,
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        gasPrice: parseGwei('20'),
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        maxFeePerGas: parseGwei('20'),
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther, parseGwei } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        maxFeePerGas: parseGwei('20'),
        maxPriorityFeePerGas: parseGwei('2'),
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### nonce [‚Äã](#nonce)

`number | undefined`

Unique number identifying this transaction.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
        nonce: 5,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### parameters [‚Äã](#parameters-1)

`("fees" | "gas" | "nonce" | "type")[] | undefined`

Parameters to prepare.

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        parameters: ['gas', 'nonce'],
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const result = usePrepareTransactionRequest({
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = usePrepareTransactionRequest({
        config,
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { usePrepareTransactionRequest } from 'wagmi'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    function App() {
      const result = usePrepareTransactionRequest({
        scopeKey: 'foo'
        account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1'),
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`PrepareTransactionRequestData | (() => PrepareTransactionRequestData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`PrepareTransactionRequestData | ((previousValue: PrepareTransactionRequestData | undefined; previousQuery: Query | undefined) => PrepareTransactionRequestData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: PrepareTransactionRequestData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: PrepareTransactionRequestErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: PrepareTransactionRequestErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: PrepareTransactionRequestData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: PrepareTransactionRequestData | undefined, newData: PrepareTransactionRequestData) => PrepareTransactionRequestData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UsePrepareTransactionRequestReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data-1)

`PrepareTransactionRequestData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | PrepareTransactionRequestErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | PrepareTransactionRequestErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<PrepareTransactionRequestData, PrepareTransactionRequestErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type PrepareTransactionRequestData,
      type PrepareTransactionRequestOptions,
      type PrepareTransactionRequestQueryFnData,
      type PrepareTransactionRequestQueryKey,
      prepareTransactionRequestQueryKey,
      prepareTransactionRequestQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`prepareTransactionRequest`](https://wagmi.sh/core/api/actions/prepareTransactionRequest)</content>
</page>

<page>
  <title>useSendTransaction | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSendTransaction</url>
  <content>Hook for creating, signing, and sending transactions to networks.

Import [‚Äã](#import)
-------------------

ts

    import { useSendTransaction } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useSendTransaction } from 'wagmi'
    import { parseEther } from 'viem'
    
    function App() {
      const { sendTransaction } = useSendTransaction()
    
      return (
        <button
          onClick={() =>
            sendTransaction({
              to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
              value: parseEther('0.01'),
            })
          }
        >
          Send transaction
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSendTransactionParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useSendTransaction } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useSendTransaction({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`sendTransaction`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SendTransactionErrorType, variables: SendTransactionVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SendTransactionVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SendTransactionData, variables: SendTransactionVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SendTransactionData, error: SendTransactionErrorType, variables: SendTransactionVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SendTransactionErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SendTransactionErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSendTransactionReturnType } from 'wagmi'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### sendTransaction [‚Äã](#mutate)

`(variables: SendTransactionVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SendTransactionVariables`
    
    The variables object to pass to the [`sendTransaction`](https://wagmi.sh/core/api/actions/sendTransaction#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SendTransactionData, variables: SendTransactionVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SendTransactionErrorType, variables: SendTransactionVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SendTransactionData | undefined, error: SendTransactionErrorType | null, variables: SendTransactionVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### sendTransactionAsync [‚Äã](#mutate-async)

`(variables: SendTransactionVariables, { onSuccess, onSettled, onError }) => Promise<SendTransactionData>`

Similar to [`sendTransaction`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SendTransactionData | undefined`

*   [`sendTransaction` return type](https://wagmi.sh/core/api/actions/sendTransaction#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SendTransactionErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SendTransactionErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SendTransactionVariables | undefined`

*   The variables object passed to [`sendTransaction`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SendTransactionData,
      type SendTransactionVariables,
      type SendTransactionMutate,
      type SendTransactionMutateAsync,
      sendTransactionMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`sendTransaction`](https://wagmi.sh/core/api/actions/sendTransaction)</content>
</page>

<page>
  <title>useSignMessage | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSignMessage</url>
  <content>Hook for signing messages.

Import [‚Äã](#import)
-------------------

ts

    import { useSignMessage } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useSignMessage } from 'wagmi'
    
    function App() {
      const { signMessage } = useSignMessage()
    
      return (
        <button onClick={() => signMessage({ message: 'hello world' })}>
          Sign message
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSignMessageParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useSignMessage } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useSignMessage({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`signMessage`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SignMessageErrorType, variables: SignMessageVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SignMessageVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SignMessageData, variables: SignMessageVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SignMessageData, error: SignMessageErrorType, variables: SignMessageVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SignMessageErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SignMessageErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSignMessageReturnType } from 'wagmi'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### signMessage [‚Äã](#mutate)

`(variables: SignMessageVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SignMessageVariables`
    
    The variables object to pass to the [`signMessage`](https://wagmi.sh/core/api/actions/signMessage#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SignMessageData, variables: SignMessageVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SignMessageErrorType, variables: SignMessageVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SignMessageData | undefined, error: SignMessageErrorType | null, variables: SignMessageVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### signMessageAsync [‚Äã](#mutate-async)

`(variables: SignMessageVariables, { onSuccess, onSettled, onError }) => Promise<SignMessageData>`

Similar to [`signMessage`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SignMessageData | undefined`

*   [`signMessage` return type](https://wagmi.sh/core/api/actions/signMessage#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SignMessageErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SignMessageErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SignMessageVariables | undefined`

*   The variables object passed to [`signMessage`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SignMessageData,
      type SignMessageVariables,
      type SignMessageMutate,
      type SignMessageMutateAsync,
      signMessageMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`signMessage`](https://wagmi.sh/core/api/actions/signMessage)</content>
</page>

<page>
  <title>useReconnect | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useReconnect</url>
  <content>Hook for reconnecting [connectors](https://wagmi.sh/core/api/connectors).

Import [‚Äã](#import)
-------------------

ts

    import { useReconnect } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsx

tsx

    import { useReconnect } from 'wagmi'
    import { useEffect } from 'react'
    
    function App() {
      const { reconnect } = useReconnect()
    
      useEffect(() => {
        reconnect()
      }, [])
    }

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseReconnectParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useReconnect } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useReconnect({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`reconnect`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: ReconnectErrorType, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }, error: ReconnectErrorType, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ReconnectErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ReconnectErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseReconnectReturnType } from 'wagmi'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Globally configured connectors via [`createConfig`](https://wagmi.sh/react/api/createConfig#connectors).

index.tsxconfig.ts

tsx

    import { useReconnect } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { useEffect } from 'react'
    
    function App() {
      const { reconnect, connectors } = useReconnect()
    
      useEffect(() => {
        reconnect({ connectors })
      }, [])
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### reconnect [‚Äã](#mutate)

`(variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `{ connectors?: (CreateConnectorFn | Connector)[] | undefined; }`
    
    The variables object to pass to the [`reconnect`](https://wagmi.sh/core/api/actions/reconnect#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: ReconnectErrorType, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector } | undefined, error: ReconnectErrorType | null, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### reconnectAsync [‚Äã](#mutate-async)

`(variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, { onSuccess, onSettled, onError }) => Promise<{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }>`

Similar to [`reconnect`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector } | undefined`

*   [`reconnect` return type](https://wagmi.sh/core/api/actions/reconnect#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`ReconnectErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`ReconnectErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`{ connectors?: (CreateConnectorFn | Connector)[] | undefined; } | undefined`

*   The variables object passed to [`reconnect`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReconnectData,
      type ReconnectVariables,
      type ReconnectMutate,
      type ReconnectMutateAsync,
      reconnectMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`reconnect`](https://wagmi.sh/core/api/actions/reconnect)</content>
</page>

<page>
  <title>useReadContracts | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useReadContracts</url>
  <content>Hook for calling multiple read methods on a contract.

Import [‚Äã](#import)
-------------------

ts

    import { useReadContracts } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    const wagmigotchiContract = {
      address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
      abi: wagmigotchiABI,
    } as const
    const mlootContract = {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
    } as const
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            ...wagmigotchiContract,
            functionName: 'getAlive',
          },
          {
            ...wagmigotchiContract,
            functionName: 'getBoredom',
          },
          {
            ...mlootContract,
            functionName: 'getChest',
            args: [69],
          },
          {
            ...mlootContract,
            functionName: 'getWaist',
            args: [69],
          },
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseReadContractsParameters } from 'wagmi'

### contracts [‚Äã](#contracts)

`readonly Contract[]`

Set of contracts to call.

#### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69],
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69],
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69],
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69],
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69],
            chainId: 1
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### allowFailure [‚Äã](#allowfailure)

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `useReadContracts` will fail silently and its error will be logged in the results array. Defaults to `true`.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        allowFailure: false,
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69]
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### batchSize [‚Äã](#batchsize)

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        batchSize: 1024,
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69]
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`number`

The block number to perform the read against.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        blockNumber: 69420n,
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69]
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        blockTag: 'safe',
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69]
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useReadContracts({
        config,
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69]
          },
          // ...
        ],
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### multicallAddress [‚Äã](#multicalladdress)

`Address`

Address of multicall contract.

index.tsxconfig.ts

tsx

    import { useReadContracts } from 'wagmi'
    
    function App() {
      const result = useReadContracts({
        contracts: [
          {
            address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
            abi: mlootABI,
            functionName: 'getChest',
            args: [69]
          },
          // ...
        ],
        multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`| (() => ) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`| ((previousValue: | undefined; previousQuery: Query | undefined) => ) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: ) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: | undefined, newData: ) => )) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseReadContractsReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null |`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null |`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<, >>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

Action [‚Äã](#action)
-------------------

*   [`readContracts`](https://wagmi.sh/core/api/actions/readContracts)</content>
</page>

<page>
  <title>useReadContract | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useReadContract</url>
  <content>Hook for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

Import [‚Äã](#import)
-------------------

ts

    import { useReadContract } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseReadContractParameters } from 'wagmi'

### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'balanceOf',
        args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
        account: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'balanceOf',
        args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to call contract at.

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
        blockNumber: 17829139n,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
        blockTag: 'safe',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
        chainId: mainnet.id,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'totalSupply',
        config,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'balanceOf',
        args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxabi.tsconfig.ts

tsx

    import { useReadContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useReadContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'balanceOf',
        args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
        scopeKey: 'foo',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`ReadContractReturnType | (() => ReadContractReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`ReadContractReturnType | ((previousValue: ReadContractReturnType | undefined; previousQuery: Query | undefined) => ReadContractReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: ReadContractReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ReadContractErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ReadContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: ReadContractReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: ReadContractReturnType | undefined, newData: ReadContractReturnType) => ReadContractReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseReadContractReturnType } from 'wagmi'

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for more info.

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`ReadContractReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | ReadContractErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | ReadContractErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<ReadContractReturnType, ReadContractErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](https://wagmi.sh/react/typescript) for more information.

InlineConst-Asserted

ts

    const  = ({
      : [
        {
          : 'function',
          : 'balanceOf',
          : 'view',
          : [{ : 'account', : 'address' }],
          : [{ : 'uint256' }],
        },
        {
          : 'function',
          : 'totalSupply',
          : 'view',
          : [],
          : [{ : 'supply', : 'uint256' }],
        },
      ],
      : '0x6b175474e89094c44da98b954eedeac495271d0f',
      : 'balanceOf',
    
    
      : ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    })
    
    .
    

ts

    const  = [
      {
        : 'function',
        : 'balanceOf',
        : 'view',
        : [{ : 'account', : 'address' }],
        : [{ : 'uint256' }],
      },
      {
        : 'function',
        : 'totalSupply',
        : 'view',
        : [],
        : [{ : 'supply', : 'uint256' }],
      },
    ] as 
    
    const  = ({
      ,
      : '0x6b175474e89094c44da98b954eedeac495271d0f',
      : 'balanceOf',
    
    
      : ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    })
    
    .
    

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReadContractData,
      type ReadContractOptions,
      type ReadContractQueryFnData,
      type ReadContractQueryKey,
      readContractQueryKey,
      readContractQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`readContract`](https://wagmi.sh/core/api/actions/readContract)</content>
</page>

<page>
  <title>useInfiniteReadContracts | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useInfiniteReadContracts</url>
  <content>Hook for calling multiple contract read-only methods with "infinite scrolling"/"fetch more" support.

Import [‚Äã](#import)
-------------------

ts

    import { useInfiniteReadContracts } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

The example below shows how to demonstrate how to fetch a set of [mloot](https://etherscan.io/address/0x1dfe7ca09e99d10835bf73044a23b73fc20623df) attributes (chestwear, footwear, and handwear) with "fetch more" support.

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    const mlootContractConfig = {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi,
    } as const
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          const args = [pageParam] as const
          return [
            { ...mlootContractConfig, functionName: 'getChest', args },
            { ...mlootContractConfig, functionName: 'getFoot', args },
            { ...mlootContractConfig, functionName: 'getHand', args },
          ]
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

In the above example, we are setting a few things:

*   [`cacheKey`](#cachekey): A unique key to store the data in the cache.
*   [`query.initialPageParam`](#initialpageparam): An initial page parameter to use when fetching the first set of contracts.
*   [`query.getNextPageParam`](#getnextpageparam): A function that returns the next page parameter to use when fetching the next set of contracts.
*   [`contracts`](#contracts): A function that provides `pageParam` (derived from the above) as an argument and expects to return an array of contracts.

### Paginated Parameters [‚Äã](#paginated-parameters)

We can also leverage properties like `getNextPageParam` with a custom `limit` variable to achieve "pagination" of parameters. For example, we can fetch the first 10 contract functions, then fetch the next 10 contract functions, and so on.

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function Example({ limit = 10 }: { limit?: number } = {}) {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          return [...new Array(limit)].map(
            (_, i) =>
              ({
                address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
                abi,
                functionName: 'getHand',
                args: [BigInt(pageParam + i)],
              }) as const,
          )
        },
        query: {
          initialPageParam: 1,
          getNextPageParam(_lastPage, _allPages, lastPageParam) {
            return lastPageParam + limit
          },
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseInfiniteReadContractsParameters } from 'wagmi'

### cacheKey [‚Äã](#cachekey)

`string`

A unique key to store the data in the cache.

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          // ...
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### contracts [‚Äã](#contracts)

`(pageParam: number) => Contract[]`

A function that provides `pageParam` (derived from the above) as an argument and expects to return an array of contracts.

#### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          const args = [pageParam] as const
          return [
            // ...
            {  
              address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
              abi,
              functionName: 'getChest', 
              args 
            },
            // ...
          ]
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          const args = [pageParam] as const
          return [
            // ...
            {  
              address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
              abi,
              functionName: 'getChest', 
              args 
            },
            // ...
          ]
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          const args = [pageParam] as const
          return [
            // ...
            {  
              address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
              abi,
              functionName: 'getChest',
              args 
            },
            // ...
          ]
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          return [
            // ...
            {  
              address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
              abi,
              functionName: 'getChest', 
              args: [pageParam]
            },
            // ...
          ]
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxabi.tsconfig.ts

tsx

    import { useInfiniteReadContracts } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useInfiniteReadContracts({
        cacheKey: 'mlootAttributes',
        contracts(pageParam) {
          const args = [pageParam] as const
          return [
            // ...
            {  
              address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
              abi,
              functionName: 'getChest', 
              args,
              chainId: 1
            },
            // ...
          ]
        }
        query: {
          initialPageParam: 0,
          getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
            return lastPageParam + 1
          }
        }
      })
    }

ts

    export const abi = [
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getChest',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getFoot',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
        name: 'getHand',
        outputs: [{ internalType: 'string', name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`InfiniteReadContractsData | (() => InfiniteReadContractsData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### initialPageParam [‚Äã](#initialpageparam)

`number`

The initial page parameter to be passed to the query function.

#### getPreviousPageParam [‚Äã](#getpreviouspageparam)

This function can be set to automatically get the previous cursor for infinite queries. The result will also be used to determine the value of `hasPreviousPage`.

`(firstPage: InfiniteReadContractsData, allPages: InfiniteReadContractsData[], firstPageParam: number, allPageParams: number[]) => number | undefined | null`

#### getNextPageParam [‚Äã](#getnextpageparam)

This function can be set to automatically get the previous cursor for infinite queries. The result will also be used to determine the value of `hasPreviousPage`.

`(lastPage: InfiniteReadContractsData, allPages: InfiniteReadContractsData[], lastPageParam: number, allPageParams: number[]) => number | undefined | null`

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`InfiniteReadContractsData | ((previousValue: InfiniteReadContractsData | undefined; previousQuery: Query | undefined) => InfiniteReadContractsData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: InfiniteReadContractsData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ReadContractsErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ReadContractsErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: InfiniteReadContractsData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: InfiniteReadContractsData | undefined, newData: InfiniteReadContractsData) => InfiniteReadContractsData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseInfiniteReadContractsReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`InfiniteReadContractsData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | ReadContractsErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | ReadContractsErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchNextPage [‚Äã](#fetchnextpage)

`(options?: FetchNextPageOptions) => Promise<InfiniteQueryObserverResult<InfiniteReadContractsData, ReadContractsErrorType>>`

This function allows you to fetch the next "page" of results.

### fetchPreviousPage [‚Äã](#fetchpreviouspage)

`(options?: FetchPreviousPageOptions) => Promise<InfiniteQueryObserverResult<TData, TError>>`

This function allows you to fetch the previous "page" of results.

### hasNextPage [‚Äã](#hasnextpage)

`boolean`

This will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).

### hasPreviousPage [‚Äã](#haspreviouspage)

`boolean`

This will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).

### isFetchingNextPage [‚Äã](#isfetchingnextpage)

`boolean`

Will be `true` while fetching the next page with `fetchNextPage`.

### isFetchingPreviousPage [‚Äã](#isfetchingpreviouspage)

`boolean`

Will be `true` while fetching the previous page with `fetchPreviousPage`.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<InfiniteReadContractsData, ReadContractsErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.</content>
</page>

<page>
  <title>useSignTypedData | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSignTypedData</url>
  <content>Hook for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

Import [‚Äã](#import)
-------------------

ts

    import { useSignTypedData } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useSignTypedData } from 'wagmi'
    
    
    function App() {
      const { signTypedData } = useSignTypedData()
    
      return (
        <button
          onClick={() =>
            signTypedData({
              types: {
                Person: [
                  { name: 'name', type: 'string' },
                  { name: 'wallet', type: 'address' },
                ],
                Mail: [
                  { name: 'from', type: 'Person' },
                  { name: 'to', type: 'Person' },
                  { name: 'contents', type: 'string' },
                ],
              },
              primaryType: 'Mail',
              message: {
                from: {
                  name: 'Cow',
                  wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
                },
                to: {
                  name: 'Bob',
                  wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
                },
                contents: 'Hello, Bob!',
              },
            })
          }
        >
          Sign message
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSignTypedDataParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useSignTypedData } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useSignTypedData({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`signTypedData`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SignTypedDataErrorType, variables: SignTypedDataVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SignTypedDataVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SignTypedDataData, variables: SignTypedDataVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SignTypedDataData, error: SignTypedDataErrorType, variables: SignTypedDataVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SignTypedDataErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SignTypedDataErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSignTypedDataReturnType } from 'wagmi'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### signTypedData [‚Äã](#mutate)

`(variables: SignTypedDataVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SignTypedDataVariables`
    
    The variables object to pass to the [`signTypedData`](https://wagmi.sh/core/api/actions/signTypedData#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SignTypedDataData, variables: SignTypedDataVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SignTypedDataErrorType, variables: SignTypedDataVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SignTypedDataData | undefined, error: SignTypedDataErrorType | null, variables: SignTypedDataVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### signTypedDataAsync [‚Äã](#mutate-async)

`(variables: SignTypedDataVariables, { onSuccess, onSettled, onError }) => Promise<SignTypedDataData>`

Similar to [`signTypedData`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SignTypedDataData | undefined`

*   [`signTypedData` return type](https://wagmi.sh/core/api/actions/signTypedData#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SignTypedDataErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SignTypedDataErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SignTypedDataVariables | undefined`

*   The variables object passed to [`signTypedData`](#mutate).
*   Defaults to `undefined`.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`types`](https://wagmi.sh/core/api/actions/signTypedData#types) setup correctly, TypeScript will infer the correct types for [`domain`](https://wagmi.sh/core/api/actions/signTypedData#domain), [`message`](https://wagmi.sh/core/api/actions/signTypedData#message), and [`primaryType`](https://wagmi.sh/core/api/actions/signTypedData#primarytype). See the Wagmi [TypeScript docs](https://wagmi.sh/react/typescript) for more information.

InlineConst-Asserted

ts

    const {  } = ()
    
    ({
      : {
        : [
          { : 'name', : 'string' },
          { : 'wallet', : 'address' },
        ],
        : [
          { : 'from', : 'Person' },
          { : 'to', : 'Person' },
          { : 'contents', : 'string' },
        ],
      },
      : 'Mail',
    
    
      : {
    
    
    
    
    
    
    
    
    
    
    
    
        : {
          : 'Cow',
          : '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        : {
          : 'Bob',
          : '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        : 'Hello, Bob!',
      },
    })

ts

    const  = {
      : [
        { : 'name', : 'string' },
        { : 'wallet', : 'address' },
      ],
      : [
        { : 'from', : 'Person' },
        { : 'to', : 'Person' },
        { : 'contents', : 'string' },
      ],
    } as 
    
    const {  } = ()
    
    ({
      ,
      : 'Mail',
    
    
      : {
    
    
    
    
    
    
    
    
    
    
    
    
        : {
          : 'Cow',
          : '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        : {
          : 'Bob',
          : '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        : 'Hello, Bob!',
      },
    })

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SignTypedDataData,
      type SignTypedDataVariables,
      type SignTypedDataMutate,
      type SignTypedDataMutateAsync,
      signTypedDataMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`signTypedData`](https://wagmi.sh/core/api/actions/signTypedData)</content>
</page>

<page>
  <title>useStorageAt | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useStorageAt</url>
  <content>Hook for for returning the value from a storage slot at a given address.

Import [‚Äã](#import)
-------------------

ts

    import { useStorageAt } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    
    function App() {
      const result = useStorageAt({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseStorageAtParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

The contract address.

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    
    function App() {
      const result = useStorageAt({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### slot [‚Äã](#slot)

`Hex | undefined`

The storage position (as a hex encoded value).

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    
    function App() {
      const result = useStorageAt({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

blockNumber [‚Äã](#blocknumber)
-----------------------------

`bigint | undefined`

The block number to check the storage at.

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    
    function App() {
      const result = useStorageAt({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        blockNumber: 16280770n,
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the storage at.

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    
    function App() {
      const result = useStorageAt({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        blockTag: 'safe',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The chain ID to check the storage at.

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    import { mainnet } from '@wagmi/core/chains'
    
    function App() {
      const result = useStorageAt({
        chainId: mainnet.id,
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useStorageAt({
        config,
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useStorageAt } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useStorageAt({
        scopeKey: 'foo'
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        slot: '0x0',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetStorageAtData | (() => GetStorageAtData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetStorageAtData | ((previousValue: GetStorageAtData | undefined; previousQuery: Query | undefined) => GetStorageAtData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetStorageAtData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetStorageAtErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetStorageAtErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetStorageAtData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetStorageAtData | undefined, newData: GetStorageAtData) => GetStorageAtData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseStorageAtReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetStorageAtData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetStorageAtErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetStorageAtErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetStorageAtData, GetStorageAtErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetStorageAtData,
      type GetStorageAtOptions,
      type GetStorageAtQueryFnData,
      type GetStorageAtQueryKey,
      getStorageAtQueryKey,
      getStorageAtQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getStorageAt`](https://wagmi.sh/core/api/actions/getStorageAt)</content>
</page>

<page>
  <title>useSwitchChain | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSwitchChain</url>
  <content>Hook for switching the target chain for a connector or the Wagmi [`Config`](https://wagmi.sh/react/api/createConfig#config).

Import [‚Äã](#import)
-------------------

ts

    import { useSwitchChain } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useSwitchChain } from 'wagmi'
    
    function App() {
      const { chains, switchChain } = useSwitchChain()
    
      return (
        <div>
          {chains.map((chain) => (
            <button key={chain.id} onClick={() => switchChain({ chainId: chain.id })}>
              {chain.name}
            </button>
          ))}
        </div>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

TIP

When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](https://wagmi.sh/react/api/createConfig#config).

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSwitchChainParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useSwitchChain } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useSwitchChain({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`switchChain`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SwitchChainErrorType, variables: SwitchChainVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SwitchChainVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SwitchChainData, variables: SwitchChainVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SwitchChainData, error: SwitchChainErrorType, variables: SwitchChainVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SwitchChainErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SwitchChainErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSwitchChainReturnType } from 'wagmi'

### chains [‚Äã](#chains)

`readonly [Chain, ...Chain[]]`

Globally configured chains. Useful for rendering a list of available chains to switch to.

index.tsxconfig.ts

tsx

    import { useSwitchChain } from 'wagmi'
    
    function App() {
      const { chains, switchChain } = useSwitchChain()
    
      return (
        <div>
          {chains.map((chain) => (
            <button key={chain.id} onClick={() => switchChain({ chainId: chain.id })}>
              {chain.name}
            </button>
          ))}
        </div>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### switchChain [‚Äã](#mutate)

`(variables: SwitchChainVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SwitchChainVariables`
    
    The variables object to pass to the [`switchChain`](https://wagmi.sh/core/api/actions/switchChain#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SwitchChainData, variables: SwitchChainVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SwitchChainErrorType, variables: SwitchChainVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SwitchChainData | undefined, error: SwitchChainErrorType | null, variables: SwitchChainVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### switchChainAsync [‚Äã](#mutate-async)

`(variables: SwitchChainVariables, { onSuccess, onSettled, onError }) => Promise<SwitchChainData>`

Similar to [`switchChain`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SwitchChainData | undefined`

*   [`switchChain` return type](https://wagmi.sh/core/api/actions/switchChain#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SwitchChainErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SwitchChainErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SwitchChainVariables | undefined`

*   The variables object passed to [`switchChain`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SwitchChainData,
      type SwitchChainVariables,
      type SwitchChainMutate,
      type SwitchChainMutateAsync,
      switchChainMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`switchChain`](https://wagmi.sh/core/api/actions/switchChain)</content>
</page>

<page>
  <title>useSwitchAccount | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSwitchAccount</url>
  <content>Hook for switching the current account.

Import [‚Äã](#import)
-------------------

ts

    import { useSwitchAccount } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useSwitchAccount } from 'wagmi'
    
    function App() {
      const { connectors, switchAccount } = useSwitchAccount()
    
      return (
        <div>
          {connectors.map((connector) => (
            <button key={connector.id} onClick={() => switchAccount({ connector })}>
              {connector.name}
            </button>
          ))}
        </div>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSwitchAccountParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useSwitchAccount } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useSwitchAccount({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`switchAccount`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SwitchAccountErrorType, variables: SwitchAccountVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SwitchAccountVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SwitchAccountData, variables: SwitchAccountVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SwitchAccountData, error: SwitchAccountErrorType, variables: SwitchAccountVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SwitchAccountErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SwitchAccountErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSwitchAccountReturnType } from 'wagmi'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Globally configured and actively connected connectors. Useful for rendering a list of available connectors to switch to.

index.tsxconfig.ts

tsx

    import { useSwitchAccount } from 'wagmi'
    
    function App() {
      const { connectors, switchAccount } = useSwitchAccount()
    
      return (
        <div>
          {connectors.map((connector) => (
            <button key={connector.id} onClick={() => switchAccount({ connector })}>
              {connector.name}
            </button>
          ))}
        </div>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### switchAccount [‚Äã](#mutate)

`(variables: SwitchAccountVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SwitchAccountVariables`
    
    The variables object to pass to the [`switchAccount`](https://wagmi.sh/core/api/actions/switchAccount#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SwitchAccountData, variables: SwitchAccountVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SwitchAccountErrorType, variables: SwitchAccountVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SwitchAccountData | undefined, error: SwitchAccountErrorType | null, variables: SwitchAccountVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### switchAccountAsync [‚Äã](#mutate-async)

`(variables: SwitchAccountVariables, { onSuccess, onSettled, onError }) => Promise<SwitchAccountData>`

Similar to [`switchAccount`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SwitchAccountData | undefined`

*   [`switchAccount` return type](https://wagmi.sh/core/api/actions/switchAccount#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SwitchAccountErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SwitchAccountErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SwitchAccountVariables | undefined`

*   The variables object passed to [`switchAccount`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SwitchAccountData,
      type SwitchAccountVariables,
      type SwitchAccountMutate,
      type SwitchAccountMutateAsync,
      switchAccountMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`switchAccount`](https://wagmi.sh/core/api/actions/switchAccount)</content>
</page>

<page>
  <title>useTransaction | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useTransaction</url>
  <content>Hook for fetching transactions given hashes or block identifiers.

Import [‚Äã](#import)
-------------------

ts

    import { useTransaction } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useTransaction } from 'wagmi'
    
    function App() {
      const result = useTransaction({
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTransactionParameters } from 'wagmi'

* * *

### blockHash [‚Äã](#blockhash)

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

ts

    import { useTransaction } from 'wagmi'
    
    function App() {
      const result = useTransaction({
        blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
        index: 0,
      })
    }

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

ts

    import { useTransaction } from 'wagmi'
    
    function App() {
      const result = useTransaction({
        blockNumber: 17829139n, 
        index: 0,
      })
    }

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

ts

    import { useTransaction } from 'wagmi'
    
    function App() {
      const result = useTransaction({
        blockTag: 'safe', 
        index: 0,
      })
    }

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

ts

    import { useTransaction } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useTransaction({
        chainId: mainnet.id, 
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      })
    }

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useTransaction } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useTransaction({
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

Hash to get transaction. [`enabled`](#enabled) set to `false` if `hash` and [`index`](#index) are `undefined`.

ts

    import { useTransaction } from 'wagmi'
    
    function App() {
      const result = useTransaction({
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', 
      })
    }

### index [‚Äã](#index)

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)). [`enabled`](#enabled) set to `false` if `index` and [`hash`](#hash) are `undefined`.

ts

    import { useTransaction } from 'wagmi'
    
    function App() {
      const result = useTransaction({
        blockTag: 'safe',
        index: 0
      })
    }

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetTransactionData | (() => GetTransactionData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetTransactionData | ((previousValue: GetTransactionData | undefined; previousQuery: Query | undefined) => GetTransactionData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetTransactionData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTransactionErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTransactionErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetTransactionData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetTransactionData | undefined, newData: GetTransactionData) => GetTransactionData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTransactionReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetTransactionData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTransactionErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTransactionErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetTransactionData, GetTransactionErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionData,
      type GetTransactionOptions,
      type GetTransactionQueryFnData,
      type GetTransactionQueryKey,
      getTransactionQueryKey,
      getTransactionQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getTransaction`](https://wagmi.sh/core/api/actions/getTransaction)</content>
</page>

<page>
  <title>useTransactionConfirmations | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useTransactionConfirmations</url>
  <content>Hook for fetching the number of blocks passed (confirmations) since the transaction was processed on a block. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

Import [‚Äã](#import)
-------------------

ts

    import { useTransactionConfirmations } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useTransactionConfirmations } from 'wagmi'
    
    function App() {
      const result = useTransactionConfirmations({
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTransactionConfirmationsParameters } from 'wagmi'

* * *

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

The hash of the transaction.

ts

    import { useTransactionConfirmations } from 'wagmi'
    
    function App() {
      const result = useTransactionConfirmations({
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', 
      })
    }

### transactionReceipt [‚Äã](#transactionreceipt)

`TransactionReceipt | undefined`

The transaction receipt.

ts

    import { useTransactionConfirmations } from 'wagmi'
    
    function App() {
      const result = useTransactionConfirmations({
        transactionReceipt: { ... }, 
      })
    }

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

ts

    import { useTransactionConfirmations } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useTransactionConfirmations({
        chainId: mainnet.id, 
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      })
    }

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useTransactionConfirmations } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useTransactionConfirmations({
        config,
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useBlock } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useTransactionConfirmations({
        scopeKey: 'foo'
        hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetTransactionConfirmationsData | (() => GetTransactionConfirmationsData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetTransactionConfirmationsData | ((previousValue: GetTransactionConfirmationsData | undefined; previousQuery: Query | undefined) => GetTransactionConfirmationsData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetTransactionConfirmationsData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTransactionConfirmationsErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTransactionConfirmationsErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetTransactionConfirmationsData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetTransactionConfirmationsData | undefined, newData: GetTransactionConfirmationsData) => GetTransactionConfirmationsData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTransactionConfirmationsReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetTransactionConfirmationsData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTransactionConfirmationsErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTransactionConfirmationsErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetTransactionConfirmationsData, GetTransactionConfirmationsErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionConfirmationsData,
      type GetTransactionConfirmationsOptions,
      type GetTransactionConfirmationsQueryFnData,
      type GetTransactionConfirmationsQueryKey,
      getTransactionConfirmationsQueryKey,
      getTransactionConfirmationsQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getTransactionConfirmations`](https://wagmi.sh/core/api/actions/getTransactionConfirmations)</content>
</page>

<page>
  <title>useTransactionReceipt | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useTransactionReceipt</url>
  <content>Hook for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

Import [‚Äã](#import)
-------------------

ts

    import { useTransactionReceipt } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTransactionReceiptParameters } from 'wagmi'

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

A transaction hash.

index.tsxconfig.ts

tsx

    import { useTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

index.tsxconfig.ts

tsx

    import { useTransactionReceipt } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    
    function App() {
      const result = useTransactionReceipt({
        chainId: mainnet.id,
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useTransactionReceipt } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useTransactionReceipt({
        config,
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useTransactionReceipt } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useTransactionReceipt({
        scopeKey: 'foo'
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetTransactionReceiptData | (() => GetTransactionReceiptData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetTransactionReceiptData | ((previousValue: GetTransactionReceiptData | undefined; previousQuery: Query | undefined) => GetTransactionReceiptData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetTransactionReceiptData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTransactionReceiptErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTransactionReceiptErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetTransactionReceiptData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetTransactionReceiptData | undefined, newData: GetTransactionReceiptData) => GetTransactionReceiptData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTransactionReceiptReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetTransactionReceiptData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTransactionReceiptErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTransactionReceiptErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetTransactionReceiptData, GetTransactionReceiptErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionReceiptData,
      type GetTransactionReceiptOptions,
      type GetTransactionReceiptQueryFnData,
      type GetTransactionReceiptQueryKey,
      getTransactionReceiptQueryKey,
      getTransactionReceiptQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getTransactionReceipt`](https://wagmi.sh/core/api/actions/getTransactionReceipt)</content>
</page>

<page>
  <title>useTransactionCount | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useTransactionCount</url>
  <content>Hook for fetching the number of transactions an Account has sent.

Import [‚Äã](#import)
-------------------

ts

    import { useTransactionCount } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useTransactionCount } from 'wagmi'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTransactionCountParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

Address to get the transaction count for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

index.tsxconfig.ts

tsx

    import { useTransactionCount } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get the transaction count at.

index.tsconfig.ts

ts

    import { useTransactionCount } from 'wagmi'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        blockNumber: 17829139n, 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the transaction count at.

index.tsconfig.ts

ts

    import { useTransactionCount } from 'wagmi'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        blockTag: 'latest', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useTransactionCount } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useTransactionCount } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useTransactionCount } from 'wagmi'
    
    function App() {
      const result = useTransactionCount({
        address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`number | (() => number) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`number | ((previousValue: number | undefined; previousQuery: Query | undefined) => number) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: number | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTransactionCountErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTransactionCountErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: number) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: number | undefined, newData: number) => number)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTransactionCountReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`number`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTransactionCountErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTransactionCountErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<number, GetTransactionCountErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionCountData,
      type GetTransactionCountOptions,
      type GetTransactionCountQueryFnData,
      type GetTransactionCountQueryKey,
      getTransactionCountQueryKey,
      getTransactionCountQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getTransactionCount`](https://wagmi.sh/core/api/actions/getTransactionCount)</content>
</page>

<page>
  <title>useSimulateContract | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSimulateContract</url>
  <content>Hook for simulating/validating a contract interaction.

Import [‚Äã](#import)
-------------------

ts

    import { useSimulateContract } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSimulateContractParameters } from 'wagmi'

### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        accessList: [{
          address: '0x1',
          storageKeys: ['0x1'],
        }],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Account | undefined`

Account to use when calling the contract (`msg.sender`). Throws if account is not found on [`connector`](#connector).

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        account: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to call contract at.

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        blockNumber: 17829139n,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        blockTag: 'safe',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        chainId: mainnet.id,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        config,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/react/api/connectors) to simulate transaction with.

index.tsabi.tsconfig.ts

tsx

    import { useConnectorClient, useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const { data: connector } = useConnectorClient()
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        connector,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### dataSuffix [‚Äã](#datasuffix)

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        dataSuffix: '0xdeadbeef',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsxabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        gas: parseGwei('20'),
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        gasPrice: parseGwei('20'),
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        maxFeePerGas: parseGwei('20'),
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        maxFeePerGas: parseGwei('20'),
        maxPriorityFeePerGas: parseGwei('2'),
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        nonce: 123,
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        type: 'eip1559',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { parseEther } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        value: parseEther('0.01'),
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsabi.tsconfig.ts

tsx

    import { useSimulateContract } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      const result = useSimulateContract({
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
        scopeKey: 'foo',
      })
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`SimulateContractReturnType | (() => SimulateContractReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`SimulateContractReturnType | ((previousValue: SimulateContractReturnType | undefined; previousQuery: Query | undefined) => SimulateContractReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: SimulateContractReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SimulateContractErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SimulateContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: SimulateContractReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: SimulateContractReturnType | undefined, newData: SimulateContractReturnType) => SimulateContractReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSimulateContractReturnType } from 'wagmi'

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for more info.

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`SimulateContractReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | SimulateContractErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | SimulateContractErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<SimulateContractReturnType, SimulateContractErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](https://wagmi.sh/react/typescript) for more information.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SimulateContractData,
      type SimulateContractOptions,
      type SimulateContractQueryFnData,
      type SimulateContractQueryKey,
      simulateContractQueryKey,
      simulateContractQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`simulateContract`](https://wagmi.sh/core/api/actions/simulateContract)</content>
</page>

<page>
  <title>useToken | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useToken</url>
  <content>useToken [deprecated](https://wagmi.sh/react/guides/migrate-from-v1-to-v2#deprecated-usetoken) [‚Äã](#usetoken-deprecated)
------------------------------------------------------------------------------------------------------------------------

Hook for fetching token info.

Import [‚Äã](#import)
-------------------

ts

    import { useToken } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useToken } from 'wagmi'
    
    function App() {
      const result = useToken({
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTokenParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

Address to get token for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

index.tsxconfig.ts

tsx

    import { useToken } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useToken({
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useToken } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useToken({
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
        chainId: mainnet.id,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useToken } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useToken({
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### formatUnits [‚Äã](#formatunits)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.tsconfig.ts

ts

    import { useToken } from 'wagmi'
    
    function App() {
      const result = useToken({
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
        formatUnits: 'ether', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsconfig.ts

ts

    import { useToken } from 'wagmi'
    
    function App() {
      const result = useToken({
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
        scopeKey: 'foo', 
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`{ address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; } | (() => { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`{ address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; } | ((previousValue: { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; } | undefined; previousQuery: Query | undefined) => { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; } | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTokenErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTokenErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; } | undefined, newData: { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }) => { address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; })) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTokenReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`{ address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTokenErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTokenErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<{ address: Address; decimals: number; name: string | undefined; symbol: string | undefined; totalSupply: { formatted: string; value: bigint; }; }, GetTokenErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTokenData,
      type GetTokenOptions,
      type GetTokenQueryFnData,
      type GetTokenQueryKey,
      getTokenQueryKey,
      getTokenQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getToken`](https://wagmi.sh/core/api/actions/getToken)</content>
</page>

<page>
  <title>useWaitForTransactionReceipt | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt</url>
  <content>Hook that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

Import [‚Äã](#import)
-------------------

ts

    import { useWaitForTransactionReceipt } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWaitForTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWaitForTransactionReceiptParameters } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        chainId: mainnet.id, 
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useWaitForTransactionReceipt } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### confirmations [‚Äã](#confirmations)

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        confirmations: 2, 
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      })
    }

### onReplaced [‚Äã](#onreplaced)

`(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined`

Optional callback to emit if the transaction has been replaced.

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
        onReplaced: replacement => console.log(replacement), 
      })
    }

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/react/api/createConfig#pollinginterval).

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
        pollingInterval: 1_000, 
      })
    }

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

The transaction hash to wait for. [`enabled`](#enabled) set to `false` if `hash` is `undefined`.

ts

    import { useWaitForTransactionReceipt } from 'wagmi'
    
    function App() {
      const result = useWaitForTransactionReceipt({
        hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
      })
    }

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`WaitForTransactionReceiptData | (() => WaitForTransactionReceiptData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`WaitForTransactionReceiptData | ((previousValue: WaitForTransactionReceiptData | undefined; previousQuery: Query | undefined) => WaitForTransactionReceiptData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: WaitForTransactionReceiptData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: WaitForTransactionReceiptErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: WaitForTransactionReceiptErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: WaitForTransactionReceiptData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: WaitForTransactionReceiptData | undefined, newData: WaitForTransactionReceiptData) => WaitForTransactionReceiptData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWaitForTransactionReceiptReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`WaitForTransactionReceiptData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | WaitForTransactionReceiptErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | WaitForTransactionReceiptErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<WaitForTransactionReceiptData, WaitForTransactionReceiptErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WaitForTransactionReceiptData,
      type WaitForTransactionReceiptOptions,
      type WaitForTransactionReceiptQueryFnData,
      type WaitForTransactionReceiptQueryKey,
      waitForTransactionReceiptQueryKey,
      waitForTransactionReceiptQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`waitForTransactionReceipt`](https://wagmi.sh/core/api/actions/waitForTransactionReceipt)</content>
</page>

<page>
  <title>useWatchAsset | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWatchAsset</url>
  <content>Hook for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchAsset } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWatchAsset } from 'wagmi'
    
    function App() {
      const { watchAsset } = useWatchAsset()
    
      return (
        <button
          onClick={() => watchAsset({
            type: 'ERC20',
            options: {
              address: '0x0000000000000000000000000000000000000000',
              symbol: 'WAGMI',
              decimals: 18,
            },
          })}
        >
          Watch asset
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchAssetParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useWatchAsset } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useWatchAsset({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`watchAsset`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: WatchAssetErrorType, variables: WatchAssetVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: WatchAssetVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: WatchAssetData, variables: WatchAssetVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: WatchAssetData, error: WatchAssetErrorType, variables: WatchAssetVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: WatchAssetErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: WatchAssetErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchAssetReturnType } from 'wagmi'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### watchAsset [‚Äã](#mutate)

`(variables: WatchAssetVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `WatchAssetVariables`
    
    The variables object to pass to the [`watchAsset`](https://wagmi.sh/core/api/actions/watchAsset#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: WatchAssetData, variables: WatchAssetVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: WatchAssetErrorType, variables: WatchAssetVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: WatchAssetData | undefined, error: WatchAssetErrorType | null, variables: WatchAssetVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### watchAssetAsync [‚Äã](#mutate-async)

`(variables: WatchAssetVariables, { onSuccess, onSettled, onError }) => Promise<WatchAssetData>`

Similar to [`watchAsset`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`WatchAssetData | undefined`

*   [`watchAsset` return type](https://wagmi.sh/core/api/actions/watchAsset#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`WatchAssetErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`WatchAssetErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`WatchAssetVariables | undefined`

*   The variables object passed to [`watchAsset`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WatchAssetData,
      type WatchAssetVariables,
      type WatchAssetMutate,
      type WatchAssetMutateAsync,
      watchAssetMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`watchAsset`](https://wagmi.sh/core/api/actions/watchAsset)</content>
</page>

<page>
  <title>useWalletClient | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWalletClient</url>
  <content>Hook for getting a Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

Import [‚Äã](#import)
-------------------

ts

    import { useWalletClient } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWalletClient } from 'wagmi'
    
    function App() {
      const result = useWalletClient()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWalletClientParameters } from 'wagmi'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

ts

    import { useWalletClient } from 'wagmi'
    
    function App() {
      const result = useWalletClient({
        account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      })
    }

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

ts

    import { useWalletClient } from 'wagmi'
    
    function App() {
      const result = useWalletClient({
        chainId: mainnet.id, 
      })
    }

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useWalletClient } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useWalletClient({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to get client for.
*   Defaults to current connector.

ts

    import { useConnections, useWalletClient } from 'wagmi'
    
    function App() {
      const connections = useConnections(config)
      const result = useWalletClient({
        connector: connections[0]?.connector, 
      })
    }

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### initialData [‚Äã](#initialdata)

`WalletClient | (() => WalletClient) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`WalletClient | ((previousValue: WalletClient | undefined; previousQuery: Query | undefined) => WalletClient) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: WalletClient | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetWalletClientErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetWalletClientErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: WalletClient) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: WalletClient | undefined, newData: WalletClient) => WalletClient)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWalletClientReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`WalletClient`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetWalletClientErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetWalletClientErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<WalletClient, GetWalletClientErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetWalletClientData,
      type GetWalletClientOptions,
      type GetWalletClientQueryFnData,
      type GetWalletClientQueryKey,
      getWalletClientQueryKey,
      getWalletClientQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`getWalletClient`](https://wagmi.sh/core/api/actions/getWalletClient)</content>
</page>

<page>
  <title>useVerifyMessage | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useVerifyMessage</url>
  <content>Hook for verify that a message was signed by the provided address. It supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account.

Import [‚Äã](#import)
-------------------

ts

    import { useVerifyMessage } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    
    function App() {
      const result = useVerifyMessage({
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseVerifyMessageParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

The Ethereum address that signed the original message.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    
    function App() {
      const result = useVerifyMessage({
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### message [‚Äã](#message)

`string | { raw: Hex | ByteArray } | undefined`

The message to be verified.

By default, wagmi verifies the UTF-8 representation of the message.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    
    function App() {
      const result = useVerifyMessage({
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

TIP

By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

ts

    import { useVerifyMessage } from 'wagmi'
    
    function App() {
      const result = useVerifyMessage({
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: { raw: '0x68656c6c6f20776f726c64' } 
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

### signature [‚Äã](#signature)

`Hex | ByteArray | undefined`

The signature that was generated by signing the message with the address's signer.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    
    function App() {
      const result = useVerifyMessage({
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useVerifyMessage({
        chainId: mainnet.id,
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useVerifyMessage({
        blockNumber: 12345678n,
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useVerifyMessage({
        blockTag: 'pending',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useVerifyMessage({
        config,
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useVerifyMessage } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useVerifyMessage({
        scopeKey: 'foo'
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        message: 'hello world',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`VerifyMessageData | (() => VerifyMessageData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`VerifyMessageData | ((previousValue: VerifyMessageData | undefined; previousQuery: Query | undefined) => VerifyMessageData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: VerifyMessageData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: VerifyMessageErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: VerifyMessageErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: VerifyMessageData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: VerifyMessageData | undefined, newData: VerifyMessageData) => VerifyMessageData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseVerifyMessageReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`VerifyMessageData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | VerifyMessageErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | VerifyMessageErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<VerifyMessageData, VerifyMessageErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type VerifyMessageData,
      type VerifyMessageOptions,
      type VerifyMessageQueryFnData,
      type VerifyMessageQueryKey,
      verifyMessageQueryKey,
      verifyMessageQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`verifyMessage`](https://wagmi.sh/core/api/actions/verifyMessage)</content>
</page>

<page>
  <title>useWatchBlockNumber | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWatchBlockNumber</url>
  <content>Hook that watches for block number changes.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchBlockNumber } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        onBlockNumber(blockNumber) {
          console.log('Block number changed!', blockNumber)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchBlockNumberParameters } from 'wagmi'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        chainId: 1, 
        onBlockNumber(blockNumber) {
          console.log('New block number', blockNumber)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    import { config } from './config'
    
    function App() {
      useWatchBlockNumber({
        config, 
        onBlockNumber(blockNumber) {
          console.log('New block number', blockNumber)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitMissed [‚Äã](#emitmissed)

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        emitMissed: true, 
        onBlockNumber(blockNumber) {
          console.log('New block number', blockNumber)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitOnBegin [‚Äã](#emitonbegin)

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        emitOnBegin: true, 
        onBlockNumber(blockNumber) {
          console.log('New block number', blockNumber)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### enabled [‚Äã](#enabled)

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        enabled: false, 
        onBlockNumber(blockNumber) {
          console.log('New block number', blockNumber)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onBlockNumber [‚Äã](#onblocknumber)

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        onBlockNumber(blockNumber) { 
          console.log('New block number', blockNumber) 
        }, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        onBlockNumber(blockNumber) { 
          console.log('New block number', blockNumber) 
        }, 
        onError(error) { 
          console.error('Block error', error) 
        }, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        onBlockNumber(blockNumber) { 
          console.log('New block number', blockNumber) 
        }
        poll: true, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        onBlockNumber(blockNumber) { 
          console.log('New block number', blockNumber) 
        }
        pollingInterval: 1_000, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsconfig.ts

ts

    import { useWatchBlockNumber } from 'wagmi'
    
    function App() {
      useWatchBlockNumber({
        onBlockNumber(blockNumber) { 
          console.log('New block number', blockNumber) 
        }
        syncConnectedChain: false, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchBlockNumberReturnType } from 'wagmi'

Function for cleaning up watcher.

Action [‚Äã](#action)
-------------------

*   [`watchBlockNumber`](https://wagmi.sh/core/api/actions/watchBlockNumber)</content>
</page>

<page>
  <title>useWatchBlocks | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWatchBlocks</url>
  <content>Hook that watches for block changes.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchBlocks } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchBlocksParameters } from 'wagmi'

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to watch blocks at.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        blockTag: 'latest', 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        chainId: 1, 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    import { config } from './config'
    
    function App() {
      useWatchBlocks({
        config, 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitMissed [‚Äã](#emitmissed)

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        emitMissed: true, 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitOnBegin [‚Äã](#emitonbegin)

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        emitOnBegin: true, 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### enabled [‚Äã](#enabled)

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        enabled: false, 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### includeTransactions [‚Äã](#includetransactions)

`boolean`

Whether or not to unwrap transactions as objects (instead of hashes) in blocks. Defaults to `false`.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        includeTransactions: true, 
        onBlock(block) {
          console.log('New block', block.number)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onBlock [‚Äã](#onblock)

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        onBlock(block) { 
          console.log('New block', block.number) 
        }, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        onBlock(block) { 
          console.log('New block', block.number) 
        }, 
        onError(error) { 
          console.error('Block error', error) 
        }, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        onBlock(block) { 
          console.log('New block', block.number) 
        }
        poll: true, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        onBlock(block) { 
          console.log('New block', block.number) 
        }
        pollingInterval: 1_000, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsconfig.ts

ts

    import { useWatchBlocks } from 'wagmi'
    
    function App() {
      useWatchBlocks({
        onBlock(block) { 
          console.log('New block', block.number) 
        }
        syncConnectedChain: false, 
      })
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchBlocksReturnType } from 'wagmi'

Action [‚Äã](#action)
-------------------

*   [`watchBlocks`](https://wagmi.sh/core/api/actions/watchBlocks)</content>
</page>

<page>
  <title>useWriteContract | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWriteContract</url>
  <content>Action for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

Import [‚Äã](#import)
-------------------

ts

    import { useWriteContract } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxabi.tsconfig.ts

tsx

    import { useWriteContract } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      const { writeContract } = useWriteContract()
    
      return (
        <button 
          onClick={() => 
            writeContract({ 
              abi,
              address: '0x6b175474e89094c44da98b954eedeac495271d0f',
              functionName: 'transferFrom',
              args: [
                '0xd2135CfB216b74109775236E36d4b433F1DF507B',
                '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
                123n,
              ],
           })
          }
        >
          Transfer
        </button>
      )
    }

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWriteContractParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useWriteContract } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useWriteContract({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`writeContract`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: WriteContractErrorType, variables: WriteContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: WriteContractVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: WriteContractReturnType, variables: WriteContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: WriteContractReturnType, error: WriteContractErrorType, variables: WriteContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: WriteContractErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: WriteContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWriteContractReturnType } from 'wagmi'

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for more info.

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### writeContract [‚Äã](#mutate)

`(variables: WriteContractVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `WriteContractVariables`
    
    The variables object to pass to the [`writeContract`](https://wagmi.sh/core/api/actions/writeContract#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: WriteContractReturnType, variables: WriteContractVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: WriteContractErrorType, variables: WriteContractVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: WriteContractReturnType | undefined, error: WriteContractErrorType | null, variables: WriteContractVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### writeContractAsync [‚Äã](#mutate-async)

`(variables: WriteContractVariables, { onSuccess, onSettled, onError }) => Promise<WriteContractReturnType>`

Similar to [`writeContract`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`WriteContractReturnType | undefined`

*   [`writeContract` return type](https://wagmi.sh/core/api/actions/writeContract#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`WriteContractErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`WriteContractErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`WriteContractVariables | undefined`

*   The variables object passed to [`writeContract`](#mutate).
*   Defaults to `undefined`.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](https://wagmi.sh/core/api/actions/writeContract#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](https://wagmi.sh/core/api/actions/writeContract#functionname), [`args`](https://wagmi.sh/core/api/actions/writeContract#args), and the [`value`](https://wagmi.sh/core/api/actions/writeContract##value). See the Wagmi [TypeScript docs](https://wagmi.sh/react/typescript) for more information.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WriteContractData,
      type WriteContractVariables,
      type WriteContractMutate,
      type WriteContractMutateAsync,
      writeContractMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`writeContract`](https://wagmi.sh/core/api/actions/writeContract)</content>
</page>

<page>
  <title>cookieToInitialState | Wagmi</title>
  <url>https://wagmi.sh/react/api/utilities/cookieToInitialState</url>
  <content>Helper to convert a cookie string into [initial state](https://wagmi.sh/react/api/WagmiProvider#initialstate).

Import [‚Äã](#import)
-------------------

ts

    import { cookieToInitialState } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

server.tsconfig.ts

ts

    import { cookieToInitialState } from 'wagmi'
    import config from './config'
    
    function handler(req: Request) {
      const initialState = cookieToInitialState(config, req.headers.cookie)
      // ...
    }

ts

    import { 
      createConfig, 
      http, 
      cookieStorage,
      createStorage
    } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true,
      storage: createStorage({ 
        storage: cookieStorage,
      }), 
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

### config [‚Äã](#config)

`Config`

Wagmi Config

### cookie [‚Äã](#cookie)

`string | null | undefined`

The cookie string.

Return Type [‚Äã](#return-type)
-----------------------------

`State`

Initial state.</content>
</page>

<page>
  <title>Actions | Wagmi</title>
  <url>https://wagmi.sh/react/api/actions</url>
  <content>Sometimes the declarative nature of React Hooks doesn't work for parts of your app. For those cases, you can use Wagmi Core Actions directly!

All the Wagmi Core Actions are importable using the `wagmi/actions` entrypoint. For example, you can use the `watchBlockNumber` action to watch for block number changes.

index.tsxconfig.ts

ts

    import { useConfig } from 'wagmi'
    import { watchBlockNumber } from 'wagmi/actions'
    import { useEffect } from 'react'
    
    function App() {
      const config = useConfig()
    
      useEffect(() => {
        return watchBlockNumber(config, {
          onBlockNumber(blockNumber) {
            console.log('Block number changed!', blockNumber)
          },
        })
      }, [])
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

See the [Wagmi Core docs](https://wagmi.sh/core/api/actions) for more info on what actions are available.</content>
</page>

<page>
  <title>useWatchPendingTransactions | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWatchPendingTransactions</url>
  <content>Hook that watches and returns pending transaction hashes.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchPendingTransactions } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchPendingTransactionsParameters } from 'wagmi'

### batch [‚Äã](#batch)

`boolean | undefined`

*   Whether or not the transactions should be batched on each invocation.
*   Defaults to `true`.

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        batch: true
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        chainId: 1
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    import { config } from './config'
    
    function App() {
      useWatchPendingTransactions({
        config
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from watching pending transactions.

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        onError(error) {
          console.log('Error', error)
        },
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onTransactions [‚Äã](#ontransactions)

`(transactions: Hash[], prevTransactions: Hash[] | undefined) => void`

Callback when new incoming pending transactions are detected.

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
        poll: true,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
        pollingInterval: 1_000,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsxconfig.ts

tsx

    import { useWatchPendingTransactions } from 'wagmi'
    
    function App() {
      useWatchPendingTransactions({
        onTransactions(transactions) {
          console.log('New transactions!', transactions)
        },
        syncConnectedChain: false,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchPendingTransactionsReturnType } from 'wagmi'

Action [‚Äã](#action)
-------------------

*   [`watchPendingTransactions`](https://wagmi.sh/core/api/actions/watchPendingTransactions)</content>
</page>

<page>
  <title>Errors | Wagmi</title>
  <url>https://wagmi.sh/react/api/errors</url>
  <content>Error classes used by Wagmi.

BaseError [‚Äã](#baseerror)
-------------------------

Error class extended by all errors.

ts

    import { BaseError } from 'wagmi'

Config [‚Äã](#config)
-------------------

### ConnectorAccountNotFoundError [‚Äã](#connectoraccountnotfounderror)

When an account does not exist on the connector or is unable to be used.

ts

    import { ConnectorAccountNotFoundError } from 'wagmi'

### ConnectorAlreadyConnectedError [‚Äã](#connectoralreadyconnectederror)

When a connector is already connected.

ts

    import { ConnectorAlreadyConnectedError } from 'wagmi'

### ConnectorChainMismatchError [‚Äã](#connectorchainmismatcherror)

When the Wagmi Config is out-of-sync with the connector's active chain ID. This is rare and likely an upstream wallet issue.

ts

    import { ConnectorChainMismatchError } from 'wagmi'

### ChainNotConfiguredError [‚Äã](#chainnotconfigurederror)

When a chain is not configured. You likely need to add the chain to [`Config['chains']`](https://wagmi.sh/react/api/createConfig#chains).

ts

    import { ChainNotConfiguredError } from 'wagmi'

### ConnectorNotConnectedError [‚Äã](#connectornotconnectederror)

When a connector is not connected.

ts

    import { ConnectorNotConnectedError } from 'wagmi'

### ConnectorNotFoundError [‚Äã](#connectornotfounderror)

When a connector is not found or able to be used.

ts

    import { ConnectorNotFoundError } from 'wagmi'

### ConnectorUnavailableReconnectingError [‚Äã](#connectorunavailablereconnectingerror)

During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.

ts

    import { ConnectorUnavailableReconnectingError } from 'wagmi'

Connector [‚Äã](#connector)
-------------------------

### ProviderNotFoundError [‚Äã](#providernotfounderror)

When a connector's provider is not found or able to be used.

ts

    import { ProviderNotFoundError } from 'wagmi'

### SwitchChainNotSupportedError [‚Äã](#switchchainnotsupportederror)

When switching chains is not supported by connectors.

ts

    import { SwitchChainNotSupportedError } from 'wagmi'

React [‚Äã](#react)
-----------------

### WagmiProviderNotFoundError [‚Äã](#wagmiprovidernotfounderror)

When a Wagmi hook is used outside of a [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

ts

    import { WagmiProviderNotFoundError } from 'wagmi'</content>
</page>

<page>
  <title>useVerifyTypedData | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useVerifyTypedData</url>
  <content>Hook for verify that a typed data was signed by the provided address. It supports verifying typed data that were signed by either a Smart Contract Account or Externally Owned Account.

Import [‚Äã](#import)
-------------------

ts

    import { useVerifyTypedData } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseVerifyTypedDataParameters } from 'wagmi'

### address [‚Äã](#address)

`Address | undefined`

The Ethereum address that signed the original typed data.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### domain [‚Äã](#domain)

`TypedDataDomain | undefined`

The typed data domain.

index.tsxdata.tsconfig.ts

tsx

    import { types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain: {
          name: 'Ether Mail',
          version: '1',
          chainId: 1,
          verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
        },
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### types [‚Äã](#types)

The type definitions for the typed data.

index.tsxdata.tsconfig.ts

tsx

    import { domain } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain,
        types: {
          Person: [
            { name: 'name', type: 'string' },
            { name: 'wallet', type: 'address' },
          ],
          Mail: [
            { name: 'from', type: 'Person' },
            { name: 'to', type: 'Person' },
            { name: 'contents', type: 'string' },
          ],
        },
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### primaryType [‚Äã](#primarytype)

`string | undefined`

The primary `type` to extract from types and use in `value`.

index.tsxdata.tsconfig.ts

tsx

    import { domain } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain,
        types: {
          Person: [
            { name: 'name', type: 'string' },
            { name: 'wallet', type: 'address' },
          ],
          Mail: [
            { name: 'from', type: 'Person' },
            { name: 'to', type: 'Person' },
            { name: 'contents', type: 'string' },
          ],
        },
        primaryType: 'Mail',
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### message [‚Äã](#message)

Type inferred from `types` & `primaryType`.

The message to be verified.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### signature [‚Äã](#signature)

`Hex | ByteArray | undefined`

The signature that was generated by signing the typed data with the address's signer.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    import { mainnet } from 'wagmi/chains'
    
    function App() {
      const result = useVerifyTypedData({
        chainId: mainnet.id,
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        blockNumber: 12345678n,
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        blockTag: 'latest',
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    import { config } from './config'
    
    function App() {
      const result = useVerifyTypedData({
        config,
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxdata.tsconfig.ts

tsx

    import { domain, types } from './data'
    import { useVerifyTypedData } from 'wagmi'
    
    function App() {
      const result = useVerifyTypedData({
        scopeKey: 'foo'
        domain,
        types,
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
          },
          contents: 'Hello, Bob!',
        },
        primaryType: 'Mail',
        address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
        signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
      })
    }

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`VerifyTypedDataData | (() => VerifyTypedDataData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`VerifyTypedDataData | ((previousValue: VerifyTypedDataData | undefined; previousQuery: Query | undefined) => VerifyTypedDataData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: VerifyTypedDataData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: VerifyTypedDataErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: VerifyTypedDataErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: VerifyTypedDataData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: VerifyTypedDataData | undefined, newData: VerifyTypedDataData) => VerifyTypedDataData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseVerifyTypedDataReturnType } from 'wagmi'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`VerifyTypedDataData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | VerifyTypedDataErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | VerifyTypedDataErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<VerifyTypedDataData, VerifyTypedDataErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](https://wagmi.sh/react/typescript) for more information.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type VerifyTypedDataData,
      type VerifyTypedDataOptions,
      type VerifyTypedDataQueryFnData,
      type VerifyTypedDataQueryKey,
      verifyTypedDataQueryKey,
      verifyTypedDataQueryOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`verifyTypedData`](https://wagmi.sh/core/api/actions/verifyTypedData)</content>
</page>

<page>
  <title>deserialize | Wagmi</title>
  <url>https://wagmi.sh/react/api/utilities/deserialize</url>
  <content>Deserialize function that supports `bigint` and `Map`.

Import [‚Äã](#import)
-------------------

ts

    import { deserialize } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { deserialize } from 'wagmi'
    
    const result = deserialize('{"foo":"wagmi","bar":{"__type":"bigint","value":"123"}}')

Parameters [‚Äã](#parameters)
---------------------------

### value [‚Äã](#value)

`string`

The string to deserialize.

### reviver [‚Äã](#reviver)

`(key: string, value: any) => any`

A custom reviver function for handling standard values.

Return Type [‚Äã](#return-type)
-----------------------------

`unknown`

Parsed value.</content>
</page>

<page>
  <title>serialize | Wagmi</title>
  <url>https://wagmi.sh/react/api/utilities/serialize</url>
  <content>Serialize function that supports `bigint` and `Map`.

Import [‚Äã](#import)
-------------------

ts

    import { serialize } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

ts

    import { serialize } from 'wagmi'
    
    const result = serialize({ foo: 'wagmi', bar: 123n })

Parameters [‚Äã](#parameters)
---------------------------

### value [‚Äã](#value)

`any`

The value to stringify.

### replacer [‚Äã](#replacer)

`(key: string, value: any) => any`

A custom replacer function for handling standard values.

### indent [‚Äã](#indent)

`number | null | undefined`

The number of spaces to indent the output by.

### circularReplacer [‚Äã](#circularreplacer)

A custom replacer function for handling circular values.

Return Type [‚Äã](#return-type)
-----------------------------

`string`

Stringified value.</content>
</page>

<page>
  <title>normalizeChainId | Wagmi</title>
  <url>https://wagmi.sh/react/api/utilities/normalizeChainId</url>
  <content>Normalizes a chain ID to a number.

Import [‚Äã](#import)
-------------------

ts

    import { normalizeChainId } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

Deprecated

Use `Number` instead.

ts

    import { normalizeChainId } from 'wagmi'
    const chainId = normalizeChainId(123n)
    const chainId = Number(123n)

ts

    import { normalizeChainId } from 'wagmi'
    
    const result = normalizeChainId('0x1')

Parameters [‚Äã](#parameters)
---------------------------

### chainId [‚Äã](#chainid)

`bigint | number | string`

The chain ID to normalize.

ts

    import { normalizeChainId } from 'wagmi'
    
    normalizeChainId(1n)
    normalizeChainId(1)
    normalizeChainId('0x1')

Return Type [‚Äã](#return-type)
-----------------------------

`number`

The normalized chain ID.</content>
</page>

<page>
  <title>useWatchContractEvent | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWatchContractEvent</url>
  <content>Hook that watches and returns emitted contract event logs.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchContractEvent } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchContractEventParameters } from 'wagmi'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`object | readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`eventName`](#eventname).

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        args: {
          to: '0xd2135CfB216b74109775236E36d4b433F1DF507B'
        }
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### batch [‚Äã](#batch)

`boolean | undefined`

*   Whether or not the events should be batched on each invocation.
*   Defaults to `true`.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        batch: false,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        chainId: 1,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        config,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### eventName [‚Äã](#eventname)

`string`

*   Event to listen for the contract.
*   Inferred from [`abi`](#abi).

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    import { config } from './config'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
        onError(error) {
          console.log('Error', error)
        }
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onLogs [‚Äã](#onlogs)

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        }
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
        poll: true
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
        pollingInterval: 1_000
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### strict [‚Äã](#strict)

`boolean | undefined`

*   Defaults to `false`.

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
        strict: true
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsxabi.tsconfig.ts

tsx

    import { useWatchContractEvent } from 'wagmi'
    import { abi } from './abi'
    
    function App() {
      useWatchContractEvent({
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        abi,
        eventName: 'Transfer',
        onLogs(logs) {
          console.log('New logs!', logs)
        },
        syncConnectedChain: true
      })
    }

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchContractEventReturnType } from 'wagmi'

Hook returns `void`

Action [‚Äã](#action)
-------------------

*   [`watchContractEvent`](https://wagmi.sh/core/api/actions/watchContractEvent)</content>
</page>

<page>
  <title>useShowCallsStatus | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useShowCallsStatus</url>
  <content>Action to request for the wallet to show information about a call batch that was sent via `useShowCalls`.

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_showcallsstatus)

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { useShowCallsStatus } from 'wagmi/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useShowCallsStatus } from 'wagmi/experimental'
    import { parseEther } from 'viem'
    
    function App() {
      const { showCallsStatus } = useShowCallsStatus()
    
      return (
        <button
          onClick={() =>
            showCallsStatus({
              id: '0x1234567890abcdef',
            })
          }
        >
          Show calls status
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseShowCallsStatusParameters } from 'wagmi/experimental'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useShowCallsStatus } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useShowCallsStatus({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`showCallsStatus`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: ShowCallsStatusErrorType, variables: ShowCallsStatusVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: ShowCallsStatusVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: ShowCallsStatusData, variables: ShowCallsStatusVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: ShowCallsStatusData, error: ShowCallsStatusErrorType, variables: ShowCallsStatusVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ShowCallsStatusErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ShowCallsStatusErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseShowCallsStatusReturnType } from 'wagmi/experimental'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### showCallsStatus [‚Äã](#mutate)

`(variables: ShowCallsStatusVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `ShowCallsStatusVariables`
    
    The variables object to pass to the [`showCallsStatus`](https://wagmi.sh/core/api/actions/showCallsStatus#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: ShowCallsStatusData, variables: ShowCallsStatusVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: ShowCallsStatusErrorType, variables: ShowCallsStatusVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: ShowCallsStatusData | undefined, error: ShowCallsStatusErrorType | null, variables: ShowCallsStatusVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### showCallsStatusAsync [‚Äã](#mutate-async)

`(variables: ShowCallsStatusVariables, { onSuccess, onSettled, onError }) => Promise<ShowCallsStatusData>`

Similar to [`showCallsStatus`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`ShowCallsStatusData | undefined`

*   [`showCallsStatus` return type](https://wagmi.sh/core/api/actions/showCallsStatus#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`ShowCallsStatusErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`ShowCallsStatusErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`ShowCallsStatusVariables | undefined`

*   The variables object passed to [`showCallsStatus`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ShowCallsStatusData,
      type ShowCallsStatusVariables,
      type ShowCallsStatusMutate,
      type ShowCallsStatusMutateAsync,
      showCallsStatusMutationOptions,
    } from 'wagmi/experimental/query'

Action [‚Äã](#action)
-------------------

*   [`showCallsStatus`](https://wagmi.sh/core/api/actions/showCallsStatus)</content>
</page>

<page>
  <title>useSendCalls | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useSendCalls</url>
  <content>Hook that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network.

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

WARNING

This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { useSendCalls } from 'wagmi/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useSendCalls } from 'wagmi/experimental'
    import { parseEther } from 'viem'
    
    function App() {
      const { sendCalls } = useSendCalls()
    
      return (
        <button
          onClick={() =>
            sendCalls({
              calls: [
                {
                  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
                  value: parseEther('1')
                },
                {
                  data: '0xdeadbeef',
                  to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
                },
              ]
            })
          }
        >
          Send calls
        </button>
      )
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSendCallsParameters } from 'wagmi/experimental'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useSendCalls } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useSendCalls({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`sendCalls`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SendCallsErrorType, variables: SendCallsVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SendCallsVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SendCallsData, variables: SendCallsVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SendCallsData, error: SendCallsErrorType, variables: SendCallsVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SendCallsErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SendCallsErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSendCallsReturnType } from 'wagmi/experimental'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### sendCalls [‚Äã](#mutate)

`(variables: SendCallsVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SendCallsVariables`
    
    The variables object to pass to the [`sendCalls`](https://wagmi.sh/core/api/actions/sendCalls#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SendCallsData, variables: SendCallsVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SendCallsErrorType, variables: SendCallsVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SendCallsData | undefined, error: SendCallsErrorType | null, variables: SendCallsVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### sendCallsAsync [‚Äã](#mutate-async)

`(variables: SendCallsVariables, { onSuccess, onSettled, onError }) => Promise<SendCallsData>`

Similar to [`sendCalls`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SendCallsData | undefined`

*   [`sendCalls` return type](https://wagmi.sh/core/api/actions/sendCalls#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SendCallsErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SendCallsErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SendCallsVariables | undefined`

*   The variables object passed to [`sendCalls`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SendCallsData,
      type SendCallsVariables,
      type SendCallsMutate,
      type SendCallsMutateAsync,
      sendCallsMutationOptions,
    } from 'wagmi/experimental/query'

Action [‚Äã](#action)
-------------------

*   [`sendCalls`](https://wagmi.sh/core/api/actions/sendCalls)</content>
</page>

<page>
  <title>useCallsStatus | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useCallsStatus</url>
  <content>Hook to fetch the status and receipts of a call batch that was sent via [`useSendCalls`](https://wagmi.sh/react/api/hooks/useSendCalls).

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { useCallsStatus } from 'wagmi/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useCallsStatus } from 'wagmi/experimental'
    
    function App() {
      const result = useCallsStatus({
        id: '0x...',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseCallsStatusParameters } from 'wagmi/experimental'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useCallsStatus } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useCallsStatus({
        config,
        id: '0x...',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get call statuses with.

index.tsxconfig.ts

tsx

    import { useCallsStatus, useConnections } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const connections = useConnections()
      const result = useCallsStatus({
        connector: connections[0]?.connector,
        id: '0x...',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### id [‚Äã](#id)

`string`

Identifier of the call batch.

index.tsconfig.ts

ts

    import { useCallsStatus } from '@wagmi/core'
    import { config } from './config'
    
    const status = await useCallsStatus({
      id: '0x1234567890abcdef', 
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useCallsStatus } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useCallsStatus({
        id: '0x...',
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetCallsStatusReturnType | (() => GetCallsStatusReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetCallsStatusReturnType | ((previousValue: GetCallsStatusReturnType | undefined; previousQuery: Query | undefined) => GetCallsStatusReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetCallsStatusReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetCallsStatusErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetCallsStatusErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetCallsStatusReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetCallsStatusReturnType | undefined, newData: GetCallsStatusReturnType) => GetCallsStatusReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseCallsStatusReturnType } from 'wagmi/experimental'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetCallsStatusReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetCallsStatusErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetCallsStatusErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetCallsStatusReturnType, GetCallsStatusErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetCallsStatusData,
      type GetCallsStatusOptions,
      type GetCallsStatusQueryFnData,
      type GetCallsStatusQueryKey,
      getCallsStatusQueryKey,
      getCallsStatusQueryOptions,
    } from 'wagmi/experimental/query'

Action [‚Äã](#action)
-------------------

*   [`getCallsStatus`](https://viem.sh/experimental/eip5792/getCallsStatus)</content>
</page>

<page>
  <title>useCapabilities | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useCapabilities</url>
  <content>Hook to extract capabilities (grouped by chain ID) that a connected wallet supports (e.g. paymasters, session keys, etc).

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_getcapabilities)

WARNING

This is an experimental Hook that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { useCapabilities } from 'wagmi/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useCapabilities } from 'wagmi/experimental'
    
    function App() {
      const result = useCapabilities()
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseCapabilitiesParameters } from 'wagmi/experimental'

### account [‚Äã](#account)

`Account | Address | undefined`

Fetch capabilities for the provided account.

index.tsconfig.ts

ts

    import { useCapabilities } from '@wagmi/core'
    import { config } from './config'
    
    const status = await useCapabilities({
      account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useCapabilities } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useCapabilities({
        config,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get call statuses with.

index.tsxconfig.ts

tsx

    import { useCapabilities, useConnections } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const connections = useConnections()
      const result = useCapabilities({
        connector: connections[0]?.connector,
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useCapabilities } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useCapabilities({
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetCapabilitiesReturnType | (() => GetCapabilitiesReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetCapabilitiesReturnType | ((previousValue: GetCapabilitiesReturnType | undefined; previousQuery: Query | undefined) => GetCapabilitiesReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetCapabilitiesReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetCapabilitiesErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetCapabilitiesErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetCapabilitiesReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetCapabilitiesReturnType | undefined, newData: GetCapabilitiesReturnType) => GetCapabilitiesReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseCapabilitiesReturnType } from 'wagmi/experimental'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetCapabilitiesReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetCapabilitiesErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetCapabilitiesErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetCapabilitiesReturnType, GetCapabilitiesErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetCapabilitiesData,
      type GetCapabilitiesOptions,
      type GetCapabilitiesQueryFnData,
      type GetCapabilitiesQueryKey,
      getCapabilitiesQueryKey,
      getCapabilitiesQueryOptions,
    } from 'wagmi/experimental/query'

Action [‚Äã](#action)
-------------------

*   [`getCapabilities`](https://viem.sh/experimental/eip5792/getCapabilities)</content>
</page>

<page>
  <title>create-wagmi | Wagmi</title>
  <url>https://wagmi.sh/cli/create-wagmi</url>
  <content>Overview [‚Äã](#overview)
-----------------------

create-wagmi is a command line interface (CLI) for scaffolding new Wagmi projects.

Usage [‚Äã](#usage)
-----------------

pnpmnpmyarnbun

bash

    npm create wagmi@latest

Options [‚Äã](#options)
---------------------

### `-t`, `--template` [‚Äã](#t-template)

You can specify a custom [template](#templates) by passing the `--template`/`-t` flag:

pnpmnpmyarnbun

bash

    pnpm create wagmi --template next

bash

    npm create wagmi@latest --template next

bash

    yarn create wagmi --template next

bash

    bun create wagmi --template next

### `--bun`/`--npm`/`--pnpm`/`--yarn` [‚Äã](#bun-npm-pnpm-yarn)

Use a specific package manager to install dependencies. By default, `create-wagmi` will use the package manager you used to run the command.

### `-h`, `--help` [‚Äã](#h-help)

Prints the help message.

### `-v`, `--version` [‚Äã](#v-version)

Prints the CLI version.

Templates [‚Äã](#templates)
-------------------------

`create-wagmi` currently comes with the following templates:

*   `next`: A Next.js Wagmi project.
*   `nuxt`: A Nuxt Wagmi project.
*   `vite-react`: A Vite (React) Wagmi project.
*   `vite-vanilla`: A Vite Wagmi Core project.
*   `vite-vue`: A Vite (Vue) Wagmi project.

If you do not specify the template on the command line, you will be prompted to select a framework and variant.

*   **React** : A React project.
    *   **Vite** : A React + Vite Wagmi project (`vite-react`).
    *   **Next** : A React + Next Wagmi project (`next`).
*   **Vue**: A Vue project.
    *   **Vite**: A Vue + Vite Wagmi project (`vite-vue`).
    *   **Nuxt**: A Vue + Nuxt Wagmi project (`nuxt`).
*   **Vanilla**: A Vite Wagmi project without React (`vite-vanilla`).</content>
</page>

<page>
  <title>TypeScript | Wagmi</title>
  <url>https://wagmi.sh/core/typescript</url>
  <content>Requirements [‚Äã](#requirements)
-------------------------------

Wagmi Core is designed to be as type-safe as possible! Things to keep in mind:

*   Types currently require using TypeScript >=5.0.4.
*   [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
*   Changes to types in this repository are considered non-breaking and are usually released as patch changes (otherwise every type enhancement would be a major version!).
*   It is highly recommended that you lock your `@wagmi/core` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
*   The non-type-related public API of Wagmi Core still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

tsconfig.json

json

    {
      "compilerOptions": {
        "strict": true
      }
    }

Const-Assert ABIs & Typed Data [‚Äã](#const-assert-abis-typed-data)
-----------------------------------------------------------------

Wagmi Core can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh/) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

ts

    const result = await readContract({
      abi: [‚Ä¶], // <--- defined inline
    })

ts

    const abi = [‚Ä¶] as const // <--- const assertion
    const result = readContract({ abi })

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`readContract`](https://wagmi.sh/core/api/actions/readContract) looks like with and without a const-asserted `abi` property.

Const-AssertedNot Const-Asserted

ts

    import {  } from '@wagmi/core'
    
    const  = await (, {
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      : 'balanceOf',
    
    
    
      : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    
    

ts

    import {  } from '@wagmi/core'
    
    const  = await (, {
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      : 'balanceOf',
    
    
    
      : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    
    

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. üéâ

ts

    import {  } from '@wagmi/core'
    
    (, {
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      functionName: 'balanecOf',Type '"balanecOf"' is not assignable to type '"balanceOf" | "isApprovedForAll" | "getApproved" | "ownerOf" | "tokenURI"'. Did you mean '"balanceOf"'?  : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })

Configure Internal Types [‚Äã](#configure-internal-types)
-------------------------------------------------------

For advanced use-cases, you may want to configure wagmi's internal types. Most of wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev/) for more info on how to configure types.</content>
</page>

<page>
  <title>Installation | Wagmi</title>
  <url>https://wagmi.sh/core/installation</url>
  <content>Install Wagmi Core via your package manager, a `<script>` tag, or build from source.

Package Manager [‚Äã](#package-manager)
-------------------------------------

Install the required packages.

pnpmnpmyarnbun

bash

    pnpm add @wagmi/core viem@2.x

bash

    npm install @wagmi/core viem@2.x

bash

    yarn add @wagmi/core viem@2.x

bash

    bun add @wagmi/core viem@2.x

*   [Viem](https://viem.sh/) is a TypeScript interface for Ethereum that performs blockchain operations.
*   [TypeScript](https://wagmi.sh/react/typescript) is optional, but highly recommended. Learn more about [TypeScript support](https://wagmi.sh/react/typescript).

CDN [‚Äã](#cdn)
-------------

If you're not using a package manager, you can also use Wagmi Core via an ESM-compatible CDN such as [esm.sh](https://esm.sh/). Simply add a `<script type="module">` tag to the bottom of your HTML file with the following content.

html

    <script type="module">
      import { createClient } from 'https://esm.sh/viem'
      import { createConfig } from 'https://esm.sh/@wagmi/core@2.x'
      import { injected } from 'https://esm.sh/@wagmi/connectors'
    </script>

Requirements [‚Äã](#requirements)
-------------------------------

Wagmi is optimized for modern browsers. It is compatible with the latest versions of the following browsers.

Using Unreleased Commits [‚Äã](#using-unreleased-commits)
-------------------------------------------------------

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

pnpmnpmyarnbun

bash

    pnpm add @wagmi/core@canary

bash

    npm install @wagmi/core@canary

bash

    yarn add @wagmi/core@canary

bash

    bun add @wagmi/core@canary

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

bash

    gh repo clone wevm/wagmi
    cd wagmi
    pnpm install
    pnpm build
    cd packages/core
    pnpm link --global

Then go to the project where you are using Wagmi and run `pnpm link --global @wagmi/core` (or the package manager that you used to link Wagmi globally). Make sure you installed any [required peer dependencies](#package-manager) and their versions are correct.

Security [‚Äã](#security)
-----------------------

Ethereum-related projects are often targeted in attacks to steal users' assets. Make sure you follow security best-practices for your project. Some quick things to get started.

*   Pin package versions, upgrade mindfully, and inspect lockfile changes to minimize the risk of [supply-chain attacks](https://nodejs.org/en/guides/security/#supply-chain-attacks).
*   Install the [Socket Security](https://socket.dev/) [GitHub App](https://github.com/apps/socket-security) to help detect and block supply-chain attacks.
*   Add a [Content Security Policy](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) to defend against external scripts running in your app.
*   Pin [GitHub Action](https://x.com/paulmillr/status/1900948425325031448) versions to commits instead of tags.</content>
</page>

<page>
  <title>Why Wagmi Core | Wagmi</title>
  <url>https://wagmi.sh/core/why</url>
  <content>The Problems [‚Äã](#the-problems)
-------------------------------

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi Core solves all these problems and more ‚Äî allowing app developers to focus on building high-quality and performant experiences for Ethereum ‚Äî by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

Developer Experience [‚Äã](#developer-experience)
-----------------------------------------------

Wagmi Core delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi Core's APIs might seem more verbose at first, it makes Wagmi Core's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi Core is a great way to learn how to interact with Ethereum in general.

Wagmi Core also provides [strongly typed APIs](https://wagmi.sh/core/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi Core can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](https://wagmi.sh/core/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi Core. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20\(TDD\),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

Performance [‚Äã](#performance)
-----------------------------

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi Core uses and is built by the same team behind [Viem](https://viem.sh/), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi Core is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times.

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi Core supports caching, deduplication, persistence, and much more through [TanStack Query](https://wagmi.sh/react/guides/tanstack-query) via the `'@wagmi/core/query'` entrypoint so you can [plug it into your framework](https://wagmi.sh/core/guides/framework-adapters) of choice, like Vue, Svelte, and more.

Feature Coverage [‚Äã](#feature-coverage)
---------------------------------------

Wagmi Core supports the most popular and commonly-used Ethereum features out of the box with 40+ VanillaJS Actions for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi Core also supports just about any wallet out there through its official [connectors](https://wagmi.sh/core/api/connectors), [EIP-6963 support](https://wagmi.sh/core/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](https://wagmi.sh/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Viem](https://viem.sh/), which Wagmi Core uses internally to perform blockchain operations. Wagmi Core also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi Core has a [CLI](https://wagmi.sh/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com/), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz/), [Privy](https://privy.io/), and many more, so you can get started quickly without needing to build everything from scratch.

Stability [‚Äã](#stability)
-------------------------

Stability is a fundamental principle for Wagmi Core. Many organizations, large and small, rely heavily on Wagmi Core and expect it to be entirely stable for their users and applications.

Wagmi Core's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi Core follows semver so developers can upgrade between versions with confidence. Starting with Wagmi Core v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi Core and [related projects](https://github.com/wevm), and is constantly improving Wagmi Core and keeping it up-to-date with industry trends and changes.</content>
</page>

<page>
  <title>useWaitForCallsStatus | Wagmi</title>
  <url>https://wagmi.sh/react/api/hooks/useWaitForCallsStatus</url>
  <content>Waits for a call bundle to be confirmed & included on a block before returning the status & receipts.

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { useWaitForCallsStatus } from 'wagmi/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsxconfig.ts

tsx

    import { useWaitForCallsStatus } from 'wagmi/experimental'
    
    function App() {
      const result = useWaitForCallsStatus({
        id: '0x...',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWaitForCallsStatusParameters } from 'wagmi/experimental'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.tsxconfig.ts

tsx

    import { useWaitForCallsStatus } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useWaitForCallsStatus({
        config,
        id: '0x...',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get call statuses with.

index.tsxconfig.ts

tsx

    import { useWaitForCallsStatus, useConnections } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const connections = useConnections()
      const result = useWaitForCallsStatus({
        connector: connections[0]?.connector,
        id: '0x...',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### id [‚Äã](#id)

`string`

Identifier of the call batch.

index.tsconfig.ts

ts

    import { useWaitForCallsStatus } from '@wagmi/core'
    import { config } from './config'
    
    const status = await useWaitForCallsStatus({
      id: '0x1234567890abcdef', 
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

Polling interval in milliseconds.

index.tsconfig.ts

ts

    import { useWaitForCallsStatus } from '@wagmi/core'
    import { config } from './config'
    
    const status = await useWaitForCallsStatus({
      id: '0x1234567890abcdef',
      pollingInterval: 1_000, 
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.tsxconfig.ts

tsx

    import { useWaitForCallsStatus } from 'wagmi/experimental'
    import { config } from './config'
    
    function App() {
      const result = useWaitForCallsStatus({
        id: '0x...',
        scopeKey: 'foo',
      })
    }

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### timeout [‚Äã](#timeout)

`number | undefined`

Timeout in milliseconds.

index.tsconfig.ts

ts

    import { useWaitForCallsStatus } from '@wagmi/core'
    import { config } from './config'
    
    const status = await useWaitForCallsStatus({
      id: '0x1234567890abcdef',
      timeout: 10_000, 
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`WaitForCallsStatusReturnType | (() => WaitForCallsStatusReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`WaitForCallsStatusReturnType | ((previousValue: WaitForCallsStatusReturnType | undefined; previousQuery: Query | undefined) => WaitForCallsStatusReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: WaitForCallsStatusReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: WaitForCallsStatusErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: WaitForCallsStatusErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: WaitForCallsStatusReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: WaitForCallsStatusReturnType | undefined, newData: WaitForCallsStatusReturnType) => WaitForCallsStatusReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWaitForCallsStatusReturnType } from 'wagmi/experimental'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`WaitForCallsStatusReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | WaitForCallsStatusErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | WaitForCallsStatusErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<WaitForCallsStatusReturnType, WaitForCallsStatusErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WaitForCallsStatusData,
      type WaitForCallsStatusOptions,
      type WaitForCallsStatusQueryFnData,
      type WaitForCallsStatusQueryKey,
      waitForCallsStatusQueryKey,
      waitForCallsStatusQueryOptions,
    } from 'wagmi/experimental/query'

Action [‚Äã](#action)
-------------------

*   [`waitForCallsStatus`](https://viem.sh/experimental/eip5792/waitForCallsStatus)</content>
</page>

<page>
  <title>Viem | Wagmi</title>
  <url>https://wagmi.sh/core/guides/viem</url>
  <content>[Viem](https://viem.sh/) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](https://wagmi.sh/core/api/createConfig) and automatic account management via [Connectors](https://wagmi.sh/core/api/connectors).

Leveraging Viem Actions [‚Äã](#leveraging-viem-actions)
-----------------------------------------------------

All of the core [Wagmi Actions](https://wagmi.sh/core/api/actions) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](https://wagmi.sh/core/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe an Action doesn't exist in Wagmi yet). In these cases, you can import Viem Actions directly via `viem/actions` and plug in a Viem Client returned by the [`getClient` Action](https://wagmi.sh/core/api/actions/getClient).

The example below demonstrates two different ways to utilize Viem Actions:

1.  **Tree-shakable Actions (recommended):** Uses `getClient` (for public actions) and `getConnectorClient` (for wallet actions).
2.  **Client Actions:** Uses `getPublicClient` (for public actions) and `getWalletClient` (for wallet actions).

TIP

It is highly recommended to use the **tree-shakable** method to ensure that you are only pulling modules you use, and keep your bundle size low.

Tree-shakable ActionsClient Actions

tsx

    // 1. Import modules. 
    import { http, createConfig, getClient, getConnectorClient } from '@wagmi/core' 
    import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
    import { getLogs, watchAsset } from 'viem/actions'
    
    // 2. Set up a Wagmi Config 
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    // 3. Extract a Viem Client for the current active chain.
    const publicClient = getClient(config)
    const logs = await getLogs(publicClient, /* ... */)
    
    // 4. Extract a Viem Client for the current active chain & account.
    const walletClient = getConnectorClient(config)
    const success = await watchAsset(walletClient, /* ... */)

tsx

    // 1. Import modules. 
    import { http, createConfig, getPublicClient, getWalletClient } from '@wagmi/core' 
    import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
    
    // 2. Set up a Wagmi Config 
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    // 3. Extract a Viem Public Client for the current active chain.
    const publicClient = getPublicClient(config)
    const logs = await publicClient.getLogs(publicClient, /* ... */)
    
    // 4. Extract a Viem Wallet Client for the current active chain & account.
    const walletClient = getWalletClient(config)
    const success = await walletClient.watchAsset(walletClient, /* ... */)

Multi-chain Viem Client [‚Äã](#multi-chain-viem-client)
-----------------------------------------------------

The [Viem Client](https://viem.sh/docs/client) provides an interface to interact with an JSON-RPC Provider. By nature, JSON-RPC Providers are single-chain, so the Viem Client is designed to be instantiated with a single `chain`. As a result, setting up Viem to be multi-chain aware can get a bit verbose.

The good news is that you can create a **"multi-chain Viem Client"** with **Wagmi** by utilizing [`createConfig`](https://wagmi.sh/core/api/createConfig) and [`getClient`](https://wagmi.sh/core/api/actions/getClient).

Wagmi UsageViem Usage

tsx

    // 1. Import modules. 
    import { http, createConfig, getClient, getConnectorClient } from '@wagmi/core' 
    import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
    import { getBlockNumber, sendTransaction } from 'viem/actions'
    
    // 2. Set up a Wagmi Config 
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    // 3. Extract a Viem Client for the current active chain.
    const publicClient = getClient(config)
    const blockNumber = await getBlockNumber(publicClient)
    
    // 4. Extract a Viem Client for the current active chain & account.
    const walletClient = getConnectorClient(config)
    const hash = await sendTransaction(walletClient, /* ... */)

tsx

    // Manually set up Viem Clients without wagmi. Don't do this, it's only here 
    // to demonstrate the amount of boilerplate required.
    
    import { createPublicClient, createWalletClient, http } from 'viem'
    import { base, mainnet, optimism, zora } from 'viem/chains'
    
    const publicClient = {
      base: createPublicClient({
        chain: base,
        transport: http()
      }),
      mainnet: createPublicClient({
        chain: mainnet,
        transport: http()
      }),
      optimism: createPublicClient({
        chain: optimism,
        transport: http()
      }),
      zora: createPublicClient({
        chain: zora,
        transport: http()
      })
    } as const
    
    const walletClient = {
      base: createWalletClient({
        chain: base,
        transport: custom(window.ethereum)
      }),
      mainnet: createWalletClient({
        chain: mainnet,
        transport: custom(window.ethereum)
      }),
      optimism: createWalletClient({
        chain: optimism,
        transport: custom(window.ethereum)
      }),
      zora: createWalletClient({
        chain: zora,
        transport: custom(window.ethereum)
      })
    } as const
    
    const blockNumber = await publicClient.mainnet.getBlockNumber()
    const hash = await walletClient.mainnet.sendTransaction(/* ... */)

Private Key & Mnemonic Accounts [‚Äã](#private-key-mnemonic-accounts)
-------------------------------------------------------------------

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

tsx

    import { http, createConfig, sendTransaction } from '@wagmi/core' 
    import { base, mainnet, optimism, zora } from '@wagmi/core/chains' 
    import { parseEther } from 'viem'
    import { privateKeyToAccount } from 'viem/accounts'
    
    export const config = createConfig({ 
      chains: [base, mainnet, optimism, zora], 
      transports: { 
        [base.id]: http(), 
        [mainnet.id]: http(), 
        [optimism.id]: http(), 
        [zora.id]: http(), 
      }, 
    }) 
    
    const account = privateKeyToAccount('0x...')
    
    const hash = await sendTransaction({ 
      account,
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
      value: parseEther('0.001')
    })

INFO

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config ‚Äì meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open a discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).</content>
</page>

<page>
  <title>Framework Adapters | Wagmi</title>
  <url>https://wagmi.sh/core/guides/framework-adapters</url>
  <content>Folks often ask if they can use Wagmi with other frameworks, like Svelte, Solid.js, and more.

The short answer is ‚Äî you already can! Wagmi Core is pure VanillaJS that you can use with any framework. For some, this answer is (understandably) unsatisfying as they want a tight integration between Wagmi Core and their favorite framework's reactivity system, e.g. what Wagmi is for React and Vue.

Someday, we would love to support additional frameworks, but unfortunately the core team doesn't have time to build and support them in a high-quality way at the moment. This could change in the future with additional [sponsors](https://github.com/sponsors/wevm), reshuffling of the roadmap, or if someone from the community wants to lead the effort.

In the meantime, here are some tips on how to create tighter bonds between Wagmi Core and other frameworks.

Dependency Injection [‚Äã](#dependency-injection)
-----------------------------------------------

Once you create a Wagmi Config, you'll need to make sure your framework has access to it inside your higher-level functions (e.g. hooks for React, composables for Vue). For example, Wagmi uses [React Context](https://react.dev/learn/passing-data-deeply-with-context) to inject the Config into React Hooks and update it if it changes. This makes it so your users don't need to pass a Config object every time they use a hook.

Reactivity Layer [‚Äã](#reactivity-layer)
---------------------------------------

All frameworks approach reactivity in a different way. To hook into your favorite frameworks, reactivity system, it's often helpful to see what other popular libraries for your framework are doing.

The most important thing to hook up Wagmi Core with your framework is to make sure changes to the Wagmi Config are tracked. This enables behavior, like switching chains or connecting accounts, to propagate throughout your app and update state. Check out [`useAccount`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useAccount.ts), [`useChainId`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useChainId.ts), [`useClient`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useClient.ts), and [`useConnectorClient`](https://github.com/wevm/wagmi/blob/main/packages/react/src/hooks/useConnectorClient.ts) ‚Äî versions of these for your framework are important to get right as they power a lot of internals.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

Wagmi uses [TanStack Query](https://tanstack.com/query) to enable caching, deduplication, persistence, and more in React and Vue applications. Normally, you would need to find a similar library for your framework, but the good news is TanStack Query supports other frameworks! (Svelte, Solid, and Angular at the time of writing.)

To get started with your framework, install and set up the related TanStack Query adapter. Next, import query keys/functions and mutation functions from the `'@wagmi/core/query'` entrypoint. You can plug these directly into your framework's TanStack Query adapter functions.

If you are building a library, you'll also want to make sure that you wire up generics correctly so type-inference and safety work correctly. The best way to make sure you are doing this correctly, is to see how we do this for React with Wagmi by checking out the [source code](https://github.com/wevm/wagmi/tree/main/packages/react/src/hooks).

Testing [‚Äã](#testing)
---------------------

If you are building a library, you'll want to write tests. Wagmi uses [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) to test hooks. [Testing Library](https://testing-library.com/) also supports other frameworks, like Svelte, Solid, and more. You can take a look at how the React tests work and do something similar for your code.

Proxy Exports [‚Äã](#proxy-exports)
---------------------------------

Wagmi proxies exports directly from Wagmi Core and [Viem](https://viem.sh/) to make importing easier. You'll likely want to imitate this behavior for your framework.</content>
</page>

<page>
  <title>FAQ / Troubleshooting | Wagmi</title>
  <url>https://wagmi.sh/core/guides/faq</url>
  <content>Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

Type inference doesn't work [‚Äã](#type-inference-doesn-t-work)
-------------------------------------------------------------

*   Check that you set up TypeScript correctly with `"strict": true` in your `tsconfig.json` ([TypeScript docs](https://wagmi.sh/core/typescript#requirements))
*   Check that you [const-asserted any ABIs or Typed Data](https://wagmi.sh/core/typescript#const-assert-abis-typed-data) you are using.
*   Restart your language server or IDE, and check for type errors in your code.

My wallet doesn't work [‚Äã](#my-wallet-doesn-t-work)
---------------------------------------------------

If you run into issues with a specific wallet, try another before opening up an issue. There are many different wallets and it's likely that the issue is with the wallet itself, not Wagmi. For example, if you are using Wallet X and sending a transaction doesn't work, try Wallet Y and see if it works.

`BigInt` Serialization [‚Äã](#bigint-serialization)
-------------------------------------------------

Using native `BigInt` with `JSON.stringify` will raise a `TypeError` as [`BigInt` values are not serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json). There are two techniques to mitigate this:

#### Lossless serialization [‚Äã](#lossless-serialization)

Lossless serialization means that `BigInt` will be converted to a format that can be deserialized later (e.g. `69420n` ‚Üí `"#bigint.69420"`). The trade-off is that these values are not human-readable and are not intended to be displayed to the user.

Lossless serialization can be achieved with wagmi's [`serialize`](https://wagmi.sh/core/api/utilities/serialize) and [`deserialize`](https://wagmi.sh/core/api/utilities/deserialize) utilities.

tsx

    import { serialize, deserialize } from 'wagmi'
    
    const serialized = serialize({ value: 69420n })
    // '{"value":"#bigint.69420"}'
    
    const deserialized = deserialize(serialized)
    // { value: 69420n }

#### Lossy serialization [‚Äã](#lossy-serialization)

Lossy serialization means that the `BigInt` will be converted to a normal display string (e.g. `69420n` ‚Üí `'69420'`). The trade-off is that you will not be able to deserialize the `BigInt` with `JSON.parse` as it can not distinguish between a normal string and a `BigInt`.

This method can be achieved by modifying `JSON.stringify` to include a BigInt `replacer`:

tsx

    const replacer = (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    
    JSON.stringify({ value: 69420n }, replacer)
    // '{"value":"69420"}'

How do I support the project? [‚Äã](#how-do-i-support-the-project)
----------------------------------------------------------------

Wagmi is an open source software project and free to use. If you enjoy using Wagmi or would like to support Wagmi development, you can:

*   [Become a sponsor on GitHub](https://github.com/sponsors/wevm)
*   Send us crypto
    *   Mainnet: 0x4557B18E779944BFE9d78A672452331C186a9f48
    *   Multichain: 0xd2135CfB216b74109775236E36d4b433F1DF507B
*   [Become a supporter on Drips](https://www.drips.network/app/projects/github/wevm/wagmi)

If you use Wagmi at work, consider asking your company to sponsor Wagmi. This may not be easy, but **business sponsorships typically make a much larger impact on the sustainability of OSS projects** than individual donations, so you will help us much more if you succeed.

Is Wagmi production ready? [‚Äã](#is-wagmi-production-ready)
----------------------------------------------------------

Yes. Wagmi is very stable and is used in production by thousands of organizations, like [Stripe](https://stripe.com/), [Shopify](https://shopify.com/), [Coinbase](https://coinbase.com/), [Uniswap](https://uniswap.org/), [ENS](https://ens.domains/), [Optimism](https://optimism.com/).

Is Wagmi strict with semver? [‚Äã](#is-wagmi-strict-with-semver)
--------------------------------------------------------------

Yes, Wagmi is very strict with [semantic versioning](https://semver.org/) and we will never introduce breaking changes to the runtime API in a minor version bump.

For exported types, we try our best to not introduce breaking changes in non-major versions, however, [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases that can cause Wagmi type issues. See the [TypeScript docs](https://wagmi.sh/core/typescript#requirements) for more information.

How can I contribute to Wagmi? [‚Äã](#how-can-i-contribute-to-wagmi)
------------------------------------------------------------------

The Wagmi team accepts all sorts of contributions. Check out the [Contributing](https://wagmi.sh/dev/contributing) guide to get started. If you are interested in adding a new connector to Wagmi, check out the [Creating Connectors](https://wagmi.sh/dev/creating-connectors) guide.

Anything else you want to know? [‚Äã](#anything-else-you-want-to-know)
--------------------------------------------------------------------

Please create a new [GitHub Discussion thread](https://github.com/wevm/wagmi). You're also free to suggest changes to this or any other page on the site using the "Suggest changes to this page" button at the bottom of the page.</content>
</page>

<page>
  <title>Ethers.js Adapters | Wagmi</title>
  <url>https://wagmi.sh/core/guides/ethers</url>
  <content>It is recommended for projects to migrate to [Viem](https://viem.sh/) when using Wagmi, but there are some cases where you might still need to use [Ethers.js](https://ethers.org/) in your project:

*   You may want to **incrementally migrate** Ethers.js usage to Viem
*   Some **third-party libraries & SDKs** may only support Ethers.js
*   Personal preference

We have provided reference implementations for Viem ‚Üí Ethers.js adapters that you can copy + paste in your project.

Client ‚Üí Provider [‚Äã](#client-‚Üí-provider)
-----------------------------------------

### Reference Implementation [‚Äã](#reference-implementation)

Copy the following reference implementation into a file of your choice:

Ethers v5Ethers v6

ts

    import { type Config, getClient } from '@wagmi/core'
    import { providers } from 'ethers'
    import type { Client, Chain, Transport } from 'viem'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback')
        return new providers.FallbackProvider(
          (transport.transports as ReturnType<Transport>[]).map(
            ({ value }) => new providers.JsonRpcProvider(value?.url, network),
          ),
        )
      return new providers.JsonRpcProvider(transport.url, network)
    }
    
    /** Action to convert a viem Public Client to an ethers.js Provider. */
    export function getEthersProvider(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = getClient(config, { chainId })
      if (!client) return
      return clientToProvider(client)
    }

ts

    import { type Config, getClient } from '@wagmi/core'
    import { FallbackProvider, JsonRpcProvider } from 'ethers'
    import type { Client, Chain, Transport } from 'viem'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback') {
        const providers = (transport.transports as ReturnType<Transport>[]).map(
          ({ value }) => new JsonRpcProvider(value?.url, network),
        )
        if (providers.length === 1) return providers[0]
        return new FallbackProvider(providers)
      }
      return new JsonRpcProvider(transport.url, network)
    }
    
    /** Action to convert a viem Client to an ethers.js Provider. */
    export function getEthersProvider(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = getClient(config, { chainId })
      if (!client) return
      return clientToProvider(client)
    }

### Usage [‚Äã](#usage)

Now you can use the `getEthersProvider` function in your components:

example.tsethers.ts (Ethers v5)ethers.ts (Ethers v6)

ts

    import { getEthersProvider } from './ethers'
    import { config } from './config'
    
    function example() {
      const provider = getEthersProvider(config)
      ...
    }

ts

    import { type Config, getClient } from '@wagmi/core'
    import { providers } from 'ethers'
    import type { Client, Chain, Transport } from 'viem'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback')
        return new providers.FallbackProvider(
          (transport.transports as ReturnType<Transport>[]).map(
            ({ value }) => new providers.JsonRpcProvider(value?.url, network),
          ),
        )
      return new providers.JsonRpcProvider(transport.url, network)
    }
    
    /** Action to convert a viem Public Client to an ethers.js Provider. */
    export function getEthersProvider(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = getClient(config, { chainId })
      if (!client) return
      return clientToProvider(client)
    }

ts

    import { type Config, getClient } from '@wagmi/core'
    import { FallbackProvider, JsonRpcProvider } from 'ethers'
    import type { Client, Chain, Transport } from 'viem'
    
    export function clientToProvider(client: Client<Transport, Chain>) {
      const { chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      if (transport.type === 'fallback') {
        const providers = (transport.transports as ReturnType<Transport>[]).map(
          ({ value }) => new JsonRpcProvider(value?.url, network),
        )
        if (providers.length === 1) return providers[0]
        return new FallbackProvider(providers)
      }
      return new JsonRpcProvider(transport.url, network)
    }
    
    /** Action to convert a viem Client to an ethers.js Provider. */
    export function getEthersProvider(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = getClient(config, { chainId })
      if (!client) return
      return clientToProvider(client)
    }

Connector Client ‚Üí Signer [‚Äã](#connector-client-‚Üí-signer)
---------------------------------------------------------

### Reference Implementation [‚Äã](#reference-implementation-1)

Copy the following reference implementation into a file of your choice:

Ethers v5Ethers v6

ts

    import { Config, getConnectorClient } from '@wagmi/core'
    import { providers } from 'ethers'
    import type { Account, Chain, Client, Transport } from 'viem'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new providers.Web3Provider(transport, network)
      const signer = provider.getSigner(account.address)
      return signer
    }
    
    /** Action to convert a Viem Client to an ethers.js Signer. */
    export async function getEthersSigner(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = await getConnectorClient(config, { chainId })
      return clientToSigner(client)
    }

ts

    import { Config, getConnectorClient } from '@wagmi/core'
    import { BrowserProvider, JsonRpcSigner } from 'ethers'
    import type { Account, Chain, Client, Transport } from 'viem'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new BrowserProvider(transport, network)
      const signer = new JsonRpcSigner(provider, account.address)
      return signer
    }
    
    /** Action to convert a viem Wallet Client to an ethers.js Signer. */
    export async function getEthersSigner(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = await getConnectorClient(config, { chainId })
      return clientToSigner(client)
    }

### Usage [‚Äã](#usage-1)

Now you can use the `getEthersSigner` function in your components:

example.tsethers.ts (Ethers v5)ethers.ts (Ethers v6)

ts

    import { getEthersSigner } from './ethers'
    import { config } from './config'
    
    function example() {
      const provider = getEthersSigner(config)
      ...
    }

ts

    import { Config, getConnectorClient } from '@wagmi/core'
    import { providers } from 'ethers'
    import type { Account, Chain, Client, Transport } from 'viem'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new providers.Web3Provider(transport, network)
      const signer = provider.getSigner(account.address)
      return signer
    }
    
    /** Action to convert a Viem Client to an ethers.js Signer. */
    export async function getEthersSigner(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = await getConnectorClient(config, { chainId })
      return clientToSigner(client)
    }

ts

    import { Config, getConnectorClient } from '@wagmi/core'
    import { BrowserProvider, JsonRpcSigner } from 'ethers'
    import type { Account, Chain, Client, Transport } from 'viem'
    
    export function clientToSigner(client: Client<Transport, Chain, Account>) {
      const { account, chain, transport } = client
      const network = {
        chainId: chain.id,
        name: chain.name,
        ensAddress: chain.contracts?.ensRegistry?.address,
      }
      const provider = new BrowserProvider(transport, network)
      const signer = new JsonRpcSigner(provider, account.address)
      return signer
    }
    
    /** Action to convert a viem Wallet Client to an ethers.js Signer. */
    export async function getEthersSigner(
      config: Config,
      { chainId }: { chainId?: number } = {},
    ) {
      const client = await getConnectorClient(config, { chainId })
      return clientToSigner(client)
    }</content>
</page>

<page>
  <title>Error Handling | Wagmi</title>
  <url>https://wagmi.sh/core/guides/error-handling</url>
  <content>Every module in Wagmi Core exports an accompanying error type which you can use to strongly type your `catch` statements.

These types come in the form of `<Module>ErrorType`. For example, the `getBlockNumber` action exports a `GetBlockNumberErrorType` type.

Unfortunately, [TypeScript doesn't have an abstraction for typed exceptions](https://github.com/microsoft/TypeScript/issues/13219), so the most pragmatic & vanilla approach would be to explicitly cast error types in the `catch` statement.

index.tsxconfig.ts

tsx

    import { type GetBlockNumberErrorType, getBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    try {
      const blockNumber = await getBlockNumber(config)
    } catch (e) {
      const error = e as GetBlockNumberErrorType
      error.name
      //    ^? (property) name: "Error" | "ChainDisconnectedError" | "HttpRequestError" | "InternalRpcError" | "InvalidInputRpcError" | "InvalidParamsRpcError" | "InvalidRequestRpcError" | "JsonRpcVersionUnsupportedError" | ... 16 more ... | "WebSocketRequestError"
    
      if (error.name === 'InternalRpcError')
        error.code
        //    ^? (property) code: -32603
    
      if (error.name === 'HttpRequestError')
        error.headers
        //    ^? (property) headers: Headers
        error.status
        //    ^? (property) status: number
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })</content>
</page>

<page>
  <title>Chain Properties | Wagmi</title>
  <url>https://wagmi.sh/core/guides/chain-properties</url>
  <content>Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains support all additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

Narrowing Parameters [‚Äã](#narrowing-parameters)
-----------------------------------------------

When you pass your `config` to an action, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { simulateContract } from '@wagmi/core'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
      feeCurrency: '0x‚Ä¶', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { base, celo, mainnet } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { simulateContract } from '@wagmi/core'
    import { celo } from 'wagmi/chains'
    
    const result = await simulateContract({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
      chainId: celo.id, 
      feeCurrency: '0x‚Ä¶', 
      // ^? (property) feeCurrency?: `0x${string}` | undefined
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { base, celo, mainnet } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })

Narrowing Return Types [‚Äã](#narrowing-return-types)
---------------------------------------------------

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter [‚Äã](#chainid-parameter)

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

index.tsxconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { zkSync } from '@wagmi/core/chains'
    
    const result = await waitForTransactionReceipt({
      chainId: zkSync.id,
      hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
    })
    
    result.logs
    //     ^? (property) logs: ZkSyncLog[] | undefined

ts

    import { http, createConfig } from '@wagmi/core'
    import { base, celo, mainnet } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })

### `chainId` Data Property [‚Äã](#chainid-data-property)

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

index.tsxconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { zkSync } from '@wagmi/core/chains'
    
    const result = await waitForTransactionReceipt({
      hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
    })
    
    if (result.chainId === zkSync.id) {
      result.logs
      //     ^? (property) logs: ZkSyncLog[] | undefined
    }

ts

    import { http, createConfig } from '@wagmi/core'
    import { base, celo, mainnet } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })

Troubleshooting [‚Äã](#troubleshooting)
-------------------------------------

If chain properties aren't working, make sure [TypeScript](https://wagmi.sh/core/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).</content>
</page>

<page>
  <title>createConnector | Wagmi</title>
  <url>https://wagmi.sh/core/api/createConnector</url>
  <content>Creates new [`CreateConnectorFn`](#parameters).

Import [‚Äã](#import)
-------------------

ts

    import { createConnector } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConnector } from '@wagmi/core'
    
    export type InjectedParameters = {}
    
    export function injected(parameters: InjectedParameters = {}) {
      return createConnector((config) => ({
        // ...
      }))
    }

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateConnectorFn } from '@wagmi/core'

Read [Creating Connectors](https://wagmi.sh/dev/creating-connectors) for more info on the `CreateConnectorFn` type.</content>
</page>

<page>
  <title>createConfig | Wagmi</title>
  <url>https://wagmi.sh/core/api/createConfig</url>
  <content>Creates new [`Config`](#config) object.

Import [‚Äã](#import)
-------------------

ts

    import { createConfig } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

Integrating a Viem Client

Instead of using [`transports`](#transports), it's possible to provide a function that returns a Viem [`Client`](https://viem.sh/docs/clients/custom.html) via the [`client`](#client) property for more fine-grained control over Wagmi's internal `Client` creation.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { createClient } from 'viem'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      client({ chain }) {
        return createClient({ chain, transport: http() })
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateConfigParameters } from '@wagmi/core'

### chains [‚Äã](#chains)

`readonly [Chain, ...Chain[]]`

*   Chains used by the `Config`.
*   See [Chains](https://wagmi.sh/core/api/chains) for more details about built-in chains and the `Chain` type.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia], 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### connectors [‚Äã](#connectors)

`CreateConnectorFn[] | undefined`

[Connectors](https://wagmi.sh/core/api/connectors) used by the `Config`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { injected } from '@wagmi/connectors'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()], 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### multiInjectedProviderDiscovery [‚Äã](#multiinjectedproviderdiscovery)

`boolean | undefined`

*   Enables discovery of injected providers via [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) using the [`mipd`](https://github.com/wevm/mipd) library and converting to [injected](https://wagmi.sh/core/api/connectors/injected) connectors.
*   Defaults to `true`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      multiInjectedProviderDiscovery: false, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### ssr [‚Äã](#ssr)

`boolean | undefined`

Flag to indicate if the config is being used in a server-side rendering environment. Defaults to `false`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### storage [‚Äã](#storage)

`Storage | null | undefined`

*   [`Storage`](https://wagmi.sh/core/api/createStorage#storage) used by the config. Persists `Config`'s [`State`](#state-1) between sessions.
*   Defaults to `createStorage({ storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage })`.

ts

    import { createConfig, createStorage, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      storage: createStorage({ storage: window.localStorage }), 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Keep the [`State['chainId']`](#chainid) in sync with the current connection.
*   Defaults to `true`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      syncConnectedChain: false, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

* * *

### batch [‚Äã](#batch)

`{ multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | { [_ in chains[number]["id"]]?: { multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | undefined } | undefined`

*   Batch settings. See [Viem docs](https://viem.sh/docs/clients/custom.html#batch-optional) for more info.
*   Defaults to `{ multicall: true }`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      batch: { multicall: true }, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### cacheTime [‚Äã](#cachetime)

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

*   Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/public.html#cachetime-optional) for more info.
*   Defaults to [`pollingInterval`](#pollinginterval) or `4_000`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      cacheTime: 4_000, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

*   Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/custom.html#pollinginterval-optional) for more info.
*   Defaults to `4_000`.

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      pollingInterval: 4_000, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### transports [‚Äã](#transports)

`Record<chains[number]['id'], Transport>`

Mapping of [chain IDs](#chains) to [`Transport`](https://wagmi.sh/core/api/transports)s. This mapping is used internally when creating chain-aware Viem [`Client`](https://viem.sh/docs/clients/custom.html) objects. See the [Transport docs](https://wagmi.sh/core/api/transports) for more info.

ts

    import { createConfig, fallback, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      transports: { 
        [mainnet.id]: fallback([ 
          http('https://...'), 
          http('https://...'), 
        ]), 
        [sepolia.id]: http('https://...'), 
      }, 
    })

* * *

### client [‚Äã](#client)

`(parameters: { chain: chains[number] }) => Client<Transport, chains[number]>`

Function for creating new Viem [`Client`](https://viem.sh/docs/clients/custom.html) to be used internally. Exposes more control over the internal `Client` creation logic versus using the [`transports`](#transports) property.

ts

    import { createClient, http } from 'viem'
    import { createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      client({ chain }) { 
        return createClient({ chain, transport: http('https://...') }) 
      }, 
    })

WARNING

When using this option, you likely want to pass `parameters.chain` straight through to [`createClient`](https://viem.sh/docs/clients/custom.html#createclient) to ensure the Viem `Client` is in sync with any active connections.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type Config } from '@wagmi/core'

Config [‚Äã](#config)
-------------------

Object responsible for managing Wagmi state and internals.

ts

    import { type Config } from '@wagmi/core'

### chains [‚Äã](#chains-1)

`readonly [Chain, ...Chain[]]`

[`chains`](#chains) passed to `createConfig`.

### connectors [‚Äã](#connectors-1)

`readonly Connector[]`

Connectors set up from passing [`connectors`](#connectors) and [`multiInjectedProviderDiscovery`](#multiinjectedproviderdiscovery) to `createConfig`.

### state [‚Äã](#state)

`State<chains>`

The `Config` object's internal state. See [`State`](#state-1) for more info.

### storage [‚Äã](#storage-1)

`Storage | null`

[`storage`](#storage) passed to `createConfig`.

### getClient [‚Äã](#getclient)

`(parameters?: { chainId?: chainId | chains[number]['id'] | undefined }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>`

Creates new Viem [`Client`](https://viem.sh/docs/clients/custom.html) object.

index.tsconfig.ts

ts

    import { config } from './config'
    
    const client = config.getClient({ chainId: 1 })

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### setState [‚Äã](#setstate)

`(value: State<chains> | ((state: State<chains>) => State<chains>)) => void`

Updates the `Config` object's internal state. See [`State`](#state-1) for more info.

index.tsconfig.ts

ts

    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    config.setState((x) => ({
      ...x,
      chainId: x.current ? x.chainId : mainnet.id,
    }))

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

WARNING

Exercise caution when using this method. It is intended for internal and advanced use-cases only. Manually setting state can cause unexpected behavior.

### subscribe [‚Äã](#subscribe)

`(selector: (state: State<chains>) => state, listener: (selectedState: state, previousSelectedState: state) => void, options?: { emitImmediately?: boolean | undefined; equalityFn?: ((a: state, b: state) => boolean) | undefined } | undefined) => (() => void)`

Listens for state changes matching the `selector` function. Returns a function that can be called to unsubscribe the listener.

index.tsconfig.ts

ts

    import { config } from './config'
    
    const unsubscribe = config.subscribe(
      (state) => state.chainId,
      (chainId) => console.log(`Chain ID changed to ${chainId}`),
    )
    unsubscribe()

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

State [‚Äã](#state-1)
-------------------

ts

    import { type State } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`chains[number]['id']`

Current chain ID. When `syncConnectedChain` is `true`, `chainId` is kept in sync with the current connection. Defaults to first chain in [`chains`](#chains).

### connections [‚Äã](#connections)

`Map<string, Connection>`

Mapping of unique connector identifier to [`Connection`](#connection) object.

### current [‚Äã](#current)

`string | undefined`

Unique identifier of the current connection.

### status [‚Äã](#status)

`'connected' | 'connecting' | 'disconnected' | 'reconnecting'`

Current connection status.

*   `'connecting'` attempting to establish connection.
*   `'reconnecting'` attempting to re-establish connection to one or more connectors.
*   `'connected'` at least one connector is connected.
*   `'disconnected'` no connection to any connector.

Connection [‚Äã](#connection)
---------------------------

ts

    import { type Connection } from '@wagmi/core'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Array of addresses associated with the connection.

### chainId [‚Äã](#chainid-1)

`number`

Chain ID associated with the connection.

### connector [‚Äã](#connector)

`Connector`

Connector associated with the connection.</content>
</page>

<page>
  <title>createStorage | Wagmi</title>
  <url>https://wagmi.sh/core/api/createStorage</url>
  <content>Creates new [`Storage`](#storage) object.

Import [‚Äã](#import)
-------------------

ts

    import { createStorage } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { createStorage } from '@wagmi/core'
    
    const storage = createStorage({ storage: localStorage })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateStorageParameters } from '@wagmi/core'

### deserialize [‚Äã](#deserialize)

`(<T>(value: string) => T) | undefined`

*   Function to deserialize data from storage.
*   Defaults to [`deserialize`](https://wagmi.sh/core/api/utilities/deserialize).

ts

    import { createStorage, deserialize } from '@wagmi/core'
    
    const storage = createStorage({
      deserialize, 
      storage: localStorage,
    })

WARNING

If you use a custom `deserialize` function, make sure it can handle `bigint` and `Map` values.

### key [‚Äã](#key)

`string | undefined`

*   Key prefix to use when persisting data.
*   Defaults to `'wagmi'`.

ts

    import { createStorage } from '@wagmi/core'
    
    const storage = createStorage({
      key: 'my-app', 
      storage: localStorage,
    })

### serialize [‚Äã](#serialize)

`(<T>(value: T) => string) | undefined`

*   Function to serialize data for storage.
*   Defaults to [`serialize`](https://wagmi.sh/core/api/utilities/serialize).

ts

    import { createStorage, serialize } from '@wagmi/core'
    
    const storage = createStorage({
      serialize, 
      storage: localStorage,
    })

WARNING

If you use a custom `serialize` function, make sure it can handle `bigint` and `Map` values.

### storage [‚Äã](#storage)

`{ getItem(key: string): string | null | undefined | Promise<string | null | undefined>; setItem(key: string, value: string): void | Promise<void>; removeItem(key: string): void | Promise<void>; }`

*   Storage interface to use for persisting data.
*   Defaults to `localStorage`.
*   Supports synchronous and asynchronous storage methods.

ts

    import { createStorage } from '@wagmi/core'
    // Using IndexedDB via https://github.com/jakearchibald/idb-keyval
    import { del, get, set } from 'idb-keyval'
    
    const storage = createStorage({
      storage: { 
        async getItem(name) { 
          return get(name)
        }, 
        async setItem(name, value) { 
          await set(name, value) 
        }, 
        async removeItem(name) { 
          await del(name) 
        }, 
      }, 
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type Storage } from '@wagmi/core'

Storage [‚Äã](#storage-1)
-----------------------

Object responsible for persisting Wagmi [`State`](https://wagmi.sh/core/api/createConfig#state-1) and other data.

ts

    import { type Storage } from '@wagmi/core'

### getItem [‚Äã](#getitem)

`getItem(key: string, defaultValue?: value | null | undefined): value | null | Promise<value | null>`

ts

    import { createStorage } from '@wagmi/core'
    
    const storage = createStorage({ storage: localStorage })
    const recentConnectorId = storage.getItem('recentConnectorId')

### setItem [‚Äã](#setitem)

`setItem(key: string, value: any): void | Promise<void>`

ts

    import { createStorage } from '@wagmi/core'
    
    const storage = createStorage({ storage: localStorage })
    storage.setItem('recentConnectorId', 'foo')

### removeItem [‚Äã](#removeitem)

`removeItem(key: string): void | Promise<void>`

ts

    import { createStorage } from '@wagmi/core'
    
    const storage = createStorage({ storage: localStorage })
    storage.removeItem('recentConnectorId')</content>
</page>

<page>
  <title>injected | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors/injected</url>
  <content>Connector for [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Providers.

Import [‚Äã](#import)
-------------------

ts

    import { injected } from '@wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { injected } from '@wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type InjectedParameters } from '@wagmi/connectors'

### shimDisconnect [‚Äã](#shimdisconnect)

`boolean | undefined`

*   MetaMask and other injected providers do not support programmatic disconnect.
*   This flag simulates the disconnect behavior by keeping track of connection status in storage. See [GitHub issue](https://github.com/MetaMask/metamask-extension/issues/10353) for more info.
*   Defaults to `true`.

ts

    import { injected } from '@wagmi/connectors'
    
    const connector = injected({
      shimDisconnect: false, 
    })

### target [‚Äã](#target)

`TargetId | (TargetMap[TargetId] & { id: string }) | (() => (TargetMap[TargetId] & { id: string }) | undefined) | undefined`

*   [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target.
*   [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) supported via `createConfig`'s [`multiInjectedProviderDiscovery`](https://wagmi.sh/core/api/createConfig#multiinjectedproviderdiscovery) property.

ts

    import { injected } from '@wagmi/connectors'
    
    const connector = injected({
      target() { 
        return { 
          id: 'windowProvider', 
          name: 'Window Provider', 
          provider: window.ethereum, 
        } 
      }, 
    })

### unstable\_shimAsyncInject [‚Äã](#unstable-shimasyncinject)

`boolean | number | undefined`

Watches for async provider injection via the `ethereum#initialized` event. When `true`, defaults to `1_000` milliseconds. Otherwise, uses a provided value of milliseconds.

ts

    import { injected } from '@wagmi/connectors'
    
    const connector = injected({
      unstable_shimAsyncInject: 2_000, 
    })</content>
</page>

<page>
  <title>Chains | Wagmi</title>
  <url>https://wagmi.sh/core/api/chains</url>
  <content>Import [‚Äã](#import)
-------------------

Import via the `'@wagmi/core/chains'` entrypoint (proxies all chains from `'viem/chains'`).

ts

    import { mainnet } from '@wagmi/core/chains'

Available Chains [‚Äã](#available-chains)
---------------------------------------

Chain definitions as of `viem@2.23.12`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

266 Chains

OP Mainnet

`optimism`

10 - ETH

Flare Mainnet

`flare`

14 - FLR

Coston

`songbirdTestnet`

16 - CFLR

Songbird Mainnet

`songbird`

19 - SGB

Cronos Mainnet

`cronos`

25 - CRO

Rootstock Mainnet

`rootstock`

30 - RBTC

Rootstock Testnet

`rootstockTestnet`

31 - tRBTC

Telos

`telosTestnet`

41 - TLOS

Darwinia Network

`darwinia`

46 - RING

XinFin Network

`xdc`

50 - XDC

Apothem Network

`xdcTestnet`

51 - TXDC

BNB Smart Chain

`bsc`

56 - BNB

Syscoin Mainnet

`syscoin`

57 - SYS

Ethereum Classic

`classic`

61 - ETC

Conflux eSpace Testnet

`confluxESpaceTestnet`

71 - CFX

Meter Testnet

`meterTestnet`

83 - MTR

Binance Smart Chain Testnet

`bscTestnet`

97 - tBNB

Shibarium

`shibarium`

109 - BONE

Coston2

`flareTestnet`

114 - C2FLR

Fuse Sparknet

`fuseSparknet`

123 - SPARK

Polygon

`polygon`

137 - MATIC

Manta Pacific Mainnet

`manta`

169 - ETH

X1 Testnet

`x1Testnet`

195 - OKB

X1 Testnet

`xLayerTestnet`

195 - OKB

X Layer Mainnet

`xLayer`

196 - OKB

BitTorrent

`bitTorrent`

199 - BTT

Edgeless Testnet

`edgelessTestnet`

202 - EwETH

Nexilix Smart Chain

`nexilix`

240 - NEXILIX

Fraxtal

`fraxtal`

252 - frxETH

zkSync InMemory Node

`zkSyncInMemoryNode`

260 - ETH

zkSync CLI Local Node

`zkSyncLocalNode`

270 - ETH

zkSync Era Testnet

`zkSyncTestnet`

280 - ETH

Boba Network

`boba`

288 - ETH

Hedera Mainnet

`hedera`

295 - HBAR

Hedera Testnet

`hederaTestnet`

296 - HBAR

Hedera Previewnet

`hederaPreviewnet`

297 - HBAR

zkSync Sepolia Testnet

`zkSyncSepoliaTestnet`

300 - ETH

Filecoin Mainnet

`filecoin`

314 - FIL

zkSync Era

`zkSync`

324 - ETH

Cronos Testnet

`cronosTestnet`

338 - tCRO

PulseChain

`pulsechain`

369 - PLS

Optimism Goerli

`optimismGoerli`

420 - ETH

Areon Network Testnet

`areonNetworkTestnet`

462 - TAREA

Areon Network

`areonNetwork`

463 - AREA

FlowEVM Testnet

`flowTestnet`

545 - FLOW

Rollux Mainnet

`rollux`

570 - SYS

MetaChain Mainnet

`metachain`

571 - MTC

Mandala TC9

`mandala`

595 - mACA

Metis Goerli

`metisGoerli`

599 - METIS

FlowEVM Previewnet

`flowPreviewnet`

646 - FLOW

FlowEVM Mainnet

`flowMainnet`

747 - FLOW

Taraxa Mainnet

`taraxa`

841 - TARA

Taraxa Testnet

`taraxaTestnet`

842 - TARA

Wanchain

`wanchain`

888 - WAN

Mode Testnet

`modeTestnet`

919 - ETH

PulseChain V4

`pulsechainV4`

943 - v4PLS

5ireChain Thunder Testnet

`thunderTestnet`

997 - 5IRE

Wanchain Testnet

`wanchainTestnet`

999 - WANt

Zora Goerli Testnet

`zoraTestnet`

999 - ETH

Klaytn Baobab Testnet

`klaytnBaobab`

1001 - KLAY

Ekta Testnet

`ektaTestnet`

1004 - EKTA

BNB Greenfield Chain

`bscGreenfield`

1017 - BNB

BitTorrent Chain Testnet

`bitTorrentTestnet`

1028 - BTT

Conflux eSpace

`confluxESpace`

1030 - CFX

Bronos Testnet

`bronosTestnet`

1038 - tBRO

Shimmer Testnet

`shimmerTestnet`

1073 - SMR

Polygon zkEVM

`polygonZkEvm`

1101 - ETH

WEMIX Testnet

`wemixTestnet`

1112 - tWEMIX

Core Dao

`coreDao`

1116 - CORE

DeFiChain EVM Mainnet

`defichainEvm`

1130 - DFI

DeFiChain EVM Testnet

`defichainEvmTestnet`

1131 - DFI

Moonbeam Development Node

`moonbeamDev`

1281 - DEV

Moonbeam

`moonbeam`

1284 - GLMR

Moonriver

`moonriver`

1285 - MOVR

Moonbase Alpha

`moonbaseAlpha`

1287 - DEV

Localhost

`localhost`

1337 - ETH

Polygon zkEVM Testnet

`polygonZkEvmTestnet`

1442 - ETH

MetaChain Istanbul

`metachainIstanbul`

1453 - MTC

Horizen Gobi Testnet

`gobi`

1663 - tZEN

Mint Sepolia Testnet

`mintSepoliaTestnet`

1686 - ETH

Reya Network

`reyaNetwork`

1729 - ETH

LightLink Phoenix Mainnet

`lightlinkPhoenix`

1890 - ETH

LightLink Pegasus Testnet

`lightlinkPegasus`

1891 - ETH

Dogechain

`dogechain`

2000 - DC

Telcoin Adiri Testnet

`telcoinTestnet`

2017 - TEL

Edgeware EdgeEVM Mainnet

`edgeware`

2021 - EDG

Saigon Testnet

`saigon`

2021 - RON

Beresheet BereEVM Testnet

`edgewareTestnet`

2022 - tEDG

Edgeless Network

`edgeless`

2026 - EwETH

Kava EVM Testnet

`kavaTestnet`

2221 - KAVA

RSS3 VSL Sepolia Testnet

`rss3Sepolia`

2331 - RSS3

Kroma Sepolia

`kromaSepolia`

2358 - ETH

Polygon zkEVM Cardona

`polygonZkEvmCardona`

2442 - ETH

Fraxtal Testnet

`fraxtalTestnet`

2522 - frxETH

inEVM Mainnet

`inEVM`

2525 - INJ

Morph Sepolia

`morphSepolia`

2710 - ETH

Filecoin Hyperspace

`filecoinHyperspace`

3141 - tFIL

Crossbell

`crossbell`

3737 - CSB

Astar zkEVM

`astarZkEVM`

3776 - ETH

APEX Testnet

`apexTestnet`

3993 - ETH

Fantom Testnet

`fantomTestnet`

4002 - FTM

Oasis Testnet

`oasisTestnet`

4090 - FTN

LUKSO Testnet

`luksoTestnet`

4201 - LYXt

Lisk Sepolia

`liskSepolia`

4202 - ETH

IoTeX Testnet

`iotexTestnet`

4690 - IOTX

MEVerse Chain Testnet

`mevTestnet`

4759 - MEV

BlackFort Exchange Network Testnet

`bxnTestnet`

4777 - TBXN

BlackFort Exchange Network

`bxn`

4999 - BXN

Mantle Testnet

`mantleTestnet`

5001 - MNT

Mantle Sepolia Testnet

`mantleSepoliaTestnet`

5003 - MNT

opBNB Testnet

`opBNBTestnet`

5611 - tBNB

Syscoin Tanenbaum Testnet

`syscoinTestnet`

5700 - SYS

ZetaChain

`zetachain`

7000 - ZETA

ZetaChain Athens Testnet

`zetachainAthensTestnet`

7001 - aZETA

MEVerse Chain Mainnet

`mev`

7518 - MEV

Shardeum Sphinx

`shardeumSphinx`

8082 - SHM

Evmos Testnet

`evmosTestnet`

9000 - EVMOS

OORT MainnetDev

`oortMainnetDev`

9700 - OORT

Gnosis Chiado

`gnosisChiado`

10200 - xDAI

HAQQ Mainnet

`haqqMainnet`

11235 - ISLM

BEVM Mainnet

`bevmMainnet`

11501 - BTC

Fibo Chain

`fibo`

12306 - FIBO

RSS3 VSL Mainnet

`rss3`

12553 - RSS3

Beam Testnet

`beamTestnet`

13337 - BEAM

Immutable zkEVM

`immutableZkEvm`

13371 - IMX

Phoenix Blockchain

`phoenix`

13381 - PHX

Immutable zkEVM Testnet

`immutableZkEvmTestnet`

13473 - IMX

EOS EVM Testnet

`eosTestnet`

15557 - EOS

Holesky

`holesky`

17000 - ETH

Oasis Sapphire

`sapphire`

23294 - ROSE

Oasis Sapphire Testnet

`sapphireTestnet`

23295 - TEST

DreyerX Mainnet

`dreyerxMainnet`

23451 - DRX

Foundry

`foundry`

31337 - ETH

Hardhat

`hardhat`

31337 - ETH

Zilliqa

`zilliqa`

32769 - ZIL

Zilliqa Testnet

`zilliqaTestnet`

33101 - ZIL

Mode Mainnet

`mode`

34443 - ETH

Q Mainnet

`qMainnet`

35441 - Q

Q Testnet

`qTestnet`

35443 - Q

Arbitrum One

`arbitrum`

42161 - ETH

Arbitrum Nova

`arbitrumNova`

42170 - ETH

ZKFair Mainnet

`zkFair`

42766 - USDC

Avalanche Fuji

`avalancheFuji`

43113 - AVAX

Avalanche

`avalanche`

43114 - AVAX

ZKFair Testnet

`zkFairTestnet`

43851 - USDC

Alfajores

`celoAlfajores`

44787 - A-CELO

Yooldo Verse

`yooldoVerse`

50005 - OAS

Yooldo Verse Testnet

`yooldoVerseTestnet`

50006 - OAS

DODOchain Testnet

`dodochainTestnet`

53457 - DODO

DFK Chain

`dfk`

53935 - JEWEL

HAQQ Testedge 2

`haqqTestedge2`

54211 - ISLMT

Rollux Testnet

`rolluxTestnet`

57000 - SYS

PGN

`pgnTestnet`

58008 - ETH

Linea Goerli Testnet

`lineaGoerli`

59140 - ETH

Linea Goerli Testnet

`lineaTestnet`

59140 - ETH

Linea Sepolia Testnet

`lineaSepolia`

59141 - ETH

Linea Mainnet

`linea`

59144 - ETH

Fantom Sonic Open Testnet

`fantomSonicTestnet`

64240 - FTM

Polygon Mumbai

`polygonMumbai`

80001 - MATIC

Polygon Amoy

`polygonAmoy`

80002 - MATIC

Berachain Artio

`berachainTestnet`

80085 - BERA

Base Goerli

`baseGoerli`

84531 - ETH

Base Sepolia

`baseSepolia`

84532 - ETH

Chiliz Spicy Testnet

`spicy`

88882 - CHZ

Chiliz Chain

`chiliz`

88888 - CHZ

Jibchain Testnet

`jbcTestnet`

88991 - tJBC

Vechain

`vechain`

100009 - VET

Stratis Mainnet

`stratis`

105105 - STRAX

Etherlink Testnet

`etherlinkTestnet`

128123 - XTZ

Taiko (Alpha-3 Testnet)

`taikoTestnetSepolia`

167005 - ETH

Taiko Jolnir (Alpha-5 Testnet)

`taikoJolnir`

167007 - ETH

Taiko Katla (Alpha-6 Testnet)

`taikoKatla`

167008 - ETH

Taiko Hekla L2

`taikoHekla`

167009 - ETH

Bitlayer Testnet

`btrTestnet`

200810 - ETH

Auroria Testnet

`auroria`

205205 - tSTRAX

Filecoin Calibration

`filecoinCalibration`

314159 - tFIL

Arbitrum Goerli

`arbitrumGoerli`

421613 - ETH

Arbitrum Sepolia

`arbitrumSepolia`

421614 - ETH

Scroll Sepolia

`scrollSepolia`

534351 - ETH

Scroll Testnet

`scrollTestnet`

534353 - ETH

Bear Network Chain Mainnet

`bearNetworkChainMainnet`

641230 - BRNKC

Sei Devnet

`seiDevnet`

713715 - SEI

Bear Network Chain Testnet

`bearNetworkChainTestnet`

751230 - tBRNKC

Zhejiang

`zhejiang`

1337803 - ZhejETH

PlayFi Albireo Testnet

`playfiAlbireo`

1612127 - ETH

Manta Pacific Testnet

`mantaTestnet`

3441005 - ETH

Manta Pacific Sepolia Testnet

`mantaSepoliaTestnet`

3441006 - ETH

Astar zkEVM Testnet zKyoto

`astarZkyoto`

6038361 - ETH

Sepolia

`sepolia`

11155111 - ETH

OP Sepolia

`optimismSepolia`

11155420 - ETH

Ancient8 Testnet

`ancient8Sepolia`

28122024 - ETH

SKALE Nebula Testnet

`skaleNebulaTestnet`

37084624 - sFUEL

Otim Devnet

`otimDevnet`

41144114 - ETH

Cyber Testnet

`cyberTestnet`

111557560 - ETH

Plume Testnet

`plumeTestnet`

161221135 - ETH

Blast Sepolia

`blastSepolia`

168587773 - ETH

Neon EVM DevNet

`neonDevnet`

245022926 - NEON

Neon EVM MainNet

`neonMainnet`

245022934 - NEON

SKALE | Razor Network

`skaleRazor`

278611351 - sFUEL

SKALE | Block Brawlers

`skaleBlockBrawlers`

391845894 - BRAWL

Degen

`degen`

666666666 - DEGEN

Ancient8

`ancient8`

888888888 - ETH

SKALE Calypso Testnet

`skaleCalypsoTestnet`

974399131 - sFUEL

Zora Sepolia

`zoraSepolia`

999999999 - ETH

SKALE Titan Hub

`skaleTitanTestnet`

1020352220 - sFUEL

SKALE | CryptoBlades

`skaleCryptoBlades`

1026062157 - sFUEL

SKALE | Crypto Colosseum

`skaleCryptoColosseum`

1032942172 - sFUEL

SKALE | Human Protocol

`skaleHumanProtocol`

1273227453 - sFUEL

Aurora

`aurora`

1313161554 - ETH

Aurora Testnet

`auroraTestnet`

1313161555 - ETH

SKALE | Titan Community Hub

`skaleTitan`

1350216234 - sFUEL

SKALE Europa Testnet

`skaleEuropaTestnet`

1444673419 - sFUEL

SKALE | Nebula Gaming Hub

`skaleNebula`

1482601649 - sFUEL

SKALE | Calypso NFT Hub

`skaleCalypso`

1564830818 - sFUEL

Harmony One

`harmonyOne`

1666600000 - ONE

SKALE | Europa Liquidity Hub

`skaleEuropa`

2046399126 - sFUEL

SKALE | Exorde

`skaleExorde`

2139927552 - sFUEL

Palm Testnet

`palmTestnet`

11297108099 - PALM

Palm

`palm`

11297108109 - PALM

Kakarot Sepolia

`kakarotSepolia`

107107114116 - ETH

Create Chain [‚Äã](#create-chain)
-------------------------------

Import the `Chain` type from Viem and create a new object that is asserted `as const` and `satisfies` the type. You can also use the `defineChain` function from Viem.

as const satisfies ChaindefineChain

ts

    import { type  } from 'viem'
    
    export const  = {} as  satisfies Type '{}' does not satisfy the expected type 'Chain'.
      Type '{}' is missing the following properties from type 'Chain': id, name, nativeCurrency, rpcUrls

ts

    import {  } from 'viem'
    
    export const  = ({})Argument of type '{}' is not assignable to parameter of type 'Chain<ChainFormatters>'.
      Type '{}' is missing the following properties from type 'Chain<ChainFormatters>': id, name, nativeCurrency, rpcUrls

Now, add the missing required properties to the object until the error goes away.

as const satisfies ChaindefineChain

ts

    import { type  } from 'viem'
    
    export const  = {
      : 1,
      : 'Ethereum',
      : { : 'Ether', : 'ETH', : 18 },
      : {
        : { : ['https://eth.merkle.io'] },
      },
      : {
        : { : 'Etherscan', : 'https://etherscan.io' },
      },
      : {
        : {
          : '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        : {
          : '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
          : 16773775,
        },
        : {
          : '0xca11bde05977b3631167028862be2a173976ca11',
          : 14353601,
        },
      },
    } as  satisfies 

ts

    import {  } from 'viem'
    
    export const  = ({
      : 1,
      : 'Ethereum',
      : { : 'Ether', : 'ETH', : 18 },
      : {
        : { : ['https://eth.merkle.io'] },
      },
      : {
        : { : 'Etherscan', : 'https://etherscan.io' },
      },
      : {
        : {
          : '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        : {
          : '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
          : 16773775,
        },
        : {
          : '0xca11bde05977b3631167028862be2a173976ca11',
          : 14353601,
        },
      },
    })

The more properties you add, the better the chain will be to use with Wagmi. Most of these attributes exist within the [`ethereum-lists/chains` repository](https://github.com/ethereum-lists/chains/tree/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains).

*   `id`: The chain ID for the network. This can be found by typing the network name into [ChainList](https://chainlist.org/). Example: "Ethereum Mainnet" has a Chain ID of `1`.
*   `name`: Human-readable name for the chain. Example: "Ethereum Mainnet"
*   `nativeCurrency`: The native currency of the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L20-L24).
*   `rpcUrls`: At least one public, credible RPC URL. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L4-L18).
*   `blockExplorers`: A set of block explorers for the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L30-L36).
*   `contracts`: A set of deployed contracts for the chain. If you are deploying one of the following contracts yourself, make sure it is verified.
    *   `multicall3` is optional, but it's address is most likely `0xca11bde05977b3631167028862be2a173976ca11` ‚Äì you can find the deployed block number on the block explorer. Check out [`mds1/multicall`](https://github.com/mds1/multicall#multicall3-contract-addresses) for more info.
    *   `ensRegistry` is optional ‚Äì not all Chains have a ENS Registry. See [ENS Deployments](https://docs.ens.domains/ens-deployments) for more info.
    *   `ensUniversalResolver` is optional ‚Äì not all Chains have a ENS Universal Resolver.
*   `sourceId`: Source Chain ID (e.g. the L1 chain).
*   `testnet`: Whether or not the chain is a testnet.</content>
</page>

<page>
  <title>Connectors | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors</url>
  <content>Released under the [MIT License](https://github.com/wevm/wagmi/blob/main/LICENSE).

Copyright ¬© 2022-present Weth, LLC</content>
</page>

<page>
  <title>Migrate from v1 to v2</title>
  <url>https://wagmi.sh/core/guides/migrate-from-v1-to-v2</url>
  <content>Wagmi Core v2 redesigns the core APIs to mesh better with [Viem](https://viem.sh/). This major version transforms Wagmi into a light wrapper around Viem, sprinkling in multichain support and account management. As such, there are some breaking changes and deprecations to be aware of outlined in this guide.

To get started, install the latest version of Wagmi and it's required peer dependencies.

pnpmnpmyarnbun

bash

    pnpm add @wagmi/core viem@2.x @wagmi/connectors

bash

    npm install @wagmi/core viem@2.x @wagmi/connectors

bash

    yarn add @wagmi/core viem@2.x @wagmi/connectors

bash

    bun add @wagmi/core viem@2.x @wagmi/connectors

Wagmi Core v2 should be the last major version that will have this many actionable breaking changes.

Moving forward, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Not ready to migrate yet?

The Wagmi Core v1 docs are still available at [1.x.wagmi.sh/core](https://1.x.wagmi.sh/core).

Dependencies [‚Äã](#dependencies)
-------------------------------

### Dropped CommonJS support [‚Äã](#dropped-commonjs-support)

Wagmi v2 no longer publishes a separate `cjs` tag since very few people use this tag and ESM is the future. See [Sindre Sorhus' guide](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c) for more info about switching to ESM.

Actions [‚Äã](#actions)
---------------------

### Removed `config` singleton [‚Äã](#removed-config-singleton)

Before v2, when you called [`createConfig`](https://wagmi.sh/core/api/createConfig), it set a global `config` singleton that was used internally by actions. For v2, `config` is now a required first parameter for actions.

index.tsconfig.ts

ts

    import { getAccount, readContract } from '@wagmi/core'
    import { parseAbi } from 'viem'
    import { config } from './config'
    
    const account = getAccount()
    const account = getAccount(config)
    
    const balanceOf = readContract({ 
    const balanceOf = readContract(config, { 
      address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
      abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
      functionName: 'balanceOf',
      args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

The previous global `config` singleton made it so you couldn't use multiple `Config` objects in the same project. In addition, we think passing `config` is more explicit and makes it easier to understand what's going on. Finally, types can be inferred directly from the `config`, like [chain properties](https://wagmi.sh/core/guides/chain-properties) and more.

### Removed `getContract` [‚Äã](#removed-getcontract)

Removed `getContract` export. Use Viem's [`getContract`](https://viem.sh/docs/contract/getContract.html) instead.

ts

    import { getContract } from '@wagmi/core'
    import { getContract } from 'viem'
    
    const contract = getContract()
    const contract = getContract()

### Removed `getNetwork` and `watchNetwork` [‚Äã](#removed-getnetwork-and-watchnetwork)

The `getNetwork` and `watchNetwork` actions were removed since the connected chain is typically based on the connected account.

*   Use [`config.chains`](https://wagmi.sh/core/api/createConfig#chains-1) instead to get `chains`.
    
    index.tsconfig.ts
    
    ts
    
        import { getNetwork } from '@wagmi/core'
        
        const { chains } = getNetwork()
        const chains = config.chains
    
    ts
    
        import { http, createConfig } from '@wagmi/core'
        import { mainnet, sepolia } from '@wagmi/core/chains'
        
        export const config = createConfig({
          chains: [mainnet, sepolia],
          transports: {
            [mainnet.id]: http(),
            [sepolia.id]: http(),
          },
        })
    
*   Use [`getAccount`](https://wagmi.sh/core/api/actions/getAccount) and `config.chains` instead to get `chain`.
    
    index.tsconfig.ts
    
    ts
    
        import { getNetwork } from '@wagmi/core'
        import { getAccount } from '@wagmi/core'
        import { config } from './config'
        
        const { chain } = getNetwork()
        const { chainId } = getAccount(config)
        const chain = chains.find(chain => chain.id === chainId)
    
    ts
    
        import { http, createConfig } from '@wagmi/core'
        import { mainnet, sepolia } from '@wagmi/core/chains'
        
        export const config = createConfig({
          chains: [mainnet, sepolia],
          transports: {
            [mainnet.id]: http(),
            [sepolia.id]: http(),
          },
        })
    
    Before v2, `getNetwork().chain` could result in an invalid chain if the active connector's `chainId` was not configured in the list of `config.chains`. Using `getAccount` and `config.chains` is more work, but ensures that chain is either valid or not defined. You can also use `getAccount(config).chain` if you don't care about the chain being `undefined` when not configured.
    
*   Use `watchAccount` instead of `watchNetwork`.
    
    index.tsconfig.ts
    
    ts
    
        import { watchNetwork } from '@wagmi/core'
        import { watchAccount } from '@wagmi/core'
        import { config } from './config'
        
        const unwatch = watchNetwork((data) => console.log('Changed!', data))
        const unwatch = watchAccount(config, { 
          onChange(data) { 
            const chains = config.chains
            const chain = chains.find(chain => chain.id === data.chainId)
          }, 
        })
    
    ts
    
        import { http, createConfig } from '@wagmi/core'
        import { mainnet, sepolia } from '@wagmi/core/chains'
        
        export const config = createConfig({
          chains: [mainnet, sepolia],
          transports: {
            [mainnet.id]: http(),
            [sepolia.id]: http(),
          },
        })
    

### Removed `getWebSocketPublicClient` and `watchWebSocketPublicClient` [‚Äã](#removed-getwebsocketpublicclient-and-watchwebsocketpublicclient)

Viem [Transports](https://viem.sh/docs/clients/intro.html#transports) now determine the type of client that is returned. You can use [`getPublicClient`](https://wagmi.sh/core/api/actions/getPublicClient) and [`watchPublicClient`](https://wagmi.sh/core/api/actions/watchPublicClient) to retrieve Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instances.

Alternatively, you can use [`getClient`](https://wagmi.sh/core/api/actions/getClient) and [`watchClient`](https://wagmi.sh/core/api/actions/watchClient) to retrieve plain Viem [`Client`](https://viem.sh/docs/clients/custom.html) instances. This is a better option for users that care about optimizing bundle size to be as small as possible.

### Removed `watchReadContract`, `watchReadContracts`, and `watchReadMulticall` [‚Äã](#removed-watchreadcontract-watchreadcontracts-and-watchreadmulticall)

Use [`watchBlockNumber`](https://wagmi.sh/core/api/actions/watchBlockNumber) along with [`readContract`](https://wagmi.sh/core/api/actions/readContract), [`readContracts`](https://wagmi.sh/core/api/actions/readContracts), and [`multicall`](https://wagmi.sh/core/api/actions/multicall) actions instead. Before v2, `watchReadContract`, `watchReadContracts`, and `watchReadMulticall` were all wrappers around `watchBlockNumber` and this simplifies the API.

index.tsconfig.ts

ts

    import { watchReadContract } from '@wagmi/core'
    import { watchBlockNumber, readContract } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchReadContract(
      { 
        address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', 
        abi: parseAbi(['function balanceOf(address) view returns (uint256)']), 
        functionName: 'balanceOf', 
        args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], 
      },
      (result) => console.log('Changed!', result),
    )
    const unwatch = watchBlockNumber(config, { 
      onBlockNumber() { 
        const balanceOf = readContract(config, { 
          address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', 
          abi: parseAbi(['function balanceOf(address) view returns (uint256)']), 
          functionName: 'balanceOf', 
          args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], 
        })
        console.log('Changed!', balanceOf)
      }, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### Removed `fetchFeeData` [‚Äã](#removed-fetchfeedata)

Removed `fetchFeeData`. Use [`estimateFeesPerGas`](https://wagmi.sh/core/api/actions/estimateFeesPerGas) instead.

index.tsconfig.ts

ts

    import { fetchFeeData } from '@wagmi/core'
    import { estimateFeesPerGas } from '@wagmi/core'
    import { config } from './config'
    
    const result = await fetchFeeData()
    const result = await estimateFeesPerGas(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### Removed `prepareWriteContract` [‚Äã](#removed-preparewritecontract)

Removed `prepareWriteContract`. Use [`simulateContract`](https://wagmi.sh/core/api/actions/simulateContract) instead.

index.tsconfig.ts

ts

    import { prepareWriteContract } from '@wagmi/core'
    import { simulateContract } from '@wagmi/core'
    import { config } from './config'
    
    const result = await prepareWriteContract({ ... })
    const result = await simulateContract(config, { ... })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### Removed `prepareSendTransaction` [‚Äã](#removed-preparesendtransaction)

Removed `prepareSendTransaction`. Use [`estimateGas`](https://wagmi.sh/core/api/actions/estimateGas) instead.

index.tsconfig.ts

ts

    import { prepareSendTransaction } from '@wagmi/core'
    import { estimateGas } from '@wagmi/core'
    import { config } from './config'
    
    const result = await prepareSendTransaction({ ... })
    const result = await estimateGas(config, { ... })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### Updated `sendTransaction` and `writeContract` return type [‚Äã](#updated-sendtransaction-and-writecontract-return-type)

Updated [`sendTransaction`](https://wagmi.sh/core/api/actions/sendTransaction) and [`writeContract`](https://wagmi.sh/core/api/actions/writeContract) return type from ``{ hash: `0x${string}` }`` to `` `0x${string}` ``.

ts

    const result = await sendTransaction({ hash: '0x...' })
    result.hash
    result

### Updated `connect` return type [‚Äã](#updated-connect-return-type)

Updated [`connect`](https://wagmi.sh/core/api/actions/connect) return type from `{ account: Address; chain: { id: number; unsupported?: boolean }; connector: Connector }` to `{ accounts: readonly Address[]; chainId: number }`. This better reflects the ability to have multiple accounts per connector.

### Renamed parameters and return types [‚Äã](#renamed-parameters-and-return-types)

All hook parameters and return types follow the naming pattern of `[PascalCaseActionName]Parameters` and `[PascalCaseActionName]ReturnType`. For example, `GetAccountParameters` and `GetAccountReturnType`.

ts

    import { GetAccountConfig, GetAccountResult } from '@wagmi/core'
    import { GetAccountParameters, GetAccountReturnType } from '@wagmi/core'

Connectors [‚Äã](#connectors)
---------------------------

### Moved Wagmi Connectors to peer dependencies [‚Äã](#moved-wagmi-connectors-to-peer-dependencies)

Wagmi Core v2 no longer exports connectors via the `'@wagmi/core/connectors/*'` entrypoints. Instead, you should install the `@wagmi/connectors` package.

pnpmnpmyarnbun

bash

    pnpm add @wagmi/connectors

bash

    npm install @wagmi/connectors

bash

    yarn add @wagmi/connectors

bash

    bun add @wagmi/connectors

And import connectors from there.

ts

    import { injected } from '@wagmi/connectors'

See the [connectors documentation](https://wagmi.sh/core/api/connectors) for more information.

### Updated connector API [‚Äã](#updated-connector-api)

In order to maximize type-safety and ease of creating connectors, the connector API changed. Follow the [Creating Connectors guide](https://wagmi.sh/dev/creating-connectors) for more info on creating new connectors and converting Wagmi v1 connectors.

### Removed individual entrypoints [‚Äã](#removed-individual-entrypoints)

Previously, each connector had its own entrypoint to optimize tree-shaking. Since all connectors now have [`package.json#sideEffects`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) enabled, this is no longer necessary and the entrypoint is unified. Use the `'@wagmi/connectors'` package instead.

ts

    import { InjectedConnector } from '@wagmi/core/connectors/injected'
    import { CoinbaseWalletConnector } from '@wagmi/core/connectors/coinbaseWallet'
    import { coinbaseWallet, injected } from '@wagmi/connectors'

### Removed `MetaMaskConnector` [‚Äã](#removed-metamaskconnector)

The `MetaMaskConnector` was removed since it was nearly the same thing as the `InjectedConnector`. Use the [`injected`](https://wagmi.sh/core/api/connectors/injected) connector instead, along with the [`target`](https://wagmi.sh/core/api/connectors/injected#target) parameter set to `'metaMask'`, for the same behavior.

ts

    import { MetaMaskConnector } from '@wagmi/core/connectors/metaMask'
    import { injected } from '@wagmi/connectors'
    
    const connector = new MetaMaskConnector()
    const connector = injected({ target: 'metaMask' })

### Renamed connectors [‚Äã](#renamed-connectors)

In Wagmi v1, connectors were classes you needed to instantiate. In Wagmi v2, connectors are functions. As a result, the API has changed. Connectors have the following new names:

*   `CoinbaseWalletConnector` is now [`coinbaseWallet`](https://wagmi.sh/core/api/connectors/coinbaseWallet).
*   `InjectedConnector` is now [`injected`](https://wagmi.sh/core/api/connectors/injected).
*   `SafeConnector` is now [`safe`](https://wagmi.sh/core/api/connectors/safe).
*   `WalletConnectConnector` is now [`walletConnect`](https://wagmi.sh/core/api/connectors/walletConnect).

To create a connector, you now call the connector function with parameters.

ts

    import { WalletConnectConnector } from '@wagmi/core/connectors/walletConnect'
    import { walletConnect } from '@wagmi/connectors'
    
    const connector = new WalletConnectConnector({ 
    const connector = walletConnect({ 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### Removed `WalletConnectLegacyConnector` [‚Äã](#removed-walletconnectlegacyconnector)

WalletConnect v1 was sunset June 28, 2023. Use the [`walletConnect`](https://wagmi.sh/core/api/connectors/walletConnect) connector instead.

ts

    import { WalletConnectLegacyConnector } from '@wagmi/core/connectors/walletConnectLegacy'
    import { walletConnect } from '@wagmi/connectors'
    
    const connector = new WalletConnectLegacyConnector({ 
    const connector = walletConnect({ 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

Chains [‚Äã](#chains)
-------------------

### Updated `'@wagmi/core/chains'` entrypoint [‚Äã](#updated-wagmi-core-chains-entrypoint)

Chains now live in the [Viem repository](https://github.com/wevm/viem). As a result, the `'@wagmi/core/chains'` entrypoint now proxies all chains from `'viem/chains'` directly.

### Removed `mainnet` and `sepolia` from main entrypoint [‚Äã](#removed-mainnet-and-sepolia-from-main-entrypoint)

Since the `'@wagmi/core/chains'` entrypoint now proxies `'viem/chains'`, `mainnet` and `sepolia` were removed from the main entrypoint. Use the `'@wagmi/core/chains'` entrypoint instead.

ts

    import { mainnet, sepolia } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'

Errors [‚Äã](#errors)
-------------------

A number of errors were renamed to better reflect their functionality or replaced by Viem errors.

Miscellaneous [‚Äã](#miscellaneous)
---------------------------------

### Removed internal ENS normalization [‚Äã](#removed-internal-ens-normalization)

Before v2, Wagmi handled ENS name normalization internally for `getEnsAddress`, `getEnsAvatar`, and `getEnsResolver`, using Viem's [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function. This added extra bundle size as full normalization is quite heavy. For v2, you must normalize ENS names yourself before passing them to these actions. You can use Viem's `normalize` function or any other function that performs [UTS-46 normalization](https://unicode.org/reports/tr46).

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem'
    import { config } from './config'
    
    const result = await getEnsAddress(config, {
      name: 'wevm.eth', 
      name: normalize('wevm.eth'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

By inverting control, Wagmi lets you choose how much normalization to do. For example, maybe your project only allows ENS names that are numeric so no normalization is not needed. Check out the [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) for more information on normalizing names.

### Removed `configureChains` [‚Äã](#removed-configurechains)

The Wagmi v2 `Config` now has native multichain support using the [`chains`](https://wagmi.sh/core/api/createConfig) parameter so the `configureChains` function is no longer required.

ts

    import { configureChains, createConfig } from '@wagmi/core'
    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    const { chains, publicClient } = configureChains(
      [mainnet, sepolia],
      [publicProvider(), publicProvider()],
    )
    
    export const config = createConfig({
      publicClient, 
      chains: [mainnet, sepolia], 
      transports: { 
        [mainnet.id]: http(), 
        [sepolia.id]: http(), 
      }, 
    })

### Removed ABI exports [‚Äã](#removed-abi-exports)

Import from Viem instead.

ts

    import { erc20ABI } from '@wagmi/core'
    import { erc20Abi } from 'viem'

### Removed `'@wagmi/core/providers/*` entrypoints [‚Äã](#removed-wagmi-core-providers-entrypoints)

It never made sense that we would have provider URLs hardcoded in the Wagmi codebase. Use [Viem transports](https://viem.sh/docs/clients/intro.html#transports) along with RPC provider URLs instead.

ts

    import { alchemyProvider } from '@wagmi/core/providers/alchemy'
    import { http } from 'viem'
    
    const transport = http('https://mainnet.example.com')

### Updated `createConfig` parameters [‚Äã](#updated-createconfig-parameters)

*   Removed `autoConnect`. The reconnecting behavior must be managed manually and is not related to the Wagmi `Config`. Use the [`reconnect`](https://wagmi.sh/core/api/actions/reconnect) action instead.
*   Removed `publicClient` and `webSocketPublicClient`. Use [`transports`](https://wagmi.sh/core/api/createConfig#transports) or [`client`](https://wagmi.sh/core/api/createConfig#client) instead.
*   Removed `logger`. Wagmi no longer logs debug information to console.

### Updated `Config` object [‚Äã](#updated-config-object)

*   Removed `config.connector`. Use `config.state.connections.get(config.state.current)?.connector` instead.
*   Removed `config.data`. Use `config.state.connections.get(config.state.current)` instead.
*   Removed `config.error`. Was unused and not needed.
*   Removed `config.lastUsedChainId`. Use `config.state.connections.get(config.state.current)?.chainId` instead.
*   Removed `config.publicClient`. Use [`config.getClient()`](https://wagmi.sh/core/api/createConfig#getclient) or [`getPublicClient`](https://wagmi.sh/core/api/actions/getPublicClient) instead.
*   Removed `config.status`. Use [`config.state.status`](https://wagmi.sh/core/api/createConfig#status) instead.
*   Removed `config.webSocketClient`. Use [`config.getClient()`](https://wagmi.sh/core/api/createConfig#getclient) or [`getPublicClient`](https://wagmi.sh/core/api/actions/getPublicClient) instead.
*   Removed `config.clearState`. Was unused and not needed.
*   Removed `config.autoConnect()`. Use [`reconnect`](https://wagmi.sh/core/api/actions/reconnect) action instead.
*   Renamed `config.setConnectors`. Use `config._internal.setConnectors` instead.
*   Removed `config.setLastUsedConnector`. Use `config.storage?.setItem('recentConnectorId', connectorId)` instead.
*   Removed `getConfig`. `config` should be passed explicitly to actions instead of using global `config`.

Deprecations [‚Äã](#deprecations)
-------------------------------

### Deprecated `getBalance` `token` parameter [‚Äã](#deprecated-getbalance-token-parameter)

Moving forward, `getBalance` will only work for native currencies, thus the `token` parameter is no longer supported. Use [`readContracts`](https://wagmi.sh/core/api/actions/readContracts) instead.

ts

    import { getBalance } from '@wagmi/core'
    import { readContracts } from '@wagmi/core'
    import { erc20Abi } from 'viem'
    import { config } from './config'
    
    const result = await getBalance(config, { 
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48', 
      token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })
    const result = await readContracts(config, { 
      allowFailure: false, 
      contracts: [ 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'balanceOf', 
          args: ['0x4557B18E779944BFE9d78A672452331C186a9f48'], 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'decimals', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'symbol', 
        }, 
      ] 
    })

### Deprecated `getBalance` `unit` parameter and `formatted` return value [‚Äã](#deprecated-getbalance-unit-parameter-and-formatted-return-value)

Moving forward, `getBalance` will not accept the `unit` parameter or return a `formatted` value. Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

ts

    import { formatUnits } from 'viem'
    import { getBalance } from '@wagmi/core'
    
    const result = await getBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      unit: 'ether', 
    })
    result.formatted
    formatUnits(result.value, result.decimals)

### Deprecated `getToken` [‚Äã](#deprecated-gettoken)

Moving forward, `getToken` is no longer supported. Use [`readContracts`](https://wagmi.sh/core/api/actions/readContracts) instead.

ts

    import { getToken } from '@wagmi/core'
    import { readContracts } from '@wagmi/core'
    import { erc20Abi } from 'viem'
    import { config } from './config'
    
    const result = await getToken(config, { 
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })
    const result = await readContracts(config, { 
      allowFailure: false, 
      contracts: [ 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'decimals', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'name', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'symbol', 
        }, 
        { 
          address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
          abi: erc20Abi, 
          functionName: 'totalSupply', 
        }, 
      ] 
    })

### Deprecated `formatUnits` parameters and return values [‚Äã](#deprecated-formatunits-parameters-and-return-values)

The `formatUnits` parameter and related return values (e.g. `result.formatted`) are deprecated for the following actions:

*   [`estimateFeesPerGas`](https://wagmi.sh/core/api/actions/estimateFeesPerGas)
*   [`getToken`](https://wagmi.sh/core/api/actions/getToken)

Instead you can call `formatUnits` from Viem directly or use another number formatting library, like [dnum](https://github.com/bpierre/dnum) instead.

ts

    import { formatUnits } from 'viem'
    import { getToken } from '@wagmi/core'
    
    const result = await getToken({
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
      formatUnits: 'ether',
    })
    result.totalSupply.formatted
    formatUnits(result.totalSupply.value, 18)

This allows us to invert control to users so they can handle number formatting however they want, taking into account precision, localization, and more.

### Renamed actions [‚Äã](#renamed-actions)

The following actions were renamed to better reflect their functionality and underlying [Viem](https://viem.sh/) actions:

*   `fetchBalance` is now [`getBalance`](https://wagmi.sh/core/api/actions/getBalance)
*   `fetchBlockNumber` is now [`getBlockNumber`](https://wagmi.sh/core/api/actions/getBlockNumber)
*   `fetchEnsAddress` is now [`getEnsAddress`](https://wagmi.sh/core/api/actions/getEnsAddress)
*   `fetchEnsAvatar` is now [`getEnsAvatar`](https://wagmi.sh/core/api/actions/getEnsAvatar)
*   `fetchEnsName` is now [`getEnsName`](https://wagmi.sh/core/api/actions/getEnsName)
*   `fetchEnsResolver` is now [`getEnsResolver`](https://wagmi.sh/core/api/actions/getEnsResolver)
*   `fetchToken` is now [`getToken`](https://wagmi.sh/core/api/actions/getToken)
*   `fetchTransaction` is now [`getTransaction`](https://wagmi.sh/core/api/actions/getTransaction)
*   `switchNetwork` is now [`switchChain`](https://wagmi.sh/core/api/actions/switchChain)
*   `waitForTransaction` is now [`waitForTransactionReceipt`](https://wagmi.sh/core/api/actions/waitForTransactionReceipt)</content>
</page>

<page>
  <title>coinbaseWallet | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors/coinbaseWallet</url>
  <content>Connector for the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk).

Import [‚Äã](#import)
-------------------

ts

    import { coinbaseWallet } from '@wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { coinbaseWallet } from '@wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [coinbaseWallet()], 
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Before going to production, it is highly recommended to set an [`appName`](#appname) and [`appLogoUrl`](#applogourl) for your application that can be displayed upon connection to the wallet.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CoinbaseWalletParameters } from '@wagmi/connectors'

Check out the [Coinbase Wallet SDK docs](https://github.com/coinbase/coinbase-wallet-sdk) for more info.

### appName [‚Äã](#appname)

`string`

Application name.

ts

    import { coinbaseWallet } from '@wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App', 
    })

### appLogoUrl [‚Äã](#applogourl)

`string | null | undefined`

Application logo image URL; favicon is used if unspecified.

ts

    import { coinbaseWallet } from '@wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      appLogoUrl: 'https://example.com/myLogoUrl.png', 
    })

### headlessMode deprecated [‚Äã](#headlessmode)

`boolean | undefined`

*   Whether or not onboarding overlay popup should be displayed.
*   `headlessMode` will be removed in the next major version. Upgrade to [`version: '4'`](#version).

ts

    import { coinbaseWallet } from '@wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      headlessMode: false, 
    })

### preference \>=2.9.0 [‚Äã](#preference)

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

*   `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
*   `'smartWalletOnly'`: Displays Smart Wallet popup.
*   `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

ts

    import { coinbaseWallet } from '@wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      preference: 'smartWalletOnly', 
    })

WARNING

Passing `preference` as a string is deprecated and will be removed in the next major version. Instead you should use [`preference#options`](#options).

ts

    import { coinbaseWallet } from '@wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      preference: { 
        options: 'smartWalletOnly'
      }, 
    })

#### attribution \>=2.12.33 [‚Äã](#attribution)

``{ auto?: boolean | undefined; dataSuffix?: `0x${string}` | undefined }``

This option only applies to Coinbase Smart Wallet. When a valid data suffix is supplied, it is appended to the `initCode` and `executeBatch` calldata. Coinbase Smart Wallet expects a 16 byte hex string. If the data suffix is not a 16 byte hex string, the Smart Wallet will ignore the property. If auto is true, the Smart Wallet will generate a 16 byte hex string from the apps origin.

#### keysUrl \>=2.12.33 [‚Äã](#keysurl)

`string`

*   The URL for the keys popup.
*   By default, `https://keys.coinbase.com/connect` is used for production. Use `https://keys-dev.coinbase.com/connect` for development environments.

#### options \>=2.12.33 [‚Äã](#options)

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

*   `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
*   `'smartWalletOnly'`: Displays Smart Wallet popup.
*   `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

### version \>=2.13.0 [‚Äã](#version)

*   Coinbase Wallet SDK version
*   Defaults to `'4'`. If [`headlessMode: true`](#headlessmode), defaults to `'3'`.

ts

    import { coinbaseWallet } from '@wagmi/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      version: '4', 
    })</content>
</page>

<page>
  <title>metaMask | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors/metaMask</url>
  <content>Connector for [MetaMask SDK](https://github.com/MetaMask/metamask-sdk).

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/metamask-sdk/javascript) for more information.

Import [‚Äã](#import)
-------------------

ts

    import { metaMask } from '@wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { metaMask } from '@wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [metaMask()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MetaMaskParameters } from '@wagmi/connectors'

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/3rd-party-libraries/wagmi/) for more info. A few options are omitted that Wagmi manages internally.

### dappMetadata [‚Äã](#dappmetadata)

`DappMetadata | undefined`

Metadata is used to fill details for the UX on confirmation screens in MetaMask, including the following fields:

*   `name`: `string` - The name of the dapp.
*   `url`: `string` - URL of the dapp (defaults to `window.location.origin`).
*   `iconUrl`: `string` - URL to the dapp's favicon or icon.

ts

    import { metaMask } from '@wagmi/connectors'
    
    const connector = metaMask({
      dappMetadata: { 
        name: 'My Wagmi App', 
        url: 'https://example.com', 
        iconUrl: 'https://example.com/favicon.ico', 
      }
    })

### logging [‚Äã](#logging)

`SDKLoggingOptions | undefined`

Enables SDK-side logging to provide visibility into:

*   RPC methods being called.
*   Events received for syncing the chain or active account.
*   Raw RPC responses.

In this context, this is especially useful to observe what calls are made through Wagmi hooks.

Relevant options:

ts

    {
      developerMode: boolean, // Enables developer mode logs
      sdk: boolean           // Enables SDK-specific logs
    }

ts

    import { metaMask } from '{{connectorsPackageName}}'
    
    const connector = metaMask({
      logging: { developerMode: true, sdk: true } 
    })

### headless [‚Äã](#headless)

`boolean | undefined`

*   Enables headless mode, disabling MetaMask's built-in modal.
*   Allows developers to create their own modal, such as for displaying a QR code.

This is particularly relevant for web-only setups using Wagmi, where developers want complete control over the UI.

To get the deeplink to display in the QR code, listen to the `display_uri` event.

The default is `false`.

ts

    import { metaMask } from '@wagmi/connectors'
    
    const connector = metaMask({
      headless: true
    })

Advanced [‚Äã](#advanced)
-----------------------

By default, if the EIP-6963 MetaMask injected provider is detected, this connector will replace it.

EIP-6963 defines a standard way for dapps to interact with multiple wallets simultaneously by injecting providers into the browser. Wallets that implement this standard can make their presence known to dapps in a consistent and predictable manner.

When MetaMask SDK detects an EIP-6963-compliant provider (such as MetaMask itself), the connector will automatically replace the default injected provider (like `window.ethereum`) with the one provided by MetaMask SDK.

See the [`rdns` property](https://wagmi.sh/dev/creating-connectors#properties) for more information.</content>
</page>

<page>
  <title>mock | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors/mock</url>
  <content>Connector for mocking Wagmi functionality.

Import [‚Äã](#import)
-------------------

ts

    import { mock } from '@wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { mock } from '@wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [
        mock({
          accounts: [
            '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
            '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
            '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
          ],
        }),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MockParameters } from '@wagmi/connectors'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Accounts to use with the connector.

ts

    import { mock } from '@wagmi/connectors'
    
    const connector = mock({
      accounts: [ 
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', 
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', 
        '0x90F79bf6EB2c4f870365E785982E1f101E93b906', 
        '0x15d34aaf54267db7d7c367839aaf71a00a2c6a65', 
        '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', 
        '0x976EA74026E726554dB657fA54763abd0C3a0aa9', 
        '0x14dC79964da2C08b23698B3D3cc7Ca32193d9955', 
        '0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f', 
        '0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', 
      ], 
    })

### features [‚Äã](#features)

`{ connectError?: boolean | Error | undefined; reconnect?: boolean | undefined; signMessageError?: boolean | Error | undefined; signTypedDataError?: boolean | Error | undefined; switchChainError?: boolean | Error | undefined; } | undefined`

Feature flags that change behavior of Wagmi internals.

ts

    import { mock } from '@wagmi/connectors'
    import { UserRejectedRequestError } from 'viem'
    
    const connector = mock({
      accounts: [
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
      ],
      features: { 
        connectError: new UserRejectedRequestError(new Error('Failed to connect.')), 
        reconnect: false, 
      }, 
    })

#### defaultConnected [‚Äã](#defaultconnected)

`boolean | undefined`

Whether the connector is connected by default.

#### connectError [‚Äã](#connecterror)

`boolean | Error | undefined`

Whether to throw an error when `connector.connect` is called.

#### reconnect [‚Äã](#reconnect)

`boolean | undefined`

Enables reconnecting to connector.

#### signMessageError [‚Äã](#signmessageerror)

`boolean | Error | undefined`

Whether to throw an error when `'personal_sign'` is called.

#### signTypedDataError [‚Äã](#signtypeddataerror)

`boolean | Error | undefined`

Whether to throw an error when `'eth_signTypedData_v4'` is called.

#### switchChainError [‚Äã](#switchchainerror)

`boolean | Error | undefined`

Whether to throw an error when `connector.switchChain` is called.</content>
</page>

<page>
  <title>walletConnect | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors/walletConnect</url>
  <content>Connector for [WalletConnect](https://walletconnect.com/).

Import [‚Äã](#import)
-------------------

ts

    import { walletConnect } from '@wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { walletConnect } from '@wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [
        walletConnect({
          projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
        }),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WalletConnectParameters } from '@wagmi/connectors'

Check out the [WalletConnect docs](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/providers/ethereum-provider) for more info. A few options are omitted that Wagmi manages internally.

### customStoragePrefix @wagmi/connectors@>=5.1.8 [‚Äã](#customstorageprefix)

`string | undefined`

Custom storage prefix for persisting provider state.

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      customStoragePrefix: 'wagmi', 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### disableProviderPing [‚Äã](#disableproviderping)

`boolean | undefined`

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      disableProviderPing: false, 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### isNewChainsStale [‚Äã](#isnewchainsstale)

`boolean | undefined`

*   If a new chain is added to a previously existing configured connector `chains`, this flag will determine if that chain should be considered as stale. A stale chain is a chain that WalletConnect has yet to establish a relationship with (e.g. the user has not approved or rejected the chain).
*   Defaults to `true`.

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      isNewChainsStale: true, 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

More info

Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when a user tries to switch to a chain that they have not approved.

This flag mainly affects the behavior when a wallet does not support dynamic chain authorization with WalletConnect v2.

If `true` (default), the new chain will be treated as a stale chain. If the user has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect session, the connector will disconnect upon the dapp auto-connecting, and the user will have to reconnect to the dapp (revalidate the chain) in order to approve the newly added chain. This is the default behavior to avoid an unexpected error upon switching chains which may be a confusing user experience (e.g. the user will not know they have to reconnect unless the dapp handles these types of errors).

If `false`, the new chain will be treated as a validated chain. This means that if the user has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully auto-connect the user. This comes with the trade-off that the connector will throw an error when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly modifies their configured chains, and they do not want to disconnect the user upon auto-connecting. If the user decides to switch to the unapproved chain, it is important that the dapp handles this error and prompts the user to reconnect to the dapp in order to approve the newly added chain.

### metadata [‚Äã](#metadata)

`CoreTypes.Metadata | undefined`

Metadata related to the app requesting the connection.

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      metadata: { 
        name: 'Example', 
        description: 'Example website', 
        url: 'https://example.com', 
      }, 
    })

### projectId [‚Äã](#projectid)

`string`

WalletConnect Cloud project identifier. You can find your `projectId` on your [WalletConnect dashboard](https://cloud.reown.com/sign-in).

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68', 
    })

### qrModalOptions [‚Äã](#qrmodaloptions)

`QrModalOptions | undefined`

Options for rendering QR modal.

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      qrModalOptions: { 
        themeMode: 'dark', 
      }, 
    })

### relayUrl [‚Äã](#relayurl)

`string | undefined`

*   WalletConnect relay URL to use.
*   Defaults to `'wss://relay.walletconnect.com'`.

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      relayUrl: 'wss://relay.walletconnect.org', 
    })

### storageOptions [‚Äã](#storageoptions)

`KeyValueStorageOptions | undefined`

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      storageOptions: {}, 
    })

### showQrModal [‚Äã](#showqrmodal)

`boolean | undefined`

*   Whether to show the QR code modal upon calling `connector.connect()`.
*   Defaults to `true`.

ts

    import { walletConnect } from '@wagmi/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      showQrModal: true, 
    })

TIP

This can be disabled and you can listen for a `'message'` event with payload `{ type: 'display_uri'; data: string }` if you want to render your own QR code.</content>
</page>

<page>
  <title>safe | Wagmi</title>
  <url>https://wagmi.sh/core/api/connectors/safe</url>
  <content>Connector for [Safe Apps SDK](https://github.com/safe-global/safe-apps-sdk).

Import [‚Äã](#import)
-------------------

ts

    import { safe } from '@wagmi/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    import { safe } from '@wagmi/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [safe()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SafeParameters } from '@wagmi/connectors'

Check out the [Safe docs](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-sdk) for more info.

### allowedDomains [‚Äã](#alloweddomains)

`RegExp[] | undefined`

ts

    import { safe } from '@wagmi/connectors'
    
    const connector = safe({
      allowedDomains: [/app.safe.global$/], 
    })

### debug [‚Äã](#debug)

`boolean | undefined`

ts

    import { safe } from '@wagmi/connectors'
    
    const connector = safe({
      debug: true, 
    })

### shimDisconnect [‚Äã](#shimdisconnect)

`boolean | undefined`

*   This flag simulates disconnect behavior by keeping track of connection status in storage.
*   Defaults to `false`.

ts

    import { safe } from '@wagmi/connectors'
    
    const connector = safe({
      shimDisconnect: true, 
    })</content>
</page>

<page>
  <title>Transports | Wagmi</title>
  <url>https://wagmi.sh/core/api/transports</url>
  <content>[`createConfig`](https://wagmi.sh/core/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

Import [‚Äã](#import)
-------------------

ts

    import { http } from '@wagmi/core'

Built-In Transports [‚Äã](#built-in-transports)
---------------------------------------------

Available via the `'@wagmi/core'` entrypoint.

*   [custom (EIP-1193)](https://wagmi.sh/core/api/transports/custom)
*   [fallback](https://wagmi.sh/core/api/transports/fallback)
*   [http](https://wagmi.sh/core/api/transports/http)
*   [unstable\_connector](https://wagmi.sh/core/api/transports/unstable_connector)
*   [webSocket](https://wagmi.sh/core/api/transports/webSocket)</content>
</page>

<page>
  <title>custom | Wagmi</title>
  <url>https://wagmi.sh/core/api/transports/custom</url>
  <content>The `custom` Transport connects to a JSON-RPC API via custom. Wraps Viem's [`custom` Transport](https://viem.sh/docs/clients/transports/custom.html).

Import [‚Äã](#import)
-------------------

ts

    import { custom } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      custom
    } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { customRpc } from './rpc'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: custom({ 
          async request({ method, params }) { 
            const response = await customRpc.request(method, params)
            return response
          } 
        }) 
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

### provider [‚Äã](#provider)

`{ request({ method: string, params: unknown[] }): Promise<unknown> }`

An [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request) function.

ts

    import { customRpc } from './rpc'
    
    const transport = custom({
      async request({ method, params }) { 
        const response = await customRpc.request(method, params)
        return response
      }
    })

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"custom"`.

ts

    const transport = custom(
      provider,
      { 
        key: 'windowProvider', 
      }
    )

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"Ethereum Provider"`.

ts

    const transport = custom(
      provider,
      { 
        name: 'Window Ethereum Provider', 
      }
    )

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = custom(provider, {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = custom(provider, {
      retryDelay: 100, 
    })</content>
</page>

<page>
  <title>fallback | Wagmi</title>
  <url>https://wagmi.sh/core/api/transports/fallback</url>
  <content>The `fallback` Transport consumes **multiple** Transports. If a Transport request fails, it will fall back to the next one in the list. Wraps Viem's [`fallback` Transport](https://viem.sh/docs/clients/transports/fallback.html).

Import [‚Äã](#import)
-------------------

ts

    import { fallback } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      fallback,
      http,
    } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: fallback([ 
          http('https://foo-bar-baz.quiknode.pro/...'), 
          http('https://mainnet.infura.io/v3/...'), 
        ]) 
      },
    })</content>
</page>

<page>
  <title>http | Wagmi</title>
  <url>https://wagmi.sh/core/api/transports/http</url>
  <content>The `http` Transport connects to a JSON-RPC API via HTTP. Wraps Viem's [`http` Transport](https://viem.sh/docs/clients/transports/http.html).

Import [‚Äã](#import)
-------------------

ts

    import { http } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      http
    } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: http('https://foo-bar-baz.quiknode.pro/...'), 
        [sepolia.id]: http('https://foo-bar-sep.quiknode.pro/...'), 
      },
    })

WARNING

If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.

### Batch JSON-RPC [‚Äã](#batch-json-rpc)

The `http` Transport supports Batch JSON-RPC. This means that multiple JSON-RPC requests can be sent in a single HTTP request.

The Transport will batch up Actions over a given period and execute them in a single Batch JSON-RPC HTTP request. By default, this period is a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays) meaning that the batch request will be executed at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue). Consumers can specify a custom time period `wait` (in ms).

You can enable Batch JSON-RPC by setting the `batch` flag to `true`:

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: true
    })

Parameters [‚Äã](#parameters)
---------------------------

### url [‚Äã](#url)

`string`

URL of the JSON-RPC API. Defaults to `chain.rpcUrls.default.http[0]`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...')

### batch [‚Äã](#batch)

`boolean | BatchOptions`

Toggle to enable Batch JSON-RPC. Defaults to `false`

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: true
    })

### batch.batchSize [‚Äã](#batch-batchsize)

`number`

The maximum number of JSON-RPC requests to send in a batch. Defaults to `1_000`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: {
        batchSize: 2_000
      }
    })

### batch.wait [‚Äã](#batch-wait)

`number`

The maximum number of milliseconds to wait before sending a batch. Defaults to `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays)).

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: {
        wait: 16
      }
    })

### fetchOptions [‚Äã](#fetchoptions)

[`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)

[Fetch options](https://developer.mozilla.org/en-US/docs/Web/API/fetch) to pass to the internal `fetch` function. Useful for passing auth headers or cache options.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      fetchOptions: { 
        headers: {
          'Authorization': 'Bearer ...'
        }
      }
    })

### key [‚Äã](#key)

`string`

A key for the Transport. Defaults to `"http"`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      key: 'alchemy', 
    })

### name [‚Äã](#name)

`string`

A name for the Transport. Defaults to `"HTTP JSON-RPC"`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      name: 'Alchemy HTTP Provider', 
    })

### retryCount [‚Äã](#retrycount)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      retryCount: 5, 
    })

### retryDelay [‚Äã](#retrydelay)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      retryDelay: 100, 
    })

### timeout [‚Äã](#timeout)

`number`

The timeout for requests. Defaults to `10_000`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      timeout: 60_000, 
    })</content>
</page>

<page>
  <title>unstable_connector | Wagmi</title>
  <url>https://wagmi.sh/core/api/transports/unstable_connector</url>
  <content>The `unstable_connector` Transport connects to a JSON-RPC API via the provided [Connector](https://wagmi.sh/core/api/connectors).

For example, if the provided Connector is [`injected`](https://wagmi.sh/core/api/connectors/injected) and the end-user uses MetaMask, then outgoing JSON-RPC requests will be sent via the MetaMask EIP-1193 Provider (`window.ethereum`).

Import [‚Äã](#import)
-------------------

ts

    import { unstable_connector } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      fallback,
      unstable_connector,
    } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: fallback([
          unstable_connector(injected), 
          http('https://foo-bar-baz.quiknode.pro/...')
        ])
      },
    })

WARNING

It is **highly recommended** to use the `unstable_connector` Transport inside of a [`fallback` Transport](https://wagmi.sh/core/api/transports/fallback). This ensures that if the Connector request fails, the Transport will fall back to a different Transport in the fallback set.

Some common cases for a Connector request to fail are:

*   Chain ID mismatches,
*   Connector RPC not supporting the requested method and/or only supporting a subset of methods for connected accounts,
*   Rate-limiting of Connector RPC.

Parameters [‚Äã](#parameters)
---------------------------

### connector [‚Äã](#connector)

`Connector`

The Connector to use for the Transport.

ts

    import { unstable_connector } from 'wagmi'
    import { safe } from 'wagmi/connectors'
    
    const transport = unstable_connector(safe)

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"connector"`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, { 
      key: 'injected',  
    })

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"Connector"`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, { 
      name: 'Injected',  
    })

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, {
      retryDelay: 100, 
    })</content>
</page>

<page>
  <title>webSocket | Wagmi</title>
  <url>https://wagmi.sh/core/api/transports/webSocket</url>
  <content>The `webSocket` Transport connects to a JSON-RPC API via a WebSocket. Wraps Viem's [`webSocket` Transport](https://viem.sh/docs/clients/transports/webSocket.html).

Import [‚Äã](#import)
-------------------

ts

    import { webSocket } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      webSocket
    } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: webSocket('wss://foo-bar-baz.quiknode.pro/...'), 
        [sepolia.id]: webSocket('wss://foo-bar-sep.quicknode.pro/...'), 
      },
    })

WARNING

If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.

Parameters [‚Äã](#parameters)
---------------------------

### url [‚Äã](#url)

`string`

URL of the JSON-RPC API.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...')

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"webSocket"`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
      key: 'alchemy',  
    })

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"WebSocket JSON-RPC"`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
      name: 'Alchemy WebSocket Provider',  
    })

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      retryDelay: 100, 
    })

### timeout (optional) [‚Äã](#timeout-optional)

`number`

The timeout for async WebSocket requests. Defaults to `10_000`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      timeout: 60_000, 
    })</content>
</page>

<page>
  <title>Actions | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions</url>
  <content>Released under the [MIT License](https://github.com/wevm/wagmi/blob/main/LICENSE).

Copyright ¬© 2022-present Weth, LLC</content>
</page>

<page>
  <title>getAccount | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getAccount</url>
  <content>Action for getting current account.

Import [‚Äã](#import)
-------------------

ts

    import { getAccount } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getAccount } from '@wagmi/core'
    import { config } from './config'
    
    const account = getAccount(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetAccountReturnType } from '@wagmi/core'

### address [‚Äã](#address)

`Address | undefined`

*   Connected address from connector.
*   Defaults to first address in [`addresses`](#addresses).

### addresses [‚Äã](#addresses)

`readonly Address[] | undefined`

Connected addresses from connector.

### chain [‚Äã](#chain)

`Chain | undefined`

Connected chain from connector. If chain is not configured by config, it will be `undefined`.

### chainId [‚Äã](#chainid)

`number | undefined`

Connected chain id from connector.

### connector [‚Äã](#connector)

`Connector | undefined`

Connected connector.

### isConnecting / isReconnecting / isConnected / isDisconnected [‚Äã](#isconnecting-isreconnecting-isconnected-isdisconnected)

`boolean`

Boolean variables derived from [`status`](#status).

### status [‚Äã](#status)

`'connecting' | 'reconnecting' | 'connected' | 'disconnected'`

*   `'connecting'` attempting to establish connection.
*   `'reconnecting'` attempting to re-establish connection to one or more connectors.
*   `'connected'` at least one connector is connected.
*   `'disconnected'` no connection to any connector.

You can use `status` to narrow the return type.

For example, when `status` is `'connected'` properties like `address` are guaranteed to be defined.

ts

    if (. === 'connected') {
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

Or when status is `'disconnected'` properties like `address` are guaranteed to be `undefined`:

ts

    if (. === 'disconnected') {
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }</content>
</page>

<page>
  <title>estimateMaxPriorityFeePerGas | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/estimateMaxPriorityFeePerGas</url>
  <content>Returns an estimate for the max priority fee per gas (in wei) for a transaction to be likely included in the next block.

Import [‚Äã](#import)
-------------------

ts

    import { estimateMaxPriorityFeePerGas } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
    import { config } from './config'
    
    const result = await estimateMaxPriorityFeePerGas(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type EstimateFeesPerGasParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { estimateMaxPriorityFeePerGas } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const result = await estimateMaxPriorityFeePerGas(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type EstimateFeesPerGasReturnType } from '@wagmi/core'

`bigint`

An estimate (in wei) for the max priority fee per gas.

Error [‚Äã](#error)
-----------------

ts

    import { type EstimateFeesPerGasErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateFeesPerGasData,
      type EstimateFeesPerGasOptions,
      type EstimateFeesPerGasQueryFnData,
      type EstimateFeesPerGasQueryKey,
      estimateMaxPriorityFeePerGasQueryKey,
      estimateMaxPriorityFeePerGasQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`estimateMaxPriorityFeePerGas`](https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html)</content>
</page>

<page>
  <title>call | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/call</url>
  <content>Action for executing a new message call immediately without submitting a transaction to the network.

Import [‚Äã](#import)
-------------------

ts

    import { call } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type  } from '@wagmi/core'

### account [‚Äã](#account)

`Account | Address | undefined`

The Account to call from.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`Address | undefined`

The contract address or recipient.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      accessList: [ 
        {
          address: '0x1',
          storageKeys: ['0x1'],
        },
      ],
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

The gas provided for transaction execution.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      gas: 1_000_000n, 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      gasPrice: parseGwei('20'), 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      maxFeePerGas: parseGwei('20'), 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### nonce [‚Äã](#nonce)

`number | undefined`

Unique number identifying this transaction.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      nonce: 420, 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value (in wei) sent with this transaction.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await call(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`number | undefined`

The block number to perform the call against.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      blockNumber: 15121123n, 
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to perform the call against.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    
    await call(config, {
      blockTag: 'safe', 
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The block tag to perform the call against.

index.tsconfig.ts

ts

    import { call } from '@wagmi/core'
    import { config } from './config'
    import { mainnet } from '@wagmi/core/chains'
    
    await call(config, {
      chainId: mainnet.id, 
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type  } from '@wagmi/core'

`{ data: 0x${string} }`

The call data.

Error [‚Äã](#error)
-----------------

ts

    import { type  } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type callData,
      type callOptions,
      type callQueryFnData,
      type callQueryKey,
      callQueryKey,
      callQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`call`](https://viem.sh/docs/actions/public/call.html)</content>
</page>

<page>
  <title>getBalance | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getBalance</url>
  <content>Action for fetching native currency or token balance.

Import [‚Äã](#import)
-------------------

ts

    import { getBalance } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { config } from './config'
    
    const balance = getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetBalanceParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

Address to get balance for.

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { config } from './config'
    
    const balance = getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get balance at.

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { config } from './config'
    
    const balance = getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      blockNumber: 17829139n, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { config } from './config'
    
    const balance = getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      blockTag: 'latest', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const balance = await getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### token [‚Äã](#token)

`Address | undefined`

ERC-20 token address to get balance for.

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { config } from './config'
    
    const balance = getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### unit [‚Äã](#unit)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.tsconfig.ts

ts

    import { getBalance } from '@wagmi/core'
    import { config } from './config'
    
    const balance = getBalance(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      unit: 'ether', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetBalanceReturnType } from '@wagmi/core'

### decimals [‚Äã](#decimals)

`number`

Number of decimals for balance [`value`](#value).

### formatted [‚Äã](#formatted)

`string`

Formatted value of balance using [`unit`](#unit).

### symbol [‚Äã](#symbol)

`string`

Symbol of native currency or token.

### value [‚Äã](#value)

`bigint`

Raw value of balance.

Error [‚Äã](#error)
-----------------

ts

    import { type GetBalanceErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBalanceData,
      type GetBalanceOptions,
      type GetBalanceQueryFnData,
      type GetBalanceQueryKey,
      getBalanceQueryKey,
      getBalanceQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getBalance`](https://viem.sh/docs/actions/public/getBalance.html) for native currency balances
*   [`multicall`](https://viem.sh/docs/actions/public/multicall.html) for token balances</content>
</page>

<page>
  <title>connect | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/connect</url>
  <content>Action for connecting accounts with [connectors](https://wagmi.sh/core/api/connectors).

Import [‚Äã](#import)
-------------------

ts

    import { connect } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { connect } from '@wagmi/core'
    import { injected } from '@wagmi/connectors'
    import { config } from './config'
    
    const result = await connect(config, { connector: injected() })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type ConnectParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`number | undefined`

Chain ID to connect to.

Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider is connected to.

index.tsconfig.ts

ts

    import { connect } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { injected } from '@wagmi/connectors'
    import { config } from './config'
    
    const result = await connect(config, {
      chainId: mainnet.id, 
      connector: injected(),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`CreateConnectorFn | Connector`

[Connector](https://wagmi.sh/core/api/connectors) to connect with.

index.tsconfig.ts

ts

    import { connect } from '@wagmi/core'
    import { injected } from '@wagmi/connectors'
    import { config } from './config'
    
    const result = await connect(config, {
      connector: injected(), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type ConnectReturnType } from '@wagmi/core'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Connected accounts from connector.

### chainId [‚Äã](#chainid-1)

`number`

Connected chain ID from connector.

Error [‚Äã](#error)
-----------------

ts

    import { type ConnectErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ConnectData,
      type ConnectVariables,
      type ConnectMutate,
      type ConnectMutateAsync,
      connectMutationOptions,
    } from '@wagmi/core/query'</content>
</page>

<page>
  <title>estimateFeesPerGas | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/estimateFeesPerGas</url>
  <content>Returns an estimate for the fees per gas (in wei) for a transaction to be likely included in the next block.

Import [‚Äã](#import)
-------------------

ts

    import { estimateFeesPerGas } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { estimateFeesPerGas } from '@wagmi/core'
    import { config } from './config'
    
    const result = await estimateFeesPerGas(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type EstimateFeesPerGasParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { estimateFeesPerGas } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const result = await estimateFeesPerGas(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### formatUnits [‚Äã](#formatunits)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.tsconfig.ts

ts

    import { estimateFeesPerGas } from '@wagmi/core'
    import { config } from './config'
    
    const feesPerGas = estimateFeesPerGas(config, {
      formatUnits: 'ether', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559'`

*   Fee value type.
*   Defaults to `'eip1559'`

index.tsconfig.ts

ts

    import { estimateFeesPerGas } from '@wagmi/core'
    import { config } from './config'
    
    const result = estimateFeesPerGas(config, {
      type: 'legacy', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type EstimateFeesPerGasReturnType } from '@wagmi/core'

[`FeeValues`](https://viem.sh/docs/glossary/types.html#feevalues)

An estimate (in wei) for the fees per gas.

### formatted [‚Äã](#formatted)

`{ gasPrice: string | undefined; maxFeePerGas: string | undefined; maxPriorityFeePerGas: string | undefined; }`

Object of formatted values using [`formatUnits`](#formatunits).

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

*   Gas price.
*   When [`type`](#type) is `'eip1559'`, value is `undefined`.

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

*   Max fee per gas.
*   When [`type`](#type) is `'legacy'`, value is `undefined`.

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

*   Max priority fee per gas.
*   When [`type`](#type) is `'legacy'`, value is `undefined`.

Error [‚Äã](#error)
-----------------

ts

    import { type EstimateFeesPerGasErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateFeesPerGasData,
      type EstimateFeesPerGasOptions,
      type EstimateFeesPerGasQueryFnData,
      type EstimateFeesPerGasQueryKey,
      estimateFeesPerGasQueryKey,
      estimateFeesPerGasQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`estimateFeesPerGas`](https://viem.sh/docs/actions/public/estimateFeesPerGas.html)</content>
</page>

<page>
  <title>disconnect | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/disconnect</url>
  <content>Action for disconnecting connections.

Import [‚Äã](#import)
-------------------

ts

    import { disconnect } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { disconnect } from '@wagmi/core'
    import { config } from './config'
    
    await disconnect(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type DisconnectParameters } from '@wagmi/core'

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/core/api/connectors) to disconnect with.

index.tsconfig.ts

ts

    import { disconnect, getAccount } from '@wagmi/core'
    import { config } from './config'
    
    const { connector } = getAccount(config)
    const result = await disconnect(config, {
      connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Error [‚Äã](#error)
-----------------

ts

    import { type DisconnectErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type DisconnectData,
      type DisconnectVariables,
      type DisconnectMutate,
      type DisconnectMutateAsync,
      disconnectMutationOptions,
    } from '@wagmi/core/query'</content>
</page>

<page>
  <title>estimateGas | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/estimateGas</url>
  <content>Action for estimating the gas necessary to complete a transaction without submitting it to the network.

Import [‚Äã](#import)
-------------------

ts

    import { estimateGas } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type EstimateGasParameters } from '@wagmi/core'

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      accessList: [{ 
        address: '0x1', 
        storageKeys: ['0x1'], 
      }], 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when estimating gas.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      chainId: mainnet.id, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

index.tsconfig.ts

ts

    import { getConnections, estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const connections = getConnections(config)
    const result = await estimateGas(config, {
      connector: connections[0]?.connector, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      gas: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      gasPrice: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      maxFeePerGas: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      nonce: 123, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`Address | undefined`

The transaction recipient or contract address.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      type: 'eip1559', 
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsconfig.ts

ts

    import { estimateGas } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await estimateGas(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      value: parseEther('0.01'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type EstimateGasReturnType } from '@wagmi/core'

`bigint`

The gas estimate in wei.

Error [‚Äã](#error)
-----------------

ts

    import { type EstimateGasErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateGasData,
      type EstimateGasOptions,
      type EstimateGasQueryFnData,
      type EstimateGasQueryKey,
      estimateGasQueryKey,
      estimateGasQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`estimateGas`](https://viem.sh/docs/actions/public/estimateGas.html)</content>
</page>

<page>
  <title>deployContract | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/deployContract</url>
  <content>deployContract viem@>=2.8.18 [‚Äã](#deploycontract)
-------------------------------------------------

Action for deploying a contract to the network, given bytecode, and constructor arguments.

Import [‚Äã](#import)
-------------------

ts

    import { deployContract } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsabi.tsconfig.ts

ts

    import { deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const result = await deployContract(config, {
      abi: wagmiAbi,
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Deploying with Constructor Args [‚Äã](#deploying-with-constructor-args)
---------------------------------------------------------------------

index.tsabi.tsconfig.ts

ts

    import { deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const result = await deployContract(config, {
      abi: wagmiAbi,
      args: [69420],
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type DeployContractParameters } from '@wagmi/core'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI.

index.tsabi.tsconfig.ts

ts

    import { deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const result = await deployContract(config, {
      abi: wagmiAbi, 
      args: [69420],
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when deploying a contract. Throws if account is not found on [`connector`](#connector).

index.tsabi.tsconfig.ts

ts

    import { deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const result = await deployContract(config, {
      abi: wagmiAbi,
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      args: [69420],
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when deploying the contract.
*   Inferred from [`abi`](#abi).

index.tsabi.tsconfig.ts

ts

    import { deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const result = await deployContract(config, {
      abi: wagmiAbi,
      args: [69420], 
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### bytecode [‚Äã](#bytecode)

`Hex`

The contract's bytecode.

index.tsabi.tsconfig.ts

ts

    import { deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const result = await deployContract(config, {
      abi: wagmiAbi,
      args: [69420],
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...', 
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to use when deploying a contract.
*   Defaults to current connector.

index.tsabi.tsconfig.ts

ts

    import { getAccount, deployContract } from '@wagmi/core'
    import { wagmiAbi } from './abi'
    import { config } from './config'
    
    const { connector } = getAccount(config)
    const result = await deployContract(config, {
      abi: wagmiAbi,
      args: [69420],
      bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
      connector, 
    })

ts

    export const wagmiAbi = [
      ...
      {
        inputs: [{ name: "x", type: "uint32" }],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      ...
    ] as const;

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type DeployContractReturnType } from '@wagmi/core'

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

Transaction hash.

Error [‚Äã](#error)
-----------------

ts

    import { type DeployContractErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type DeployContractData,
      type DeployContractVariables,
      type DeployContractMutate,
      type DeployContractMutateAsync,
      deployContractMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`deployContract`](https://viem.sh/docs/contract/deployContract)</content>
</page>

<page>
  <title>getBlockNumber | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getBlockNumber</url>
  <content>Action for fetching the number of the most recent block seen.

Import [‚Äã](#import)
-------------------

ts

    import { getBlockNumber } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlockNumber(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetBlockNumberParameters } from '@wagmi/core'

### cacheTime [‚Äã](#cachetime)

`number | undefined`

Time in milliseconds that cached block number will remain in memory.

index.tsconfig.ts

ts

    import { getBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlockNumber(config, {
      cacheTime: 4_000, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getBlockNumber } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const blockNumber = await getBlockNumber(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetBlockNumberReturnType } from '@wagmi/core'

`bigint`

Most recent block number seen.

Error [‚Äã](#error)
-----------------

ts

    import { type GetBlockNumberErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockNumberData,
      type GetBlockNumberOptions,
      type GetBlockNumberQueryFnData,
      type GetBlockNumberQueryKey,
      getBlockNumberQueryKey,
      getBlockNumberQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getBlockNumber`](https://viem.sh/docs/actions/public/getBlockNumber.html)
*   [`watchBlockNumber`](https://viem.sh/docs/actions/public/watchBlockNumber.html)</content>
</page>

<page>
  <title>getBlock | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getBlock</url>
  <content>Action for fetching information about a block at a block number, hash or tag.

Import [‚Äã](#import)
-------------------

ts

    import { getBlock } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getBlock } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlock(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetBlockParameters } from '@wagmi/core'

### blockHash [‚Äã](#blockhash)

`` `0x${string}` ``

Information at a given block hash.

index.tsconfig.ts

ts

    import { getBlock } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlock(config, {
      blockHash: '0x89644bbd5c8d682a2e9611170e6c1f02573d866d286f006cbf517eec7254ec2d'
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint`

Information at a given block number.

index.tsconfig.ts

ts

    import { getBlock } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlock(config, {
      blockNumber: 42069n
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Information at a given block tag. Defaults to `'latest'`.

index.tsconfig.ts

ts

    import { getBlock } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlock(config, {
      blockTag: 'pending'
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getBlock } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const blockNumber = await getBlock(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### includeTransactions [‚Äã](#includetransactions)

`boolean`

Whether or not to include transactions as objects.

index.tsconfig.ts

ts

    import { getBlock } from '@wagmi/core'
    import { config } from './config'
    
    const blockNumber = await getBlock(config, {
      includeTransactions: true
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetBlockReturnType } from '@wagmi/core'

[`Block`](https://viem.sh/docs/glossary/types.html#block)

Information about the block.

Error [‚Äã](#error)
-----------------

ts

    import { type GetBlockErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockData,
      type GetBlockOptions,
      type GetBlockQueryFnData,
      type GetBlockQueryKey,
      getBlockQueryKey,
      getBlockQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getBlock`](https://viem.sh/docs/actions/public/getBlock.html)</content>
</page>

<page>
  <title>getBlockTransactionCount | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getBlockTransactionCount</url>
  <content>Action for fetching the number of Transactions at a block number, hash or tag.

Import [‚Äã](#import)
-------------------

ts

    import { getBlockTransactionCount } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getBlockTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const blockTransactionCount = await getBlockTransactionCount(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetBlockTransactionCountParameters } from '@wagmi/core'

### cacheTime [‚Äã](#cachetime)

`number | undefined`

Time in milliseconds that cached block transaction count will remain in memory.

index.tsconfig.ts

ts

    import { getBlockTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const blockTransactionCount = await getBlockTransactionCount(config, {
      cacheTime: 4_000, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getBlockTransactionCount } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const blockTransactionCount = await getBlockTransactionCount(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetBlockTransactionCountReturnType } from '@wagmi/core'

`number`

The number of Transactions at a block number

Error [‚Äã](#error)
-----------------

ts

    import { type GetBlockTransactionCountErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockTransactionCountData,
      type GetBlockTransactionCountOptions,
      type GetBlockTransactionCountQueryFnData,
      type GetBlockTransactionCountQueryKey,
      getBlockTransactionCountQueryKey,
      getBlockTransactionCountQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getBlockTransactionCount`](https://viem.sh/docs/actions/public/getBlockTransactionCount.html)</content>
</page>

<page>
  <title>getBytecode | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getBytecode</url>
  <content>Action for retrieving the bytecode at an address.

Import [‚Äã](#import)
-------------------

ts

    import { getBytecode } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getBytecode } from '@wagmi/core'
    import { config } from './config'
    
    await getBytecode(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetBytecodeParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

The contract address.

index.tsconfig.ts

ts

    import { getBytecode } from '@wagmi/core'
    import { config } from './config'
    
    await getBytecode(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

The block number to check the bytecode at.

index.tsconfig.ts

ts

    import { getBytecode } from '@wagmi/core'
    import { config } from './config'
    
    await getBytecode(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      blockNumber: 16280770n, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

index.tsconfig.ts

ts

    import { getBytecode } from '@wagmi/core'
    import { config } from './config'
    
    await getBytecode(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      blockTag: 'safe', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

index.tsconfig.ts

ts

    import { getBytecode } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    await getBytecode(config, {
      chainId: mainnet.id, 
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetBytecodeReturnType } from '@wagmi/core'

`Hex`

The contract's bytecode.

Error [‚Äã](#error)
-----------------

ts

    import { type GetBytecodeErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type getBytecodeData,
      type getBytecodeOptions,
      type getBytecodeQueryFnData,
      type getBytecodeQueryKey,
      getBytecodeQueryKey,
      getBytecodeQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getCode`](https://viem.sh/docs/contract/getCode)</content>
</page>

<page>
  <title>getChainId | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getChainId</url>
  <content>Action for getting current chain ID.

Import [‚Äã](#import)
-------------------

ts

    import { getChainId } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getChainId } from '@wagmi/core'
    import { config } from './config'
    
    const chainId = getChainId(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetChainIdReturnType } from '@wagmi/core'

`number`

Current chain ID from [`config.state.chainId`](https://wagmi.sh/core/api/createConfig#chainid).

INFO

Only returns chain IDs for chains configured via `createConfig`'s [`chains`](https://wagmi.sh/core/api/createConfig#chains) parameter.

If the active [connection](https://wagmi.sh/core/api/createConfig#connection) [`chainId`](https://wagmi.sh/core/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `getChainId` will return the last configured chain ID.</content>
</page>

<page>
  <title>getClient | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getClient</url>
  <content>Action for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

Import [‚Äã](#import)
-------------------

ts

    import { getClient } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getClient } from '@wagmi/core'
    import { config } from './config'
    
    const client = getClient(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetClientParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

index.tsconfig.ts

ts

    import { getClient } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const client = await getClient(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetClientReturnType } from '@wagmi/core'

`Client`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.</content>
</page>

<page>
  <title>getChains | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getChains</url>
  <content>Action for getting configured chains.

Import [‚Äã](#import)
-------------------

ts

    import { getChains } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getChains } from '@wagmi/core'
    import { config } from './config'
    
    const chains = getChains(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetChainsReturnType } from '@wagmi/core'

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](https://wagmi.sh/core/api/createConfig#chains).</content>
</page>

<page>
  <title>getConnections | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getConnections</url>
  <content>Action for getting active connections.

Import [‚Äã](#import)
-------------------

ts

    import { getConnections } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getConnections } from '@wagmi/core'
    import { config } from './config'
    
    const connections = getConnections(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetConnectionsReturnType } from '@wagmi/core'

[`Connection[]`](https://wagmi.sh/core/api/createConfig#connection)

Active connections.</content>
</page>

<page>
  <title>getConnectorClient | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getConnectorClient</url>
  <content>Action for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

Import [‚Äã](#import)
-------------------

ts

    import { getConnectorClient } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getConnectorClient } from '@wagmi/core'
    import { config } from './config'
    
    const client = await getConnectorClient(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetConnectorClientParameters } from '@wagmi/core'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

index.tsconfig.ts

ts

    import { getConnectorClient } from '@wagmi/core'
    import { config } from './config'
    
    const client = await getConnectorClient(config, {
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

index.tsconfig.ts

ts

    import { getConnectorClient } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const client = await getConnectorClient(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to get client for.
*   Defaults to current connector.

index.tsconfig.ts

ts

    import { getConnections, getConnectorClient } from '@wagmi/core'
    import { config } from './config'
    
    const connections = getConnections(config)
    const client = await getConnectorClient(config, {
      connector: connections[0]?.connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetChainIdReturnType } from '@wagmi/core'

`Client`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

Error [‚Äã](#error)
-----------------

ts

    import { type GetConnectorClientErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetConnectorClientData,
      type GetConnectorClientOptions,
      type GetConnectorClientQueryFnData,
      type GetConnectorClientQueryKey,
      getConnectorClientQueryKey,
      getConnectorClientQueryOptions,
    } from '@wagmi/core/query'</content>
</page>

<page>
  <title>getConnectors | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getConnectors</url>
  <content>Action for getting configured connectors.

Import [‚Äã](#import)
-------------------

ts

    import { getConnectors } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getConnectors } from '@wagmi/core'
    import { config } from './config'
    
    const connectors = getConnectors(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetConnectorsReturnType } from '@wagmi/core'

`readonly Connector[]`

Connectors from [`config.connectors`](https://wagmi.sh/core/api/createConfig#connectors-1).</content>
</page>

<page>
  <title>getEnsAddress | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getEnsAddress</url>
  <content>Action for fetching ENS address for name.

Import [‚Äã](#import)
-------------------

ts

    import { getEnsAddress } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = getEnsAddress(config, {
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetEnsAddressParameters } from '@wagmi/core'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS address at.

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = getEnsAddress(config, {
      blockNumber: 17829139n, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = getEnsAddress(config, {
      blockTag: 'latest', 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = await getEnsAddress(config, {
      chainId: mainnet.id, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### coinType [‚Äã](#cointype)

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = await getEnsAddress(config, {
      coinType: 60, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string`

Name to get the address for.

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = await getEnsAddress(config, {
      name: normalize('wevm.eth'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { getEnsAddress } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAddress = await getEnsAddress(config, {
      name: normalize('wevm.eth'),
      universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetEnsAddressReturnType } from '@wagmi/core'

`string`

ENS address.

Error [‚Äã](#error)
-----------------

ts

    import { type GetEnsAddressErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsAddressData,
      type GetEnsAddressOptions,
      type GetEnsAddressQueryFnData,
      type GetEnsAddressQueryKey,
      getEnsAddressQueryKey,
      getEnsAddressQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getEnsAddress`](https://viem.sh/docs/ens/actions/getEnsAddress.html)</content>
</page>

<page>
  <title>getEnsName | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getEnsName</url>
  <content>Action for fetching primary ENS name for address.

Import [‚Äã](#import)
-------------------

ts

    import { getEnsName } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getEnsName } from '@wagmi/core'
    import { config } from './config'
    
    const ensName = getEnsName(config, {
      address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetEnsNameParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

Address to get the name for.

index.tsconfig.ts

ts

    import { getEnsName } from '@wagmi/core'
    import { config } from './config'
    
    const ensName = await getEnsName(config, {
      address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get name at.

index.tsconfig.ts

ts

    import { getEnsName } from '@wagmi/core'
    import { config } from './config'
    
    const ensName = getEnsName(config, {
      address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      blockNumber: 17829139n, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get name at.

index.tsconfig.ts

ts

    import { getEnsName } from '@wagmi/core'
    import { config } from './config'
    
    const ensName = getEnsName(config, {
      address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      blockTag: 'latest', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getEnsName } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const ensName = await getEnsName(config, {
      address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { getEnsName } from '@wagmi/core'
    import { config } from './config'
    
    const ensName = await getEnsName(config, {
      address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      universalResolverName: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetEnsNameReturnType } from '@wagmi/core'

`string | null`

The primary ENS name for the address. Returns `null` if address does not have primary name assigned.

Error [‚Äã](#error)
-----------------

ts

    import { type GetEnsNameErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsNameData,
      type GetEnsNameOptions,
      type GetEnsNameQueryFnData,
      type GetEnsNameQueryKey,
      getEnsNameQueryKey,
      getEnsNameQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getEnsName`](https://viem.sh/docs/ens/actions/getEnsName.html)</content>
</page>

<page>
  <title>getEnsAvatar | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getEnsAvatar</url>
  <content>Action for fetching ENS address for avatar.

Import [‚Äã](#import)
-------------------

ts

    import { getEnsAvatar } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetEnsAvatarParameters } from '@wagmi/core'

* * *

### assetGatewayUrls viem@>=2.3.1 [‚Äã](#assetgatewayurls)

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      assetGatewayUrls: { 
        ipfs: 'https://cloudflare-ipfs.com', 
      }, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get avatar at.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      blockNumber: 17829139n, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get avatar at.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      blockTag: 'latest', 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      chainId: mainnet.id, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gatewayUrls [‚Äã](#gatewayurls)

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      gatewayUrls: ['https://cloudflare-ipfs.com'] { 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string`

Name to get the avatar for.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      name: normalize('wevm.eth'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensAvatar = await getEnsAvatar(config, {
      name: normalize('wevm.eth'),
      universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetEnsAvatarReturnType } from '@wagmi/core'

`string | null`

The avatar URI for ENS name.

Error [‚Äã](#error)
-----------------

ts

    import { type getEnsAvatarError } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsAvatarData,
      type GetEnsAvatarOptions,
      type GetEnsAvatarQueryFnData,
      type GetEnsAvatarQueryKey,
      getEnsAvatarQueryKey,
      getEnsAvatarQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getEnsAvatar`](https://viem.sh/docs/ens/actions/getEnsAvatar.html)</content>
</page>

<page>
  <title>getEnsText | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getEnsText</url>
  <content>Action for fetching a text record for a specified ENS name and key.

Import [‚Äã](#import)
-------------------

ts

    import { getEnsText } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = getEnsText(config, {
      name: normalize('wevm.eth'),
      key: 'com.twitter',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsText`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetEnsTextParameters } from '@wagmi/core'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get the text at.

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = getEnsText(config, {
      blockNumber: 17829139n, 
      name: normalize('wevm.eth'),
      key: 'com.twitter',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get the text at.

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = getEnsText(config, {
      blockTag: 'latest', 
      name: normalize('wevm.eth'),
      key: 'com.twitter',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = await getEnsText(config, {
      chainId: mainnet.id, 
      name: normalize('wevm.eth'),
      key: 'com.twitter',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### key [‚Äã](#key)

`string`

ENS key to get Text for.

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = await getEnsText(config, {
      name: normalize('wevm.eth'),
      key: 'com.twitter', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string`

Name to get the text for.

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = await getEnsText(config, {
      name: normalize('wevm.eth'), 
      key: 'com.twitter',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { getEnsText } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensText = await getEnsText(config, {
      name: normalize('wevm.eth'),
      key: 'com.twitter',
      universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetEnsTextReturnType } from '@wagmi/core'

`string | null`

The text record for ENS name.

Returns `null` if name does not have text assigned.

Error [‚Äã](#error)
-----------------

ts

    import { type getEnsTextError } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsTextData,
      type GetEnsTextOptions,
      type GetEnsTextQueryFnData,
      type GetEnsTextQueryKey,
      getEnsTextQueryKey,
      getEnsTextQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html)</content>
</page>

<page>
  <title>getEnsResolver | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getEnsResolver</url>
  <content>Action for fetching ENS resolver for name.

Import [‚Äã](#import)
-------------------

ts

    import { getEnsResolver } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getEnsResolver } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensResolver = getEnsResolver(config, {
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsResolver`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetEnsResolverParameters } from '@wagmi/core'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get resolver at.

index.tsconfig.ts

ts

    import { getEnsResolver } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensResolver = getEnsResolver(config, {
      blockNumber: 17829139n, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get resolver at.

index.tsconfig.ts

ts

    import { getEnsResolver } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensResolver = getEnsResolver(config, {
      blockTag: 'latest', 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getEnsResolver } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensResolver = await getEnsResolver(config, {
      chainId: mainnet.id, 
      name: normalize('wevm.eth'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string`

Name to get the resolver for.

index.tsconfig.ts

ts

    import { getEnsResolver } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensResolver = await getEnsResolver(config, {
      name: normalize('wevm.eth'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.tsconfig.ts

ts

    import { getEnsResolver } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const ensResolver = await getEnsResolver(config, {
      name: normalize('wevm.eth'),
      universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetEnsResolverReturnType } from '@wagmi/core'

`Address`

The address of the resolver.

Error [‚Äã](#error)
-----------------

ts

    import { type getEnsResolverError } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsResolverData,
      type GetEnsResolverOptions,
      type GetEnsResolverQueryFnData,
      type GetEnsResolverQueryKey,
      getEnsResolverQueryKey,
      getEnsResolverQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getEnsResolver`](https://viem.sh/docs/ens/actions/getEnsResolver.html)</content>
</page>

<page>
  <title>getGasPrice | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getGasPrice</url>
  <content>Action for fetching the current price of gas (in wei).

Import [‚Äã](#import)
-------------------

ts

    import { getGasPrice } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getGasPrice } from '@wagmi/core'
    import { config } from './config'
    
    const gasPrice = await getGasPrice(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetGasPriceParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getGasPrice } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const gasPrice = await getGasPrice(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetGasPriceReturnType } from '@wagmi/core'

`bigint`

Current price of gas (in wei).

Error [‚Äã](#error)
-----------------

ts

    import { type GetGasPriceErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetGasPriceData,
      type GetGasPriceOptions,
      type GetGasPriceQueryFnData,
      type GetGasPriceQueryKey,
      getGasPriceQueryKey,
      getGasPriceQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getGasPrice`](https://viem.sh/docs/actions/public/getGasPrice.html)</content>
</page>

<page>
  <title>getFeeHistory | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getFeeHistory</url>
  <content>Action for fetching a collection of historical gas information.

Import [‚Äã](#import)
-------------------

ts

    import { getFeeHistory } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getFeeHistory } from '@wagmi/core'
    import { config } from './config'
    
    const feeHistory = await getFeeHistory(config, {
      blockCount: 4,
      rewardPercentiles: [25, 75]
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetFeeHistoryParameters } from '@wagmi/core'

### blockCount [‚Äã](#blockcount)

`number`

Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.

index.tsconfig.ts

ts

    import { getFeeHistory } from '@wagmi/core'
    import { config } from './config'
    
    const feeHistory = await getFeeHistory(config, {
      blockCount: 4, 
      rewardPercentiles: [25, 75]
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### rewardPercentiles [‚Äã](#rewardpercentiles)

`number[]`

A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.

index.tsconfig.ts

ts

    import { getFeeHistory } from '@wagmi/core'
    import { config } from './config'
    
    const feeHistory = await getFeeHistory(config, {
      blockCount: 4,
      rewardPercentiles: [25, 75] 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Highest number block of the requested range.

index.tsconfig.ts

ts

    import { getFeeHistory } from '@wagmi/core'
    import { config } from './config'
    
    const feeHistory = await getFeeHistory(config, {
      blockCount: 4,
      blockNumber: 1551231n, 
      rewardPercentiles: [25, 75],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag of the highest number block of the requested range.

index.tsconfig.ts

ts

    import { getFeeHistory } from '@wagmi/core'
    import { config } from './config'
    
    const feeHistory = await getFeeHistory(config, {
      blockCount: 4,
      blockTag: 'safe', 
      rewardPercentiles: [25, 75],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getFeeHistory } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const feeHistory = await getFeeHistory(config, {
      blockCount: 4,
      chainId: mainnet.id, 
      rewardPercentiles: [25, 75],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetFeeHistoryReturnType } from '@wagmi/core'

[`FeeHistory`](https://viem.sh/docs/glossary/types.html#feehistory)

The fee history.

Error [‚Äã](#error)
-----------------

ts

    import { type GetFeeHistoryErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetFeeHistoryData,
      type GetFeeHistoryOptions,
      type GetFeeHistoryQueryFnData,
      type GetFeeHistoryQueryKey,
      getFeeHistoryQueryKey,
      getFeeHistoryQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getFeeHistory`](https://viem.sh/docs/actions/public/getFeeHistory.html)</content>
</page>

<page>
  <title>getPublicClient | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getPublicClient</url>
  <content>Action for getting Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.

Import [‚Äã](#import)
-------------------

ts

    import { getPublicClient } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getPublicClient } from '@wagmi/core'
    import { config } from './config'
    
    const client = getPublicClient(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

If you want to optimize bundle size, you should use [`getClient`](https://wagmi.sh/core/api/actions/getClient) along with Viem's [tree-shakable actions](https://viem.sh/docs/clients/custom.html#tree-shaking) instead. Since Public Client has all public actions attached directly to it.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetClientParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Public Client.

index.tsconfig.ts

ts

    import { getPublicClient } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const client = getPublicClient(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetPublicClientReturnType } from '@wagmi/core'

`PublicClient | undefined`

Viem [`PublicClient`](https://viem.sh/docs/clients/public.html) instance.</content>
</page>

<page>
  <title>getProof | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getProof</url>
  <content>Action for return the account and storage values of the specified account including the Merkle-proof.

Import [‚Äã](#import)
-------------------

ts

    import { getProof } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getProof } from '@wagmi/core'
    import { config } from './config'
    
    await getProof(config, {
      address: '0x4200000000000000000000000000000000000016',
      storageKeys: [
        '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetProofParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

The account address to get the proof for.

index.tsconfig.ts

ts

    import { getProof } from '@wagmi/core'
    import { config } from './config'
    
    await getProof(config, {
      address: '0x4200000000000000000000000000000000000016', 
      storageKeys: [
        '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### storageKeys [‚Äã](#storagekeys)

`` `0x${string}`[] ``

Array of storage-keys that should be proofed and included.

index.tsconfig.ts

ts

    import { getProof } from '@wagmi/core'
    import { config } from './config'
    
    await getProof(config, {
      address: '0x4200000000000000000000000000000000000016',
      storageKeys: [ 
        '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Proof at a given block number.

index.tsconfig.ts

ts

    import { getProof } from '@wagmi/core'
    import { config } from './config'
    
    await getProof(config, {
      address: '0x4200000000000000000000000000000000000016',
      blockNumber: 42069n, 
      storageKeys: [
        '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Proof at a given block tag.

index.tsconfig.ts

ts

    import { getProof } from '@wagmi/core'
    import { config } from './config'
    
    await getProof(config, {
      address: '0x4200000000000000000000000000000000000016',
      blockTag: 'latest', 
      storageKeys: [
        '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The ID of chain to get the proof for.

index.tsconfig.ts

ts

    import { getProof } from '@wagmi/core'
    import { config } from './config'
    import { optimism } from '@wagmi/core/chains'
    
    await getProof(config, {
      chainId: optimism.id, 
      address: '0x4200000000000000000000000000000000000016',
      storageKeys: [
        '0x4a932049252365b3eedbc5190e18949f2ec11f39d3bef2d259764799a1b27d99',
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetProofReturnType } from '@wagmi/core'

`Proof`

Proof data.

Error [‚Äã](#error)
-----------------

ts

    import { type GetProofErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type getProofData,
      type getProofOptions,
      type getProofQueryFnData,
      type getProofQueryKey,
      getProofQueryKey,
      getProofQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getProof`](https://viem.sh/docs/actions/public/getProof.html)</content>
</page>

<page>
  <title>getToken | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getToken</url>
  <content>Action for fetching token info.

Import [‚Äã](#import)
-------------------

ts

    import { getToken } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getToken } from '@wagmi/core'
    import { config } from './config'
    
    const token = getToken(config, {
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetTokenParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

Address to get token for.

index.tsconfig.ts

ts

    import { getToken } from '@wagmi/core'
    import { config } from './config'
    
    const token = getToken(config, {
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getToken } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const token = await getToken(config, {
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### formatUnits [‚Äã](#formatunits)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.tsconfig.ts

ts

    import { getToken } from '@wagmi/core'
    import { config } from './config'
    
    const token = getToken(config, {
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
      formatUnits: 'ether', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetTokenReturnType } from '@wagmi/core'

### address [‚Äã](#address-1)

`Address`

Address of token.

### decimals [‚Äã](#decimals)

`number`

Number of decimals for token.

### name [‚Äã](#name)

`string | undefined`

Name of token.

### symbol [‚Äã](#symbol)

`string | undefined`

Symbol of token.

### totalSupply [‚Äã](#totalsupply)

`{ formatted: string; value: bigint; }`

Total supply of token. `formatted` is formatted using [`formatUnits`](#formatunits).

Error [‚Äã](#error)
-----------------

ts

    import { type GetTokenErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTokenData,
      type GetTokenOptions,
      type GetTokenQueryFnData,
      type GetTokenQueryKey,
      getTokenQueryKey,
      getTokenQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`multicall`](https://viem.sh/docs/contract/multicall)</content>
</page>

<page>
  <title>getStorageAt | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getStorageAt</url>
  <content>Action for returning the value from a storage slot at a given address.

Import [‚Äã](#import)
-------------------

ts

    import { getStorageAt } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getStorageAt } from '@wagmi/core'
    import { config } from './config'
    
    await getStorageAt(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      slot: '0x0',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetStorageAtParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

The contract address.

index.tsconfig.ts

ts

    import { getStorageAt } from '@wagmi/core'
    import { config } from './config'
    
    await getStorageAt(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
      slot: '0x0',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### slot [‚Äã](#slot)

`Hex`

The storage position (as a hex encoded value).

index.tsconfig.ts

ts

    import { getStorageAt } from '@wagmi/core'
    import { config } from './config'
    
    await getStorageAt(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      slot: '0x0', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

The block number to check the storage at.

index.tsconfig.ts

ts

    import { getStorageAt } from '@wagmi/core'
    import { config } from './config'
    
    await getStorageAt(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      blockNumber: 16280770n, 
      slot: '0x0',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the storage at.

index.tsconfig.ts

ts

    import { getStorageAt } from '@wagmi/core'
    import { config } from './config'
    
    await getStorageAt(config, {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      blockTag: 'safe', 
      slot: '0x0',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The chain ID to check the storage at.

index.tsconfig.ts

ts

    import { getStorageAt } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    await getStorageAt(config, {
      chainId: mainnet.id, 
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      slot: '0x0',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetStorageAtReturnType } from '@wagmi/core'

`Hex`

The value of the storage slot.

Error [‚Äã](#error)
-----------------

ts

    import { type GetStorageAtErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type getStorageAtData,
      type getStorageAtOptions,
      type getStorageAtQueryFnData,
      type getStorageAtQueryKey,
      getStorageAtQueryKey,
      getStorageAtQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getStorageAt`](https://viem.sh/docs/contract/getStorageAt)</content>
</page>

<page>
  <title>getTransactionConfirmations | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getTransactionConfirmations</url>
  <content>Action for fetching the number of blocks passed (confirmations) since the transaction was processed on a block. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

Import [‚Äã](#import)
-------------------

ts

    import { getTransactionConfirmations } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getTransactionConfirmations } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransactionConfirmations(config, {
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetTransactionConfirmationsParameters } from '@wagmi/core'

* * *

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

The hash of the transaction.

index.tsconfig.ts

ts

    import { getTransactionConfirmations } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransactionConfirmations(config, {
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### transactionReceipt [‚Äã](#transactionreceipt)

`TransactionReceipt | undefined`

The transaction receipt.

index.tsconfig.ts

ts

    import { getTransactionConfirmations } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransactionConfirmations(config, {
      transactionReceipt: { ... }, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getTransactionConfirmations } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const transaction = await getTransactionConfirmations(config, {
      chainId: mainnet.id, 
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetTransactionConfirmationsReturnType } from '@wagmi/core'

`bigint`

The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet.

Error [‚Äã](#error)
-----------------

ts

    import { type GetTransactionConfirmationsErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionConfirmationsData,
      type GetTransactionConfirmationsOptions,
      type GetTransactionConfirmationsQueryFnData,
      type GetTransactionConfirmationsQueryKey,
      getTransactionConfirmationsQueryKey,
      getTransactionConfirmationsQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getTransactionConfirmations`](https://viem.sh/docs/actions/public/getTransactionConfirmations.html)</content>
</page>

<page>
  <title>getTransaction | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getTransaction</url>
  <content>Action for fetching transactions given hashes or block identifiers.

Import [‚Äã](#import)
-------------------

ts

    import { getTransaction } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransaction(config, {
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetTransactionParameters } from '@wagmi/core'

* * *

### blockHash [‚Äã](#blockhash)

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransaction(config, {
      blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
      index: 0,
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransaction(config, {
      blockNumber: 17829139n, 
      index: 0,
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransaction(config, {
      blockTag: 'safe', 
      index: 0,
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const transaction = await getTransaction(config, {
      chainId: mainnet.id, 
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

Hash to get transaction.

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransaction(config, {
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### index [‚Äã](#index)

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)).

index.tsconfig.ts

ts

    import { getTransaction } from '@wagmi/core'
    import { config } from './config'
    
    const transaction = getTransaction(config, {
      blockTag: 'safe',
      index: 0
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetTransactionReturnType } from '@wagmi/core'

[`Transaction`](https://viem.sh/docs/glossary/types.html#transaction)

Error [‚Äã](#error)
-----------------

ts

    import { type GetTransactionErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionData,
      type GetTransactionOptions,
      type GetTransactionQueryFnData,
      type GetTransactionQueryKey,
      getTransactionQueryKey,
      getTransactionQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getTransaction`](https://viem.sh/docs/actions/public/getTransaction.html)</content>
</page>

<page>
  <title>getWalletClient | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getWalletClient</url>
  <content>Action for getting a Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

Import [‚Äã](#import)
-------------------

ts

    import { getWalletClient } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getWalletClient } from '@wagmi/core'
    import { config } from './config'
    
    const client = getWalletClient(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetWalletClientParameters } from '@wagmi/core'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

index.tsconfig.ts

ts

    import { getWalletClient } from '@wagmi/core'
    import { config } from './config'
    
    const client = getWalletClient(config, {
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

index.tsconfig.ts

ts

    import { getWalletClient } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const client = getWalletClient(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to get client for.
*   Defaults to current connector.

index.tsconfig.ts

ts

    import { getConnections, getWalletClient } from '@wagmi/core'
    import { config } from './config'
    
    const connections = getConnections(config)
    const client = getWalletClient(config, {
      connector: connections[0]?.connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetChainIdReturnType } from '@wagmi/core'

`WalletClient`

Viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) object for the current or provided connector.

Error [‚Äã](#error)
-----------------

ts

    import { type GetWalletClientErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetWalletClientData,
      type GetWalletClientOptions,
      type GetWalletClientQueryFnData,
      type GetWalletClientQueryKey,
      getWalletClientQueryKey,
      getWalletClientQueryOptions,
    } from '@wagmi/core/query'</content>
</page>

<page>
  <title>getTransactionReceipt | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getTransactionReceipt</url>
  <content>Action for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

Import [‚Äã](#import)
-------------------

ts

    import { getTransactionReceipt } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    await getTransactionReceipt(config, {
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetTransactionReceiptParameters } from '@wagmi/core'

### hash [‚Äã](#hash)

`` `0x${string}` ``

A transaction hash.

index.tsconfig.ts

ts

    import { getTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    await getTransactionReceipt(config, {
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

index.tsconfig.ts

ts

    import { getTransactionReceipt } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    await getTransactionReceipt(config, {
      chainId: mainnet.id, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetTransactionReceiptReturnType } from '@wagmi/core'

[`TransactionReceipt`](https://viem.sh/docs/glossary/types.html#transactionreceipt)

The transaction receipt.

Error [‚Äã](#error)
-----------------

ts

    import { type GetTransactionReceiptErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type getTransactionReceiptData,
      type getTransactionReceiptOptions,
      type getTransactionReceiptQueryFnData,
      type getTransactionReceiptQueryKey,
      getTransactionReceiptQueryKey,
      getTransactionReceiptQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getTransactionReceipt`](https://viem.sh/docs/actions/public/getTransactionReceipt.html)</content>
</page>

<page>
  <title>getTransactionCount | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getTransactionCount</url>
  <content>Action for fetching the number of transactions an Account has sent.

Import [‚Äã](#import)
-------------------

ts

    import { getTransactionCount } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const transactionCount = getTransactionCount(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetTransactionCountParameters } from '@wagmi/core'

* * *

### address [‚Äã](#address)

`Address`

The address of the account.

index.tsconfig.ts

ts

    import { getTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const transactionCount = getTransactionCount(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Get the count at a block number.

index.tsconfig.ts

ts

    import { getTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const transactionCount = getTransactionCount(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      blockNumber: 17829139n, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Get the count at a block tag.

index.tsconfig.ts

ts

    import { getTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const transactionCount = getTransactionCount(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      blockTag: 'latest', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { getTransactionCount } from '@wagmi/core'
    import { config } from './config'
    
    const transactionCount = getTransactionCount(config, {
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetTransactionCountReturnType } from '@wagmi/core'

`number`

The number of transactions an account has sent.

Error [‚Äã](#error)
-----------------

ts

    import { type GetTransactionCountErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionCountData,
      type GetTransactionCountOptions,
      type GetTransactionCountQueryFnData,
      type GetTransactionCountQueryKey,
      getTransactionCountQueryKey,
      getTransactionCountQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`getTransactionCount`](https://viem.sh/docs/actions/public/getTransactionCount.html)</content>
</page>

<page>
  <title>prepareTransactionRequest | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/prepareTransactionRequest</url>
  <content>Action for preparing a transaction request for signing by populating a nonce, gas limit, fee values, and a transaction type.

Import [‚Äã](#import)
-------------------

ts

    import { prepareTransactionRequest } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type PrepareTransactionRequestParameters } from '@wagmi/core'

### account [‚Äã](#account)

`Account | Address | undefined`

The Account to send the transaction from.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`` `0x${string}` | undefined ``

The transaction recipient or contract address.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',  
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      accessList: [ 
        {
          address: '0x1',
          storageKeys: ['0x1'],
        },
      ],
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to prepare the transaction request for.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      chainId: mainnet.id, 
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price (in wei) to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      gasPrice: parseGwei('20'), 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      maxFeePerGas: parseGwei('20'), 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas (in wei). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### nonce [‚Äã](#nonce)

`number | undefined`

Unique number identifying this transaction.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
      nonce: 5, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### parameters [‚Äã](#parameters-1)

`("fees" | "gas" | "nonce" | "type")[] | undefined`

Parameters to prepare.

For instance, if `["gas", "nonce"]` is provided, then only the `gas` and `nonce` parameters will be prepared.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      parameters: ['gas', 'nonce'], 
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

The transaction recipient or contract address.

index.tsconfig.ts

ts

    import { prepareTransactionRequest } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    await prepareTransactionRequest(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
      value: parseEther('1'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type PrepareTransactionRequestReturnType } from '@wagmi/core'

[`TransactionRequest`](https://viem.sh/docs/glossary/types.html#transactionrequest)

The transaction request.

Error [‚Äã](#error)
-----------------

ts

    import { type PrepareTransactionRequestErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type prepareTransactionRequestData,
      type prepareTransactionRequestOptions,
      type prepareTransactionRequestQueryFnData,
      type prepareTransactionRequestQueryKey,
      prepareTransactionRequestQueryKey,
      prepareTransactionRequestQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`prepareTransactionRequest`](https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html)</content>
</page>

<page>
  <title>reconnect | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/reconnect</url>
  <content>Action for reconnecting [connectors](https://wagmi.sh/core/api/connectors).

Import [‚Äã](#import)
-------------------

ts

    import { reconnect } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { reconnect } from '@wagmi/core'
    import { injected } from '@wagmi/connectors'
    import { config } from './config'
    
    const result = await reconnect(config, { connectors: [injected()] })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type ReconnectParameters } from '@wagmi/core'

### connectors [‚Äã](#connectors)

`(CreateConnectorFn | Connector)[] | undefined`

*   [Connectors](https://wagmi.sh/core/api/connectors) to reconnect to.
*   Defaults to [`Config['connectors']`](https://wagmi.sh/core/api/createConfig#connectors).

index.tsconfig.ts

ts

    import { reconnect } from '@wagmi/core'
    import { injected } from '@wagmi/connectors'
    import { config } from './config'
    
    const result = await reconnect(config, {
        connectors: [injected()], 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type ReconnectReturnType } from '@wagmi/core'

`Connection[]`

[Connections](https://wagmi.sh/core/api/createConfig#connection) that were successfully reconnected.

Error [‚Äã](#error)
-----------------

ts

    import { type ReconnectErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReconnectData,
      type ReconnectVariables,
      type ReconnectMutate,
      type ReconnectMutateAsync,
      reconnectMutationOptions,
    } from '@wagmi/core/query'</content>
</page>

<page>
  <title>readContract | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/readContract</url>
  <content>Action for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

Import [‚Äã](#import)
-------------------

ts

    import { readContract } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type ReadContractParameters } from '@wagmi/core'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi, 
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf',
      args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address`

The contract's address.

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'totalSupply',
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf',
      args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'], 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to call contract at.

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      blockNumber: 17829139n, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      blockTag: 'safe', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      chainId: mainnet.id, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsabi.tsconfig.ts

ts

    import { readContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await readContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf', 
      args: ['0xd2135CfB216b74109775236E36d4b433F1DF507B'],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type ReadContractReturnType } from '@wagmi/core'

`unknown`

*   Result of contract read-only function.
*   Inferred from [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args).

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type ReadContractErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReadContractData,
      type ReadContractOptions,
      type ReadContractQueryFnData,
      type ReadContractQueryKey,
      readContractQueryKey,
      readContractQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`readContract`](https://viem.sh/docs/contract/readContract.html)</content>
</page>

<page>
  <title>signMessage | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/signMessage</url>
  <content>Action for signing messages.

Import [‚Äã](#import)
-------------------

ts

    import { signMessage } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { signMessage } from '@wagmi/core'
    import { config } from './config'
    
    await signMessage(config, { message: 'hello world' })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SignMessageParameters } from '@wagmi/core'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when signing message. Throws if account is not found on [`connector`](#connector).

index.tsconfig.ts

ts

    import { signMessage } from '@wagmi/core'
    import { config } from './config'
    
    const result = await signMessage(config, {
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      message: 'hello world',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/core/api/connectors) to sign message with.

index.tsconfig.ts

ts

    import { getAccount, signMessage } from '@wagmi/core'
    import { config } from './config'
    
    const { connector } = getAccount(config)
    const result = await signMessage(config, {
      connector, 
      message: 'hello world',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### message [‚Äã](#message)

`string | { raw: Hex | ByteArray }`

Message to sign.

index.tsconfig.ts

ts

    import { signMessage } from '@wagmi/core'
    import { config } from './config'
    
    const result = await signMessage(config, {
      message: 'hello world', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

TIP

By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

ts

    import { signMessage } from '@wagmi/core'
    import { config } from './config'
    
    const result = await signMessage(config, {
      message: { raw: '0x68656c6c6f20776f726c64' }, 
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SignMessageReturnType } from '@wagmi/core'

[`Hex`](https://viem.sh/docs/glossary/types.html#hex)

The signed message.

Error [‚Äã](#error)
-----------------

ts

    import { type SignMessageErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SignMessageData,
      type SignMessageVariables,
      type SignMessageMutate,
      type SignMessageMutateAsync,
      signMessageMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`signMessage`](https://viem.sh/docs/actions/wallet/signMessage.html)</content>
</page>

<page>
  <title>multicall | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/multicall</url>
  <content>Action for batching up multiple functions on a contract in a single RPC call via the [Multicall3 contract](https://github.com/mds1/multicall).

Import [‚Äã](#import)
-------------------

ts

    import { multicall } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const wagmigotchiContract = {
      address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
      abi: wagmigotchiABI,
    } as const
    const mlootContract = {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
    } as const
    
    const result = await multicall(config, {
      contracts: [
        {
          ...wagmigotchiContract,
          functionName: 'getAlive',
        },
        {
          ...wagmigotchiContract,
          functionName: 'getBoredom',
        },
        {
          ...mlootContract,
          functionName: 'getChest',
          args: [69],
        },
        {
          ...mlootContract,
          functionName: 'getWaist',
          args: [69],
        },
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MulticallParameters } from '@wagmi/core'

### contracts [‚Äã](#contracts)

`readonly Contract[]`

Set of contracts to call.

#### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
          chainId: 1,
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### allowFailure [‚Äã](#allowfailure)

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `multicall` will fail silently and its error will be logged in the results array. Defaults to `true`.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      allowFailure: false,
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### batchSize [‚Äã](#batchsize)

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      batchSize: 1_024,
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`number`

The block number to perform the read against.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      blockNumber: 69420n,
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      blockTag: 'safe',
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### multicallAddress [‚Äã](#multicalladdress)

`Address`

Address of multicall contract.

index.tsxconfig.ts

tsx

    import { multicall } from '@wagmi/core'
    import { config } from './config'
    
    const result = await multicall(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
      multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11',
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type MulticallReturnType } from '@wagmi/core'

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`contracts[number]['abi']`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type MulticallErrorType } from '@wagmi/core'

Viem [‚Äã](#viem)
---------------

*   [`multicall`](https://viem.sh/docs/actions/public/multicall.html)</content>
</page>

<page>
  <title>readContracts | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/readContracts</url>
  <content>Action for calling multiple read methods on a contract.

Import [‚Äã](#import)
-------------------

ts

    import { readContracts } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const wagmigotchiContract = {
      address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
      abi: wagmigotchiABI,
    } as const
    const mlootContract = {
      address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
      abi: mlootABI,
    } as const
    
    const result = await readContracts(config, {
      contracts: [
        {
          ...wagmigotchiContract,
          functionName: 'getAlive',
        },
        {
          ...wagmigotchiContract,
          functionName: 'getBoredom',
        },
        {
          ...mlootContract,
          functionName: 'getChest',
          args: [69],
        },
        {
          ...mlootContract,
          functionName: 'getWaist',
          args: [69],
        },
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type ReadContractsParameters } from '@wagmi/core'

### contracts [‚Äã](#contracts)

`readonly Contract[]`

Set of contracts to call.

#### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
          chainId: 1,
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

#### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### allowFailure [‚Äã](#allowfailure)

`boolean`

Whether or not the Hook should throw if a call reverts. If set to `true` (default), and a call reverts, then `readContracts` will fail silently and its error will be logged in the results array. Defaults to `true`.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      allowFailure: false,
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### batchSize [‚Äã](#batchsize)

`number`

The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. Defaults to `1024`.

> Note: Some RPC Providers limit the amount of calldata (`data`) that can be sent in a single `eth_call` request. It is best to check with your RPC Provider to see if there are any calldata size limits to `eth_call` requests.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      batchSize: 1_024,
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`number`

The block number to perform the read against.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      blockNumber: 69420n,
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to read against.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      blockTag: 'safe',
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### multicallAddress [‚Äã](#multicalladdress)

`Address`

Address of multicall contract.

index.tsxconfig.ts

tsx

    import { readContracts } from '@wagmi/core'
    import { config } from './config'
    
    const result = await readContracts(config, {
      contracts: [
        {
          address: '0x1dfe7ca09e99d10835bf73044a23b73fc20623df',
          abi: mlootABI,
          functionName: 'getChest',
          args: [69],
        },
        // ...
      ],
      multicallAddress: '0xca11bde05977b3631167028862be2a173976ca11',
    })

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type ReadContractsReturnType } from '@wagmi/core'

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`contracts[number]['abi']`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type ReadContractsErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReadContractsData,
      type ReadContractsOptions,
      type ReadContractsQueryFnData,
      type ReadContractsQueryKey,
      readContractsQueryKey,
      readContractsQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`multicall`](https://viem.sh/docs/actions/public/multicall.html) when supported by current chain.
*   [`readContract`](https://viem.sh/docs/contract/readContract.html) when multicall is not supported.</content>
</page>

<page>
  <title>sendTransaction | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/sendTransaction</url>
  <content>Action for creating, signing, and sending transactions to networks.

Import [‚Äã](#import)
-------------------

ts

    import { sendTransaction } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SendTransactionParameters } from '@wagmi/core'

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      accessList: [{ 
        address: '0x1', 
        storageKeys: ['0x1'], 
      }], 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when sending transaction. Throws if account is not found on [`connector`](#connector).

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      chainId: mainnet.id, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to send transaction with.
*   Defaults to current connector.

index.tsconfig.ts

ts

    import { getConnections, sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const connections = getConnections(config)
    const result = await sendTransaction(config, {
      connector: connections[0]?.connector, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded args.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined | null`

Gas provided for transaction execution.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      gas: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      gasPrice: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      maxFeePerGas: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      nonce: 123, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`Address`

The transaction recipient or contract address.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      type: 'eip1559', 
      value: parseEther('0.01'),
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsconfig.ts

ts

    import { sendTransaction } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = await sendTransaction(config, {
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      value: parseEther('0.01'), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SendTransactionReturnType } from '@wagmi/core'

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

Transaction hash.

Error [‚Äã](#error)
-----------------

ts

    import { type SendTransactionErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SendTransactionData,
      type SendTransactionVariables,
      type SendTransactionMutate,
      type SendTransactionMutateAsync,
      sendTransactionMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html)</content>
</page>

<page>
  <title>switchAccount | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/switchAccount</url>
  <content>Action for switching the current account.

Import [‚Äã](#import)
-------------------

ts

    import { switchAccount } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getConnections, switchAccount } from '@wagmi/core'
    import { config } from './config'
    
    const connections = getConnections(config)
    const result = await switchAccount(config, {
      connector: connections[0]?.connector,
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SwitchAccountParameters } from '@wagmi/core'

### connector [‚Äã](#connector)

`Connector`

[Connector](https://wagmi.sh/core/api/connectors) to switch to.

index.tsconfig.ts

ts

    import { getConnections, switchAccount } from '@wagmi/core'
    import { config } from './config'
    
    const connections = getConnections(config)
    const result = await switchAccount(config, {
      connector: connections[0]?.connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SwitchAccountReturnType } from '@wagmi/core'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Connected accounts from connector.

### chainId [‚Äã](#chainid)

`number`

Connected chain ID from connector.

Error [‚Äã](#error)
-----------------

ts

    import { type SwitchAccountErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SwitchAccountData,
      type SwitchAccountVariables,
      type SwitchAccountMutate,
      type SwitchAccountMutateAsync,
      switchAccountMutationOptions,
    } from '@wagmi/core/query'</content>
</page>

<page>
  <title>switchChain | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/switchChain</url>
  <content>Action for switching the target chain for a connector or the Wagmi [`Config`](https://wagmi.sh/core/api/createConfig#config).

Import [‚Äã](#import)
-------------------

ts

    import { switchChain } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { switchChain } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    await switchChain(config, { chainId: mainnet.id })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

TIP

When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](https://wagmi.sh/core/api/createConfig#config).

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SwitchChainParameters } from '@wagmi/core'

### addEthereumChainParameter [‚Äã](#addethereumchainparameter)

`{ chainName: string; nativeCurrency?: { name: string; symbol: string; decimals: number } | undefined; rpcUrls: readonly string[]; blockExplorerUrls?: string[] | undefined; iconUrls?: string[] | undefined } | undefined`

[EIP-3085 parameters](https://eips.ethereum.org/EIPS/eip-3085) to use when adding chain to connector (when supported).

index.tsconfig.ts

ts

    import { switchChain } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const result = await switchChain(config, {
      addEthereumChainParameter: { 
        iconUrls: ['https://example.com/icon.png'], 
      }, 
      chainId: mainnet.id,
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to switch to.

index.tsconfig.ts

ts

    import { switchChain } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const result = await switchChain(config, {
      chainId: mainnet.id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector`

[Connector](https://wagmi.sh/core/api/connectors) to switch chain with.

index.tsconfig.ts

ts

    import { getConnections, switchAccount } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const connections = getConnections(config)
    const result = await switchChain(config, {
      chainId: mainnet.id,
      connector: connections[0]?.connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SwitchChainReturnType } from '@wagmi/core'

`Chain`

Chain that was switched to.

Error [‚Äã](#error)
-----------------

ts

    import { type SwitchChainErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SwitchChainData,
      type SwitchChainVariables,
      type SwitchChainMutate,
      type SwitchChainMutateAsync,
      switchChainMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`switchChain`](https://viem.sh/docs/actions/wallet/switchChain.html) when connected.</content>
</page>

<page>
  <title>watchAccount | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchAccount</url>
  <content>Subscribe to account changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchAccount } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchAccount } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchAccount(config, {
      onChange(data) {
        console.log('Account changed!', data)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchAccountParameters } from '@wagmi/core'

### onChange [‚Äã](#onchange)

`onChange(account: GetAccountReturnType, prevAccount: GetAccountReturnType): void`

Callback function called when account changes.

index.tsconfig.ts

ts

    import { watchAccount } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchAccount(config, {
      onChange(account) { 
        console.log('Account changed!', account)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchAccountReturnType } from '@wagmi/core'

Function for cleaning up watcher.</content>
</page>

<page>
  <title>verifyMessage | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/verifyMessage</url>
  <content>Action for verify that a message was signed by the provided address. It supports verifying messages that were signed by either a Smart Contract Account or Externally Owned Account.

Import [‚Äã](#import)
-------------------

ts

    import { verifyMessage } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: 'hello world',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type VerifyMessageParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

The Ethereum address that signed the original message.

index.tsconfig.ts

ts

    import { verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      message: 'hello world',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### message [‚Äã](#message)

`string | { raw: Hex | ByteArray }`

The message to be verified.

By default, wagmi verifies the UTF-8 representation of the message.

index.tsconfig.ts

ts

    import { getAccount, verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: 'hello world', 
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

TIP

By default, viem signs the UTF-8 representation of the message. To sign the data representation of the message, you can use the `raw` attribute.

ts

    import { verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: { raw: '0x68656c6c6f20776f726c64' } 
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

### signature [‚Äã](#signature)

`Hex | ByteArray`

The signature that was generated by signing the message with the address's signer.

index.tsconfig.ts

ts

    import { verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: 'hello world',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

index.tsconfig.ts

ts

    import { verifyMessage } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    await verifyMessage(config, {
      chainId: mainnet.id, 
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: 'hello world',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

index.tsconfig.ts

ts

    import { verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      blockNumber: 12345678n, 
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: 'hello world',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a message that was signed by a Smart Contract Account. The block tag to check if the contract was already deployed.

index.tsconfig.ts

ts

    import { verifyMessage } from '@wagmi/core'
    import { config } from './config'
    
    await verifyMessage(config, {
      blockTag: 'latest', 
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      message: 'hello world',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type VerifyMessageReturnType } from '@wagmi/core'

`boolean`

Whether the signed message is valid for the given address.

Error [‚Äã](#error)
-----------------

ts

    import { type VerifyMessageErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type VerifyMessageData,
      type VerifyMessageVariables,
      type VerifyMessageMutate,
      type VerifyMessageMutateAsync,
      verifyMessageMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`verifyMessage`](https://viem.sh/docs/actions/public/verifyMessage.html)</content>
</page>

<page>
  <title>signTypedData | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/signTypedData</url>
  <content>Action for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

Import [‚Äã](#import)
-------------------

ts

    import { signTypedData } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { signTypedData } from '@wagmi/core'
    import { config } from './config'
    
    const result = await signTypedData(config, {
      types: {
        Person: [
          { name: 'name', type: 'string' },
          { name: 'wallet', type: 'address' },
        ],
        Mail: [
          { name: 'from', type: 'Person' },
          { name: 'to', type: 'Person' },
          { name: 'contents', type: 'string' },
        ],
      },
      primaryType: 'Mail',
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SignTypedDataParameters } from '@wagmi/core'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

index.tstypedData.tsconfig.ts

ts

    import { signTypedData } from '@wagmi/core'
    import { config } from './config'
    import { types } from './typedData'
    
    const result = await signTypedData(config, {
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      types,
      primaryType: 'Mail',
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })

ts

    import type { TypedData } from 'viem'
    
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const satisfies TypedData

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/core/api/connectors) to sign data with.

index.tstypedData.tsconfig.ts

ts

    import { getAccount, signTypedData } from '@wagmi/core'
    import { config } from './config'
    import { types } from './typedData'
    
    const { connector } = getAccount(config)
    const result = await signTypedData(config, {
      connector, 
      types,
      primaryType: 'Mail',
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })

ts

    import type { TypedData } from 'viem'
    
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const satisfies TypedData

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### domain [‚Äã](#domain)

`TypedDataDomain | undefined`

*   The typed data domain.
*   If `EIP712Domain` key exists in [`types`](#types), `domain` schema is inferred from it.

index.tstypedData.tsconfig.ts

ts

    import { signTypedData } from '@wagmi/core'
    import { config } from './config'
    import { types } from './typedData'
    
    const result = await signTypedData(config, {
      domain: { 
        name: 'Ether Mail', 
        chainId: 1, 
        verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC', 
        version: '1', 
      }, 
      types,
      primaryType: 'Mail',
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })

ts

    import type { TypedData } from 'viem'
    
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const satisfies TypedData

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### message [‚Äã](#message)

`Record<string, unknown>`

*   Data to sign.
*   Type inferred from [`types`](#types) and [`primaryType`](#primarytype).

index.tstypedData.tsconfig.ts

ts

    import { signTypedData } from '@wagmi/core'
    import { config } from './config'
    import { types } from './typedData'
    
    const result = await signTypedData(config, {
      types,
      primaryType: 'Mail',
      message: { 
        from: { 
          name: 'Cow', 
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826', 
        }, 
        to: { 
          name: 'Bob', 
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB', 
        }, 
        contents: 'Hello, Bob!', 
      }, 
    })

ts

    import type { TypedData } from 'viem'
    
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const satisfies TypedData

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### primaryType [‚Äã](#primarytype)

`string`

*   The primary type to extract from [`types`](#types) and use in [`message`](#message).
*   Type inferred from [`types`](#types).

index.tstypedData.tsconfig.ts

ts

    import { signTypedData } from '@wagmi/core'
    import { config } from './config'
    import { types } from './typedData'
    
    const result = await signTypedData(config, {
      types,
      primaryType: 'Mail', 
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })

ts

    import type { TypedData } from 'viem'
    
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const satisfies TypedData

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### types [‚Äã](#types)

`TypedData`

*   The type definitions for the typed data.
*   By defining inline or adding a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) to `types`, TypeScript will infer the correct types for [`message`](#message) and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

index.tsconfig.ts

ts

    import { signTypedData } from '@wagmi/core'
    import { config } from './config'
    
    const result = await signTypedData(config, {
      types: { 
        Person: [ 
          { name: 'name', type: 'string' }, 
          { name: 'wallet', type: 'address' }, 
        ], 
        Mail: [ 
          { name: 'from', type: 'Person' }, 
          { name: 'to', type: 'Person' }, 
          { name: 'contents', type: 'string' }, 
        ], 
      }, 
      primaryType: 'Mail',
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SignTypedDataReturnType } from '@wagmi/core'

[`Hex`](https://viem.sh/docs/glossary/types.html#hex)

The signed data.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

InlineConst-Asserted

ts

    const  = await (, {
      : {
        : [
          { : 'name', : 'string' },
          { : 'wallet', : 'address' },
        ],
        : [
          { : 'from', : 'Person' },
          { : 'to', : 'Person' },
          { : 'contents', : 'string' },
        ],
      },
      : 'Mail',
    
    
      : {
    
    
    
    
    
    
    
    
    
    
    
    
        : {
          : 'Cow',
          : '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        : {
          : 'Bob',
          : '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        : 'Hello, Bob!',
      },
    })

ts

    const  = {
      : [
        { : 'name', : 'string' },
        { : 'wallet', : 'address' },
      ],
      : [
        { : 'from', : 'Person' },
        { : 'to', : 'Person' },
        { : 'contents', : 'string' },
      ],
    } as 
    
    const  = await (, {
      ,
      : 'Mail',
    
    
      : {
    
    
    
    
    
    
    
    
    
    
    
    
        : {
          : 'Cow',
          : '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        : {
          : 'Bob',
          : '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        : 'Hello, Bob!',
      },
    })

Error [‚Äã](#error)
-----------------

ts

    import { type SignTypedDataErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SignTypedDataData,
      type SignTypedDataVariables,
      type SignTypedDataMutate,
      type SignTypedDataMutateAsync,
      signTypedDataMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`signTypedData`](https://viem.sh/docs/actions/wallet/signTypedData.html)</content>
</page>

<page>
  <title>waitForTransactionReceipt | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/waitForTransactionReceipt</url>
  <content>Action that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

Import [‚Äã](#import)
-------------------

ts

    import { waitForTransactionReceipt } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    const transactionReceipt = waitForTransactionReceipt(config, {
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WaitForTransactionReceiptParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const transactionReceipt = await waitForTransactionReceipt(config, {
      chainId: mainnet.id, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### confirmations [‚Äã](#confirmations)

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

index.tsconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    const transactionReceipt = await waitForTransactionReceipt(config, {
      confirmations: 2, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onReplaced [‚Äã](#onreplaced)

`(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined`

Optional callback to emit if the transaction has been replaced.

index.tsconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    const transactionReceipt = await waitForTransactionReceipt(config, {
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      onReplaced: replacement => console.log(replacement), 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### hash [‚Äã](#hash)

`` `0x${string}` ``

The transaction hash to wait for.

index.tsconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    const transactionReceipt = await waitForTransactionReceipt(config, {
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsconfig.ts

ts

    import { waitForTransactionReceipt } from '@wagmi/core'
    import { config } from './config'
    
    const transactionReceipt = await waitForTransactionReceipt(config, {
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      pollingInterval: 1_000, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WaitForTransactionReceiptReturnType } from '@wagmi/core'

[`TransactionReceipt`](https://viem.sh/docs/glossary/types.html#transactionreceipt)

The transaction receipt.

Error [‚Äã](#error)
-----------------

ts

    import { type WaitForTransactionReceiptErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WaitForTransactionReceiptData,
      type WaitForTransactionReceiptOptions,
      type WaitForTransactionReceiptQueryFnData,
      type WaitForTransactionReceiptQueryKey,
      waitForTransactionReceiptQueryKey,
      waitForTransactionReceiptQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`waitForTransactionReceipt`](https://viem.sh/docs/actions/public/waitForTransactionReceipt.html)</content>
</page>

<page>
  <title>watchAsset | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchAsset</url>
  <content>Action for requesting user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.

Import [‚Äã](#import)
-------------------

ts

    import { watchAsset } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchAsset } from '@wagmi/core'
    import { config } from './config'
    
    await watchAsset(config, {
      type: 'ERC20',
      options: {
        address: '0x0000000000000000000000000000000000000000',
        symbol: 'WAGMI',
        decimals: 18,
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchAssetParameters } from '@wagmi/core'

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/core/api/connectors) to sign message with.

index.tsconfig.ts

ts

    import { getAccount, watchAsset } from '@wagmi/core'
    import { config } from './config'
    
    const { connector } = getAccount(config)
    const result = await watchAsset(config, {
      connector, 
      options: {
        address: '0x0000000000000000000000000000000000000000',
        symbol: 'WAGMI',
        decimals: 18,
      },
      type: 'ERC20',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### options [‚Äã](#options)

`{ address: string; symbol: string; decimals: number; image?: string | undefined; }`

Asset options.

index.tsconfig.ts

ts

    import { watchAsset } from '@wagmi/core'
    import { config } from './config'
    
    const result = await watchAsset(config, {
      options: { 
        address: '0x0000000000000000000000000000000000000000', 
        symbol: 'WAGMI', 
        decimals: 18, 
      }, 
      type: 'ERC20',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'ERC20'`

Type of asset.

index.tsconfig.ts

ts

    import { watchAsset } from '@wagmi/core'
    import { config } from './config'
    
    const result = await watchAsset(config, {
      options: {
        address: '0x0000000000000000000000000000000000000000',
        symbol: 'WAGMI',
        decimals: 18,
      },
      type: 'ERC20', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchAssetReturnType } from '@wagmi/core'

`boolean`

Returns a boolean indicating if the token was successfully added.

Error [‚Äã](#error)
-----------------

ts

    import { type WatchAssetErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WatchAssetData,
      type WatchAssetVariables,
      type WatchAssetMutate,
      type WatchAssetMutateAsync,
      watchAssetMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`watchAsset`](https://viem.sh/docs/actions/wallet/watchAsset.html)</content>
</page>

<page>
  <title>simulateContract | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/simulateContract</url>
  <content>Action for simulating/validating a contract interaction.

Import [‚Äã](#import)
-------------------

ts

    import { simulateContract } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SimulateContractParameters } from '@wagmi/core'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi, 
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      accessList: [{ 
        address: '0x1', 
        storageKeys: ['0x1'], 
      }], 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address`

The contract's address.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [ 
        '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
        123n, 
      ], 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to simulate against.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      blockNumber: 17829139n, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to simulate against.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      blockTag: 'safe', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      chainId: mainnet.id, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/core/api/connectors) to simulate transaction with.

index.tsabi.tsconfig.ts

ts

    import { getAccount, simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const { connector } = getAccount(config)
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      connector, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### dataSuffix [‚Äã](#datasuffix)

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      dataSuffix: '0xdeadbeef', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'approve', 
      args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 123n]
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      gas: parseGwei('20'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      gasPrice: parseGwei('20'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      maxFeePerGas: parseGwei('20'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      nonce: 123, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      type: 'eip1559', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsabi.tsconfig.ts

ts

    import { simulateContract } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      value: parseEther('0.01'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SimulateContractReturnType } from '@wagmi/core'

The simulation result and write request.

### request [‚Äã](#request)

Write request that includes [parameters](#parameters).

### response [‚Äã](#response)

`unknown`

*   Result of contract simulation.
*   Inferred from [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args).

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type SimulateContractErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SimulateContractData,
      type SimulateContractOptions,
      type SimulateContractQueryFnData,
      type SimulateContractQueryKey,
      simulateContractQueryKey,
      simulateContractQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`simulateContract`](https://viem.sh/docs/contract/simulateContract.html)</content>
</page>

<page>
  <title>watchBlockNumber | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchBlockNumber</url>
  <content>Action that watches for block number changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchBlockNumber } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchBlockNumberParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      chainId: mainnet.id, 
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitOnBegin [‚Äã](#emitonbegin)

`boolean | undefined`

Whether or not to emit the latest block number to the callback when the subscription opens.

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      emitOnBegin: true, 
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitMissed [‚Äã](#emitmissed)

`boolean | undefined`

Whether or not to emit the missed block numbers to the callback.

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      emitMissed: true, 
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onBlockNumber [‚Äã](#onblocknumber)

`(blockNumber: bigint, prevBlockNumber: bigint | undefined) => void`

Callback for when block number changes.

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      onBlockNumber(blockNumber) { 
        console.log('Block number changed!', blockNumber) 
      }, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      onBlockNumber(blockNumber) { 
        console.log('Block number changed!', blockNumber) 
      }, 
      onError(error) { 
        console.error('Block number error', error) 
      }, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      onBlockNumber(blockNumber) { 
        console.log('Block number changed!', blockNumber) 
      }, 
      poll: true, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      onBlockNumber(blockNumber) { 
        console.log('Block number changed!', blockNumber) 
      }, 
      pollingInterval: 1_000, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsconfig.ts

ts

    import { watchBlockNumber } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlockNumber(config, {
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
      syncConnectedChain: false, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchBlockNumberReturnType } from '@wagmi/core'

Function for cleaning up watcher.

Viem [‚Äã](#viem)
---------------

*   [`watchBlockNumber`](https://viem.sh/docs/actions/public/watchBlockNumber.html)</content>
</page>

<page>
  <title>watchChainId | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchChainId</url>
  <content>Subscribe to chain ID changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchChainId } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchChainId } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchChainId(config, {
      onChange(chainId) {
        console.log('Chain ID changed!', chainId)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchChainIdParameters } from '@wagmi/core'

### onChange [‚Äã](#onchange)

`onChange(chainId: GetChainIdReturnType, prevChainId: GetChainIdReturnType): void`

Callback function called when chain ID changes.

index.tsconfig.ts

ts

    import { watchChainId } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchChainId(config, {
      onChange(chainId) { 
        console.log('Chain ID changed!', chainId)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchChainIdReturnType } from '@wagmi/core'

Function for cleaning up watcher.</content>
</page>

<page>
  <title>watchClient | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchClient</url>
  <content>Subscribe to Client changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchClient } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchClient } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchClient(config, {
      onChange(client) {
        console.log('Client changed!', client)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchClientParameters } from '@wagmi/core'

### onChange [‚Äã](#onchange)

`onChange(client: GetClientReturnType, prevClient: GetClientReturnType): void`

Callback function called when Client changes.

index.tsconfig.ts

ts

    import { watchClient } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchClient(config, {
      onChange(client) { 
        console.log('Client changed!', client)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchClientReturnType } from '@wagmi/core'

Function for cleaning up watcher.</content>
</page>

<page>
  <title>watchConnections | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchConnections</url>
  <content>Subscribe to connections changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchConnections } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchConnections } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchConnections(config, {
      onChange(data) {
        console.log('Connections changed!', data)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchConnectionsParameters } from '@wagmi/core'

### onChange [‚Äã](#onchange)

`onChange(connections: GetConnectionsReturnType, prevConnections: GetConnectionsReturnType): void`

Callback function called when connections changes.

index.tsconfig.ts

ts

    import { watchConnections } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchConnections(config, {
      onChange(data) { 
        console.log('Connections changed!', data)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchConnectionsReturnType } from '@wagmi/core'

Function for cleaning up watcher.</content>
</page>

<page>
  <title>verifyTypedData | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/verifyTypedData</url>
  <content>Action for verify that a typed data was signed by the provided address. It supports verifying typed data that were signed by either a Smart Contract Account or Externally Owned Account.

Import [‚Äã](#import)
-------------------

ts

    import { verifyTypedData } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain,
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type VerifyTypedDataParameters } from '@wagmi/core'

### address [‚Äã](#address)

`Address`

The Ethereum address that signed the original typed data.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain,
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### domain [‚Äã](#domain)

`TypedDataDomain`

The typed data domain.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain: { 
        name: 'Ether Mail',
        version: '1',
        chainId: 1,
        verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
      },
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### types [‚Äã](#types)

The type definitions for the typed data.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain,
      types: { 
        Person: [
          { name: 'name', type: 'string' },
          { name: 'wallet', type: 'address' },
        ],
        Mail: [
          { name: 'from', type: 'Person' },
          { name: 'to', type: 'Person' },
          { name: 'contents', type: 'string' },
        ],
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### primaryType [‚Äã](#primarytype)

`string`

The primary `type` to extract from types and use in `value`.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain,
      types: {
        Person: [
          { name: 'name', type: 'string' },
          { name: 'wallet', type: 'address' },
        ],
        Mail: [ 
          { name: 'from', type: 'Person' },
          { name: 'to', type: 'Person' },
          { name: 'contents', type: 'string' },
        ],
      },
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail', 
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### message [‚Äã](#message)

Type inferred from `types` & `primaryType`.

The message to be verified.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain,
      types,
      message: { 
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### signature [‚Äã](#signature)

`Hex | ByteArray`

The signature that was generated by signing the typed data with the address's signer.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      domain,
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },  
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c', 
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The ID of chain to check if the contract was already deployed.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      chainId: mainnet.id, 
      domain,
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      blockNumber: 12345678n, 
      domain,
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Only used when verifying a typed data that was signed by a Smart Contract Account. The block number to check if the contract was already deployed.

index.tsdata.tsconfig.ts

ts

    import { verifyTypedData } from '@wagmi/core'
    import { domain, types } from './data'
    import { config } from './config'
    
    const valid = await verifyTypedData(config, {
      blockTag: 'latest', 
      domain,
      types,
      message: {
        from: {
          name: 'Cow',
          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
          name: 'Bob',
          wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
      },
      primaryType: 'Mail',
      address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
      signature: '0x66edc32e2ab001213321ab7d959a2207fcef5190cc9abb6da5b0d2a8a9af2d4d2b0700e2c317c4106f337fd934fbbb0bf62efc8811a78603b33a8265d3b8f8cb1c',
    })
    // true

ts

    // All properties on a domain are optional
    export const domain = {
      name: 'Ether Mail',
      version: '1',
      chainId: 1,
      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    } as const
    
    // The named list of all type definitions
    export const types = {
      Person: [
        { name: 'name', type: 'string' },
        { name: 'wallet', type: 'address' },
      ],
      Mail: [
        { name: 'from', type: 'Person' },
        { name: 'to', type: 'Person' },
        { name: 'contents', type: 'string' },
      ],
    } as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type VerifyTypedDataReturnType } from '@wagmi/core'

`boolean`

Whether the signed message is valid for the given address.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`types`](#types) setup correctly, TypeScript will infer the correct types for [`domain`](#domain), [`message`](#message), and [`primaryType`](#primarytype). See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type VerifyTypedDataErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type verifyTypedDataData,
      type verifyTypedDataVariables,
      type verifyTypedDataMutate,
      type verifyTypedDataMutateAsync,
      verifyTypedDataMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`verifyTypedData`](https://viem.sh/docs/actions/public/verifyTypedData.html)</content>
</page>

<page>
  <title>watchConnectors | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchConnectors</url>
  <content>Subscribe to connectors changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchConnectors } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchConnectors } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchConnectors(config, {
      onChange(connectors) {
        console.log('Connectors changed!', connectors)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchConnectorsParameters } from '@wagmi/core'

### onChange [‚Äã](#onchange)

`onChange(connectors: GetConnectorsReturnType, prevConnectors: GetConnectorsReturnType): void`

Callback function called when connectors changes.

index.tsconfig.ts

ts

    import { watchConnectors } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchConnectors(config, {
      onChange(connectors) { 
        console.log('Connectors changed!', connectors)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchConnectorsReturnType } from '@wagmi/core'

Function for cleaning up watcher.</content>
</page>

<page>
  <title>watchBlocks | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchBlocks</url>
  <content>Action that watches for block changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchBlocks } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchBlocksParameters } from '@wagmi/core'

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'`

Watch for new blocks on a given tag. Defaults to `'latest'`.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      blockTag: 'pending', 
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      chainId: mainnet.id, 
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitMissed [‚Äã](#emitmissed)

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      emitMissed: true, 
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### emitOnBegin [‚Äã](#emitonbegin)

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      emitOnBegin: true, 
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onBlock [‚Äã](#onblock)

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      onBlock(block) { 
        console.log('Block changed!', block) 
      }, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      onBlock(block) { 
        console.log('Block changed!', block) 
      }, 
      onError(error) { 
        console.error('Block error', error) 
      }, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      poll: true, 
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      pollingInterval: 1_000, 
      onBlock(block) {
        console.log('Block changed!', block)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsconfig.ts

ts

    import { watchBlocks } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchBlocks(config, {
      onBlock(block) {
        console.log('Block changed!', block)
      },
      syncConnectedChain: false, 
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchBlocksReturnType } from '@wagmi/core'

Function for cleaning up watcher.

Viem [‚Äã](#viem)
---------------

*   [`watchBlocks`](https://viem.sh/docs/actions/public/watchBlocks.html)</content>
</page>

<page>
  <title>watchPendingTransactions | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchPendingTransactions</url>
  <content>Action that watches and returns pending transaction hashes.

Import [‚Äã](#import)
-------------------

ts

    import { watchPendingTransactions } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchPendingTransactionsParameters } from '@wagmi/core'

### batch [‚Äã](#batch)

`boolean | undefined`

*   Whether or not the transactions should be batched on each invocation.
*   Defaults to `true`.

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    
    const unwatch = watchPendingTransactions(config, {
      batch: false, 
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      chainId: mainnet.id, 
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from watching pending transactions.

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      onError(error) { 
        console.log('Error', error) 
      }, 
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onTransactions [‚Äã](#ontransactions)

`(transactions: Hash[], prevTransactions: Hash[] | undefined) => void`

Callback when new incoming pending transactions are detected.

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      onTransactions(transactions) { 
        console.log('New transactions!', transactions) 
      }, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new pending transactions instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
      poll: false, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
      pollingInterval: 1_000, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsconfig.ts

ts

    import { watchPendingTransactions } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPendingTransactions(config, {
      onTransactions(transactions) {
        console.log('New transactions!', transactions)
      },
      syncConnectedChain: false, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchPendingTransactionsReturnType } from '@wagmi/core'

Function to unsubscribe from pending transaction listener.

Error [‚Äã](#error)
-----------------

ts

    import { type WatchPendingTransactionsError } from '@wagmi/core'

Viem [‚Äã](#viem)
---------------

*   [`watchPendingTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html)</content>
</page>

<page>
  <title>Errors | Wagmi</title>
  <url>https://wagmi.sh/core/api/errors</url>
  <content>Error classes used by Wagmi.

BaseError [‚Äã](#baseerror)
-------------------------

Error class extended by all errors.

ts

    import { BaseError } from '@wagmi/core'

Config [‚Äã](#config)
-------------------

### ConnectorAccountNotFoundError [‚Äã](#connectoraccountnotfounderror)

When an account does not exist on the connector or is unable to be used.

ts

    import { ConnectorAccountNotFoundError } from '@wagmi/core'

### ConnectorAlreadyConnectedError [‚Äã](#connectoralreadyconnectederror)

When a connector is already connected.

ts

    import { ConnectorAlreadyConnectedError } from '@wagmi/core'

### ConnectorChainMismatchError [‚Äã](#connectorchainmismatcherror)

When the Wagmi Config is out-of-sync with the connector's active chain ID. This is rare and likely an upstream wallet issue.

ts

    import { ConnectorChainMismatchError } from '@wagmi/core'

### ChainNotConfiguredError [‚Äã](#chainnotconfigurederror)

When a chain is not configured. You likely need to add the chain to [`Config['chains']`](https://wagmi.sh/core/api/createConfig#chains).

ts

    import { ChainNotConfiguredError } from '@wagmi/core'

### ConnectorNotConnectedError [‚Äã](#connectornotconnectederror)

When a connector is not connected.

ts

    import { ConnectorNotConnectedError } from '@wagmi/core'

### ConnectorNotFoundError [‚Äã](#connectornotfounderror)

When a connector is not found or able to be used.

ts

    import { ConnectorNotFoundError } from '@wagmi/core'

### ConnectorUnavailableReconnectingError [‚Äã](#connectorunavailablereconnectingerror)

During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.

ts

    import { ConnectorUnavailableReconnectingError } from '@wagmi/core'

Connector [‚Äã](#connector)
-------------------------

### ProviderNotFoundError [‚Äã](#providernotfounderror)

When a connector's provider is not found or able to be used.

ts

    import { ProviderNotFoundError } from '@wagmi/core'

### SwitchChainNotSupportedError [‚Äã](#switchchainnotsupportederror)

When switching chains is not supported by connectors.

ts

    import { SwitchChainNotSupportedError } from '@wagmi/core'</content>
</page>

<page>
  <title>watchPublicClient | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchPublicClient</url>
  <content>Subscribe to Public Client changes.

Import [‚Äã](#import)
-------------------

ts

    import { watchPublicClient } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { watchPublicClient } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPublicClient(config, {
      onChange(client) {
        console.log('Public Client changed!', client)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchPublicClientParameters } from '@wagmi/core'

### onChange [‚Äã](#onchange)

`onChange(client: GetPublicClientReturnType, prevClient: GetPublicClientReturnType): void`

Callback function called when Public Client changes.

index.tsconfig.ts

ts

    import { watchPublicClient } from '@wagmi/core'
    import { config } from './config'
    
    const unwatch = watchPublicClient(config, {
      onChange(client) { 
        console.log('Public Client changed!', client)
      },
    })
    unwatch()

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchPublicClientReturnType } from '@wagmi/core'

Function for cleaning up watcher.</content>
</page>

<page>
  <title>cookieToInitialState | Wagmi</title>
  <url>https://wagmi.sh/core/api/utilities/cookieToInitialState</url>
  <content>Helper to convert a cookie string into [initial state](https://wagmi.sh/react/api/WagmiProvider#initialstate).

Import [‚Äã](#import)
-------------------

ts

    import { cookieToInitialState } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

server.tsconfig.ts

ts

    import { cookieToInitialState } from '@wagmi/core'
    import config from './config'
    
    function handler(req: Request) {
      const initialState = cookieToInitialState(config, req.headers.cookie)
      // ...
    }

ts

    import { 
      createConfig, 
      http, 
      cookieStorage,
      createStorage
    } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true,
      storage: createStorage({ 
        storage: cookieStorage,
      }), 
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

### config [‚Äã](#config)

`Config`

Wagmi Config

### cookie [‚Äã](#cookie)

`string | null | undefined`

The cookie string.

Return Type [‚Äã](#return-type)
-----------------------------

`State`

Initial state.</content>
</page>

<page>
  <title>watchContractEvent | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/watchContractEvent</url>
  <content>Action that watches and returns emitted contract event logs.

Import [‚Äã](#import)
-------------------

ts

    import { watchContractEvent } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      abi,
      eventName: 'Transfer',
      onLogs(logs) {
        console.log('New logs!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WatchContractEventParameters } from '@wagmi/core'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi, 
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      abi,
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`object | readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`eventName`](#eventname).

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      args: { 
        to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      }, 
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### batch [‚Äã](#batch)

`boolean | undefined`

*   Whether or not the events should be batched on each invocation.
*   Defaults to `true`.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      batch: false, 
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { mainnet } from '@wagmi/core/chains'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      chainId: mainnet.id, 
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### eventName [‚Äã](#eventname)

`string`

*   Event to listen for the contract.
*   Inferred from [`abi`](#abi).

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      eventName: 'Approval', 
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      onLogs(logs) { 
        console.log('Logs changed!', logs) 
      }, 
      onError(error) { 
        console.error('Logs error', error) 
      }, 
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onLogs [‚Äã](#onlogs)

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      onLogs(logs) { 
        console.log('Logs changed!', logs) 
      }, 
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
      poll: true, 
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
      pollingInterval: 1_000, 
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### strict [‚Äã](#strict)

`boolean | undefined`

*   Defaults to `false`.

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
      strict: true, 
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

index.tsabi.tsconfig.ts

ts

    import { watchContractEvent } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const unwatch = watchContractEvent(config, {
      abi,
      onLogs(logs) {
        console.log('Logs changed!', logs)
      },
      syncConnectedChain: false, 
    })
    unwatch()

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WatchContractEventReturnType } from '@wagmi/core'

Function for cleaning up watcher.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`eventName`](#eventname), [`args`](#args), and [`onLogs`](#onlogs) parameters. See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type WatchContractEventError } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WatchContractEventData,
      type WatchContractEventOptions,
      type WatchContractEventQueryFnData,
      type WatchContractEventQueryKey,
      watchContractEventQueryKey,
      watchContractEventQueryOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`watchContractEvent`](https://viem.sh/docs/contract/watchContractEvent.html)</content>
</page>

<page>
  <title>serialize | Wagmi</title>
  <url>https://wagmi.sh/core/api/utilities/serialize</url>
  <content>Serialize function that supports `bigint` and `Map`.

Import [‚Äã](#import)
-------------------

ts

    import { serialize } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { serialize } from '@wagmi/core'
    
    const result = serialize({ foo: 'wagmi', bar: 123n })

Parameters [‚Äã](#parameters)
---------------------------

### value [‚Äã](#value)

`any`

The value to stringify.

### replacer [‚Äã](#replacer)

`(key: string, value: any) => any`

A custom replacer function for handling standard values.

### indent [‚Äã](#indent)

`number | null | undefined`

The number of spaces to indent the output by.

### circularReplacer [‚Äã](#circularreplacer)

A custom replacer function for handling circular values.

Return Type [‚Äã](#return-type)
-----------------------------

`string`

Stringified value.</content>
</page>

<page>
  <title>deserialize | Wagmi</title>
  <url>https://wagmi.sh/core/api/utilities/deserialize</url>
  <content>Deserialize function that supports `bigint` and `Map`.

Import [‚Äã](#import)
-------------------

ts

    import { deserialize } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

ts

    import { deserialize } from '@wagmi/core'
    
    const result = deserialize('{"foo":"wagmi","bar":{"__type":"bigint","value":"123"}}')

Parameters [‚Äã](#parameters)
---------------------------

### value [‚Äã](#value)

`string`

The string to deserialize.

### reviver [‚Äã](#reviver)

`(key: string, value: any) => any`

A custom reviver function for handling standard values.

Return Type [‚Äã](#return-type)
-----------------------------

`unknown`

Parsed value.</content>
</page>

<page>
  <title>normalizeChainId | Wagmi</title>
  <url>https://wagmi.sh/core/api/utilities/normalizeChainId</url>
  <content>Normalizes a chain ID to a number.

Import [‚Äã](#import)
-------------------

ts

    import { normalizeChainId } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

Deprecated

Use `Number` instead.

ts

    import { normalizeChainId } from '@wagmi/core'
    const chainId = normalizeChainId(123n)
    const chainId = Number(123n)

ts

    import { normalizeChainId } from '@wagmi/core'
    
    const result = normalizeChainId('0x1')

Parameters [‚Äã](#parameters)
---------------------------

### chainId [‚Äã](#chainid)

`bigint | number | string`

The chain ID to normalize.

ts

    import { normalizeChainId } from '@wagmi/core'
    
    normalizeChainId(1n)
    normalizeChainId(1)
    normalizeChainId('0x1')

Return Type [‚Äã](#return-type)
-----------------------------

`number`

The normalized chain ID.</content>
</page>

<page>
  <title>getCallsStatus | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getCallsStatus</url>
  <content>Action to fetch the status and receipts of a call batch that was sent via [`sendCalls`](https://wagmi.sh/core/api/actions/sendCalls).

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_getcallsstatus)

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { getCallsStatus } from '@wagmi/core/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const status = await getCallsStatus(config, {
      id: '0x1234567890abcdef',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetCallsStatusParameters } from '@wagmi/core/experimental'

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get call statuses with.

index.tsconfig.ts

ts

    import { getConnections, getCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const connections = getConnections(config)
    const status = await getCallsStatus(config, {
      connector: connections[0]?.connector, 
      id: '0x1234567890abcdef',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### id [‚Äã](#id)

`string`

Identifier of the call batch.

index.tsconfig.ts

ts

    import { getCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const status = await getCallsStatus(config, {
      id: '0x1234567890abcdef', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetCallsStatusReturnType } from '@wagmi/core/experimental'

`{ status: 'PENDING' | 'CONFIRMED', receipts: TransactionReceipt[] }`

The status and receipts of the call batch.

Error [‚Äã](#error)
-----------------

ts

    import { type GetCallsStatusErrorType } from '@wagmi/core/experimental'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetCallsStatusData,
      type GetCallsStatusOptions,
      type GetCallsStatusQueryFnData,
      type GetCallsStatusQueryKey,
      getCallsStatusQueryKey,
      getCallsStatusQueryOptions,
    } from '@wagmi/core/experimental/query'

Viem [‚Äã](#viem)
---------------

*   [`getCallsStatus`](https://viem.sh/experimental/eip5792/getCallsStatus)</content>
</page>

<page>
  <title>getCapabilities | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/getCapabilities</url>
  <content>Action to extract capabilities (grouped by chain ID) that a connected wallet supports (e.g. paymasters, session keys, etc).

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_getcapabilities)

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { getCapabilities } from '@wagmi/core/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { getCapabilities } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const capabilities = await getCapabilities(config)

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type GetCapabilitiesParameters } from '@wagmi/core/experimental'

### account [‚Äã](#account)

`Account | Address | undefined`

Fetch capabilities for the provided account.

index.tsconfig.ts

ts

    import { getCapabilities } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const capabilities = await getCapabilities(config, {
      account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get capabilities from.

index.tsconfig.ts

ts

    import { getConnections, getCapabilities } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const connections = getConnections(config)
    const capabilities = await getCapabilities(config, {
      connector: connections[0]?.connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type GetCapabilitiesReturnType } from '@wagmi/core/experimental'

`bigint`

Most recent block number seen.

Error [‚Äã](#error)
-----------------

ts

    import { type GetCapabilitiesErrorType } from '@wagmi/core/experimental'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetCapabilitiesData,
      type GetCapabilitiesOptions,
      type GetCapabilitiesQueryFnData,
      type GetCapabilitiesQueryKey,
      getCapabilitiesQueryKey,
      getCapabilitiesQueryOptions,
    } from '@wagmi/core/experimental/query'

Viem [‚Äã](#viem)
---------------

*   [`getCapabilities`](https://viem.sh/experimental/eip5792/getCapabilities)</content>
</page>

<page>
  <title>showCallsStatus | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/showCallsStatus</url>
  <content>Action to request for the wallet to show information about a call batch that was sent via `showCalls`.

[Read more.](https://github.com/ethereum/EIPs/blob/1663ea2e7a683285f977eda51c32cec86553f585/EIPS/eip-5792.md#wallet_showcallsstatus)

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { showCallsStatus } from '@wagmi/core/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { showCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    await showCallsStatus(config, {
      id: '0x1234567890abcdef',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type ShowCallsStatusParameters } from '@wagmi/core/experimental'

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to show call statuses with.

index.tsconfig.ts

ts

    import { getConnections, showCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const connections = getConnections(config)
    await showCallsStatus(config, {
      connector: connections[0]?.connector, 
      id: '0x1234567890abcdef',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### id [‚Äã](#id)

`string`

Identifier of the call batch.

index.tsconfig.ts

ts

    import { showCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    await showCallsStatus(config, {
      id: '0x1234567890abcdef', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type ShowCallsStatusReturnType } from '@wagmi/core/experimental'

`bigint`

Most recent block number seen.

Error [‚Äã](#error)
-----------------

ts

    import { type ShowCallsStatusErrorType } from '@wagmi/core/experimental'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ShowCallsStatusData,
      type ShowCallsStatusOptions,
      type ShowCallsStatusQueryFnData,
      type ShowCallsStatusQueryKey,
      showCallsStatusQueryKey,
      showCallsStatusQueryOptions,
    } from '@wagmi/core/experimental/query'

Viem [‚Äã](#viem)
---------------

*   [`showCallsStatus`](https://viem.sh/experimental/eip5792/showCallsStatus)</content>
</page>

<page>
  <title>waitForCallsStatus | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/waitForCallsStatus</url>
  <content>Waits for a call bundle to be confirmed & included on a block before returning the status & receipts.

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { waitForCallsStatus } from '@wagmi/core/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { sendCalls, waitForCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const id = await sendCalls(config, {
      calls: [{
        to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        value: parseEther('1')
      }]
    })
    
    const { status, receipts } = await waitForCallsStatus(config, { 
      id, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WaitForCallsStatusParameters } from '@wagmi/core/experimental'

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get call statuses with.

index.tsconfig.ts

ts

    import { getConnections, waitForCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const connections = getConnections(config)
    const status = await waitForCallsStatus(config, {
      connector: connections[0]?.connector, 
      id: '0x1234567890abcdef',
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### id [‚Äã](#id)

`string`

Identifier of the call batch.

index.tsconfig.ts

ts

    import { waitForCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const status = await waitForCallsStatus(config, {
      id: '0x1234567890abcdef', 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number`

Polling interval in milliseconds.

index.tsconfig.ts

ts

    import { waitForCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const status = await waitForCallsStatus(config, {
      id: '0x1234567890abcdef',
      pollingInterval: 1_000, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### timeout [‚Äã](#timeout)

`number`

Timeout in milliseconds before `waitForCallsStatus` stops polling.

index.tsconfig.ts

ts

    import { waitForCallsStatus } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const status = await waitForCallsStatus(config, {
      id: '0x1234567890abcdef',
      timeout: 10_000, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WaitForCallsStatusReturnType } from '@wagmi/core/experimental'

`{ status: 'PENDING' | 'CONFIRMED', receipts: TransactionReceipt[] }`

The status and receipts of the call batch.

Error [‚Äã](#error)
-----------------

ts

    import { type WaitForCallsStatusErrorType } from '@wagmi/core/experimental'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WaitForCallsStatusData,
      type WaitForCallsStatusOptions,
      type WaitForCallsStatusQueryFnData,
      type WaitForCallsStatusQueryKey,
      waitForCallsStatusQueryKey,
      waitForCallsStatusQueryOptions,
    } from '@wagmi/core/experimental/query'

Viem [‚Äã](#viem)
---------------

*   [`waitForCallsStatus`](https://viem.sh/experimental/eip5792/waitForCallsStatus)</content>
</page>

<page>
  <title>sendCalls | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/sendCalls</url>
  <content>Action that requests for the wallet to sign and broadcast a batch of calls (transactions) to the network.

[Read more.](https://github.com/ethereum/EIPs/blob/815028dc634463e1716fc5ce44c019a6040f0bef/EIPS/eip-5792.md#wallet_sendcalls)

WARNING

This is an experimental action that is not supported in most wallets. It is recommended to have a fallback mechanism if using this in production.

Import [‚Äã](#import)
-------------------

ts

    import { sendCalls } from '@wagmi/core/experimental'

Usage [‚Äã](#usage)
-----------------

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { sendCalls } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const id = await sendCalls(config, {
      calls: [
        {
          to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
          value: parseEther('1')
        },
        {
          data: '0xdeadbeef',
          to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        },
      ]
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SendCallsParameters } from '@wagmi/core/experimental'

### account [‚Äã](#account)

`Account | Address | null | undefined`

Account to execute the calls.

If set to `null`, it is assumed that the wallet will handle filling the sender of the calls.

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { sendCalls } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const id = await sendCalls(config, {
      account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', 
      calls: [
        {
          to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
          value: parseEther('1')
        },
        {
          data: '0xdeadbeef',
          to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        },
      ],
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### calls [‚Äã](#calls)

`{ to: Hex, data?: Hex, value?: bigint }[]`

Calls to execute.

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { sendCalls } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const id = await sendCalls(config, {
      calls: [ 
        { 
          to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
          value: parseEther('1') 
        }, 
        { 
          data: '0xdeadbeef', 
          to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 
        }, 
      ], 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### capabilities [‚Äã](#capabilities)

`WalletCapabilities | undefined`

Capability metadata for the calls (e.g. specifying a paymaster).

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { sendCalls } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const id = await sendCalls(config, {
      calls: [
        {
          to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
          value: parseEther('1')
        },
        {
          data: '0xdeadbeef',
          to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        },
      ],
      capabilities: { 
        paymasterService: { 
          url: 'https://...'
        } 
      } 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`number | undefined`

The target chain ID to broadcast the calls.

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { sendCalls } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const id = await sendCalls(config, {
      calls: [
        {
          to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
          value: parseEther('1')
        },
        {
          data: '0xdeadbeef',
          to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        },
      ],
      chainId: 10, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to get send the calls with.

index.tsconfig.ts

ts

    import { parseEther } from 'viem'
    import { getConnections } from '@wagmi/core'
    import { sendCalls } from '@wagmi/core/experimental'
    import { config } from './config'
    
    const connections = getConnections(config)
    const id = await sendCalls(config, {
      calls: [
        {
          to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
          value: parseEther('1')
        },
        {
          data: '0xdeadbeef',
          to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
        },
      ],
      connector: connections[0]?.connector, 
    })

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type SendCallsReturnType } from '@wagmi/core/experimental'

`bigint`

Most recent block number seen.

Error [‚Äã](#error)
-----------------

ts

    import { type SendCallsErrorType } from '@wagmi/core/experimental'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SendCallsData,
      type SendCallsOptions,
      type SendCallsQueryFnData,
      type SendCallsQueryKey,
      sendCallsQueryKey,
      sendCallsQueryOptions,
    } from '@wagmi/core/experimental/query'

Viem [‚Äã](#viem)
---------------

*   [`sendCalls`](https://viem.sh/experimental/eip5792/sendCalls)</content>
</page>

<page>
  <title>writeContract | Wagmi</title>
  <url>https://wagmi.sh/core/api/actions/writeContract</url>
  <content>Action for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

Import [‚Äã](#import)
-------------------

ts

    import { writeContract } from '@wagmi/core'

Usage [‚Äã](#usage)
-----------------

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Pairing with `simulateContract`

Pairing [`simulateContract`](https://wagmi.sh/core/api/actions/simulateContract) with `writeContract` allows you to validate if the transaction will succeed ahead of time. If the simulate succeeds, `writeContract` can execute the transaction.

index.tsabi.tsconfig.ts

ts

    import { simulateContract, writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const { request } = await simulateContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })
    const hash = await writeContract(config, request)

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WriteContractParameters } from '@wagmi/core'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/react/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi, 
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      accessList: [{ 
        address: '0x1', 
        storageKeys: ['0x1'], 
      }], 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when signing data. Throws if account is not found on [`connector`](#connector).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address`

The contract's address.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [ 
        '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
        123n, 
      ] 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to validate against before sending transaction.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      chainId: mainnet.id, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/core/api/connectors) to sign data with.

index.tsabi.tsconfig.ts

ts

    import { getAccount, writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const { connector } = getAccount(config)
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      connector, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### dataSuffix [‚Äã](#datasuffix)

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      dataSuffix: '0xdeadbeef', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'approve', 
      args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 123n]
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      gas: parseGwei('20'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      gasPrice: parseGwei('20'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      maxFeePerGas: parseGwei('20'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      nonce: 123, 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      type: 'eip1559', 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsabi.tsconfig.ts

ts

    import { writeContract } from '@wagmi/core'
    import { parseEther } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = await writeContract(config, {
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      value: parseEther('0.01'), 
    })

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/core'
    import { mainnet, sepolia } from '@wagmi/core/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type WriteContractReturnType } from '@wagmi/core'

[`Hash`](https://viem.sh/docs/glossary/types.html#hash)

The transaction hash.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](https://wagmi.sh/core/typescript) for more information.

Error [‚Äã](#error)
-----------------

ts

    import { type WriteContractErrorType } from '@wagmi/core'

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WriteContractData,
      type WriteContractVariables,
      type WriteContractMutate,
      type WriteContractMutateAsync,
      writeContractMutationOptions,
    } from '@wagmi/core/query'

Viem [‚Äã](#viem)
---------------

*   [`writeContract`](https://viem.sh/docs/contract/writeContract.html)</content>
</page>

<page>
  <title>Installation | Wagmi</title>
  <url>https://wagmi.sh/cli/installation</url>
  <content>Install Wagmi CLI via your package manager.

Package Manager [‚Äã](#package-manager)
-------------------------------------

Install the required package.

pnpmnpmyarnbun

bash

    npm install @wagmi/cli

Using Unreleased Commits [‚Äã](#using-unreleased-commits)
-------------------------------------------------------

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

pnpmnpmyarnbun

bash

    pnpm add @wagmi/cli@canary

bash

    npm install @wagmi/cli@canary

bash

    yarn add @wagmi/cli@canary

bash

    bun add @wagmi/cli@canary

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

bash

    git clone https://github.com/wevm/wagmi.git
    cd wagmi
    pnpm install
    pnpm build
    cd packages/cli
    pnpm link --global

Then go to the project where you are using the Wagmi CLI and run `pnpm link --global @wagmi/cli` (or the package manager that you used to link Wagmi CLI globally).</content>
</page>

<page>
  <title>Migrate from v1 to v2</title>
  <url>https://wagmi.sh/cli/guides/migrate-from-v1-to-v2</url>
  <content>To get started, install the latest version of the Wagmi CLI.

pnpmnpmyarnbun

bash

    npm install @wagmi/cli

Not ready to migrate yet?

The Wagmi CLI v1 docs are still available at [1.x.wagmi.sh/cli](https://1.x.wagmi.sh/cli).

Changed generated action and hook names [‚Äã](#changed-generated-action-and-hook-names)
-------------------------------------------------------------------------------------

Generated action and hook names now align with [Wagmi v2 naming conventions](https://wagmi.sh/react/guides/migrate-from-v1-to-v2#renamed-hooks). If you want hooks to still follow Wagmi v1 naming conventions, set [`getActionName`](https://wagmi.sh/cli/api/plugins/actions#getactionname) and [`getHookName`](https://wagmi.sh/cli/api/plugins/react#gethookname) to `'legacy'`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { actions, react } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        actions({
          getActionName: 'legacy', 
        }),
        react({
          getHookName: 'legacy', 
        }),
      ],
    })</content>
</page>

<page>
  <title>Why Wagmi CLI | Wagmi</title>
  <url>https://wagmi.sh/cli/why</url>
  <content>The Problem [‚Äã](#the-problem)
-----------------------------

The most common way to interact with smart contracts is through [Application Binary Interfaces](https://docs.soliditylang.org/en/latest/abi-spec.html). ABIs describe smart contracts' public functionality (e.g. functions, events, errors) as well as how to encode and decode related data (e.g. arguments and results).

While ABIs are extremely powerful, there isn't a uniform way developers manage them in their apps. Developers do a bunch of different things, like:

*   Publish packages on npm containing ABIs
*   Write custom scripts to fetch ABIs from external sources
*   Compile contracts into application project
*   Copy and paste ABIs from local projects or block explorers

All these approaches take time that you could spend doing more important things, like interacting with your smart contracts!

The Solution [‚Äã](#the-solution)
-------------------------------

The Wagmi CLI is an attempt to automate manual work so you can build faster. In short, the CLI manages ABIs and generates code. It takes ABIs as inputs and outputs ABIs and generated code. For example, the [Etherscan plugin](https://wagmi.sh/cli/api/plugins/etherscan) allows you to fetch ABIs across multiple chains and deployments and immediately start importing them into your project.

Code generation is another big advantage of the CLI. Using the [React plugin](https://wagmi.sh/cli/api/plugins/react), you can generate [Wagmi Hooks](https://wagmi.sh/react/api/hooks) for ABIs. When you combine this with the CLI's different ABI sources, like Etherscan, Foundry/Hardhat, and more, you reduce a lot of boilerplate code.

DiffBeforeAfter

ts

    import { useReadContract, useWriteContract } from 'wagmi'
    import { froggyFriendsAbi, froggyFriendsAddress } from './generated'
    import { useReadFroggyFriends, useWriteFroggyFriends } from './generated'
    
    function App() {
      const { data } = useReadContract({ 
      const { data } = useReadFroggyFriends({ 
        abi: froggyFriendsAbi, 
        address: froggyFriendsAddress, 
        functionName: 'tokenURI',
        args: [123n],
      })
    
      const { write } = useWriteContract() 
      const { write } = useWriteFroggyFriends() 
      const onClick = React.useCallback(() => {
        write({
          abi: froggyFriendsAbi, 
          address: froggyFriendsAddress, 
          functionName: 'mint',
          args: ['foo', 123n],
        })
      }, [write])
    }

ts

    import { useReadContract, useWriteContract } from 'wagmi'
    import { froggyFriendsAbi, froggyFriendsAddress } from './generated'
    
    function App() {
      const { data } = useReadContract({
        abi: froggyFriendsAbi,
        address: froggyFriendsAddress,
        functionName: 'tokenURI',
        args: [123n],
      })
    
      const { write } = useWriteContract()
      const onClick = React.useCallback(() => {
        write({
          abi: froggyFriendsAbi,
          address: froggyFriendsAddress,
          functionName: 'mint',
          args: ['foo', 123n],
        })
      }, [write])
    }

ts

    import { useReadFroggyFriends, useWriteFroggyFriends } from './generated'
    
    function App() {
      const { data } = useReadFroggyFriends({
        functionName: 'tokenURI',
        args: [123n],
      })
    
      const { write } = useWriteFroggyFriends()
      const onClick = React.useCallback(() => {
        write({
          functionName: 'mint',
          args: ['foo', 123n],
        })
      }, [write])
    }

Finally, the Wagmi CLI supports popular smart contract development tools, [Foundry](https://wagmi.sh/cli/api/plugins/foundry) and [Hardhat](https://wagmi.sh/cli/api/plugins/hardhat). You can run the CLI in [watch mode](https://wagmi.sh/cli/api/commands/generate#w-watch), make changes to your contracts, and the CLI will automatically pick up ABI changes and run plugins over those changes. A major boon to working a monorepo and shortening the feedback loop across your stack.</content>
</page>

<page>
  <title>Configuring CLI | Wagmi</title>
  <url>https://wagmi.sh/cli/config/configuring-cli</url>
  <content>When running `wagmi` from the command line, `@wagmi/cli` will automatically try to resolve a config file named `wagmi.config.js` or `wagmi.config.ts` inside the project root. The most basic config file looks like this:

wagmi.config.js

js

    export default {
      // config options
    }

Note `@wagmi/cli` supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. `"type": "module"` in package.json. In this case, the config file is auto pre-processed before load.

You can also explicitly specify a config file to use with the `--config`/`-c` CLI option (resolved relative to the current directory):

bash

    wagmi --config my-config.js

To scaffold a config file quickly, check out the [`init`](https://wagmi.sh/cli/api/commands/init) command.

Config Intellisense [‚Äã](#config-intellisense)
---------------------------------------------

Since Wagmi CLI ships with TypeScript typings, you can use your editor's intellisense with [JSDoc](https://jsdoc.app/) type hints:

wagmi.config.js

js

    /** @type {import('@wagmi/cli').Config} */
    export default {
      // ...
    }

Alternatively, you can use the `defineConfig` utility which should provide intellisense without the need for JSDoc annotations:

wagmi.config.js

js

    import { defineConfig } from '@wagmi/cli'
    
    export default defineConfig({
      // ...
    })

Wagmi CLI also directly supports TypeScript config files. You can use `wagmi.config.ts` with the `defineConfig` helper as well.

Conditional Config [‚Äã](#conditional-config)
-------------------------------------------

If the config needs to conditionally determine options based on the environment, it can export a function instead:

wagmi.config.js

js

    export default defineConfig(() => {
      if (process.env.NODE_ENV === 'dev') {
        return {
          // dev specific config
        }
      } else {
        return {
          // production specific config
        }
      }
    })

Async Config [‚Äã](#async-config)
-------------------------------

If the config needs to call async function, it can export a async function instead:

wagmi.config.js

js

    export default defineConfig(async () => {
      const data = await asyncFunction()
      return {
        // ...
      }
    })

This can be useful for resolving external resources from the network or filesystem that are required for configuration ahead of running a command.

Array Config [‚Äã](#array-config)
-------------------------------

The config can also be represented either as a pre-defined array or returned as an array from a function:

wagmi.config.js

js

    export default defineConfig([
      {
      // config 1
      },
      {
      // config 2
      },
    ])

Environment Variables [‚Äã](#environment-variables)
-------------------------------------------------

Environmental Variables can be obtained from `process.env` as usual.

Note that Wagmi CLI doesn't load `.env` files by default as the files to load can only be determined after evaluating the config. However, you can use the exported `loadEnv` utility to load the specific `.env` files if needed.

wagmi.config.js

js

    import { defineConfig, loadEnv } from '@wagmi/cli'
    
    export default defineConfig(() => {
      const env = loadEnv({
        mode: process.env.NODE_ENV,
        envDir: process.cwd(),
      })
      return {
        // ...
      }
    })</content>
</page>

<page>
  <title>Config Options | Wagmi</title>
  <url>https://wagmi.sh/cli/config/options</url>
  <content>Configuration options for Wagmi CLI.

contracts [‚Äã](#contracts)
-------------------------

`ContractConfig[] | undefined`

Array of contracts to use when running [commands](https://wagmi.sh/cli/api/commands). `abi` and `name` are required, all other properties are optional.

### address [‚Äã](#address)

`Address | Record<chainId, Address> | undefined`

Contract address or addresses. Accepts an object `{ [chainId]: address }` for targeting specific chains.

wagmi.config.ts

ts

    export default {
      out: 'src/generated.ts',
      contracts: [
        {
          abi: [‚Ä¶],
          address: '0x‚Ä¶',
          name: 'MyCoolContract',
        },
        {
          abi: [‚Ä¶],
          address: {
            1: '0xfoo‚Ä¶',
            5: '0xbar‚Ä¶',
          },
          name: 'MyCoolMultichainContract'
        }
      ],
    }

### abi [‚Äã](#abi)

`Abi`

ABI for contract. Used by [plugins](https://wagmi.sh/cli/api/plugins) to generate code base on properties.

wagmi.config.ts

ts

    export default {
      out: 'src/generated.ts',
      contracts: [
        {
          abi: [‚Ä¶],
          name: 'MyCoolContract'
        },
      ],
    }

### name [‚Äã](#name)

`string`

Name of contract. Must be unique. Used by [plugins](https://wagmi.sh/cli/api/plugins) to name generated code.

wagmi.config.ts

ts

    export default {
      out: 'src/generated.ts',
      contracts: [
        {
          abi: [‚Ä¶],
          name: 'MyCoolContract'
        },
      ],
    }

out [‚Äã](#out)
-------------

`string`

Path to output generated code. Must be unique per config. Use an [Array Config](https://wagmi.sh/cli/config/configuring-cli#array-config) for multiple outputs.

wagmi.config.ts

ts

    export default {
      out: 'src/generated.ts',
      contracts: [
        {
          abi: [‚Ä¶],
          name: 'MyCoolContract'
        },
      ],
    }

plugins [‚Äã](#plugins)
---------------------

`Plugin[] | undefined`

Plugins to use and their configuration.

Wagmi CLI has multiple [built-in plugins](https://wagmi.sh/cli/api/plugins) that are used to manage ABIs, generate code, etc.

wagmi.config.ts

ts

    import { etherscan, react } from '@wagmi/cli/plugins'
    
    export default {
      out: 'src/generated.js',
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY,
          chainId: 5,
          contracts: [
            {
              name: 'EnsRegistry',
              address: {
                1: '0x314159265dd8dbb310642f98f50c066173c1259b',
                5: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
              },
            },
          ],
        }),
        react(),
      ],
    }</content>
</page>

<page>
  <title>generate | Wagmi</title>
  <url>https://wagmi.sh/cli/api/commands/generate</url>
  <content>Generates code based on configuration, using `contracts` and `plugins`.

Usage [‚Äã](#usage)
-----------------

bash

    wagmi generate

Options [‚Äã](#options)
---------------------

### \-c, --config <path> [‚Äã](#c-config-path)

`string`

Path to config file.

bash

    wagmi generate --config wagmi.config.ts

### \-r, --root <path> [‚Äã](#r-root-path)

`string`

Root path to resolve config from.

bash

    wagmi generate --root path/to/root

### \-w, --watch [‚Äã](#w-watch)

`boolean`

Watch for changes (for plugins that support watch mode).

bash

    wagmi generate --watch

### \-h, --help [‚Äã](#h-help)

Displays help message.

bash

    wagmi generate --help</content>
</page>

<page>
  <title>init | Wagmi</title>
  <url>https://wagmi.sh/cli/api/commands/init</url>
  <content>Creates configuration file. If TypeScript is detected, the config file will use TypeScript and be named `wagmi.config.ts`. Otherwise, the config file will use JavaScript and be named `wagmi.config.js`.

Usage [‚Äã](#usage)
-----------------

bash

    wagmi init

Options [‚Äã](#options)
---------------------

### \-c, --config <path> [‚Äã](#c-config-path)

`string`

Path to config file.

bash

    wagmi init --config wagmi.config.ts

### \-r, --root <path> [‚Äã](#r-root-path)

`string`

Root path to resolve config from.

bash

    wagmi init --root path/to/root

### \-h, --help [‚Äã](#h-help)

Displays help message.

bash

    wagmi init --help</content>
</page>

<page>
  <title>Commands | Wagmi</title>
  <url>https://wagmi.sh/cli/api/commands</url>
  <content>Commands [‚Äã](#commands)
-----------------------

Available Commands [‚Äã](#available-commands)
-------------------------------------------

*   [`init`](https://wagmi.sh/cli/api/commands/init) Creates configuration file.
*   [`generate`](https://wagmi.sh/cli/api/commands/generate) Generates code based on configuration, using `contracts` and `plugins`.

Display Info [‚Äã](#display-info)
-------------------------------

### `-h`, `--help` [‚Äã](#h-help)

Show help message when `-h`, `--help` flags appear.

pnpmnpmyarnbun

bash

    pnpm wagmi --help

bash

    npx wagmi --help

bash

    yarn wagmi --help

bash

    bun wagmi --help

### `-v`, `--version` [‚Äã](#v-version)

Show version number when `-v`, `--version` flags appear.

pnpmnpmyarnbun

bash

    pnpm wagmi --version

bash

    npx wagmi --version

bash

    yarn wagmi --version

bash

    bun wagmi --version</content>
</page>

<page>
  <title>Plugins | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins</url>
  <content>Plugins [‚Äã](#plugins)
---------------------

Plugins for managing ABIs, generating code, and more.

Import [‚Äã](#import)
-------------------

Import via the `'@wagmi/cli/plugins'` entrypoint.

ts

    import { etherscan } from '@wagmi/cli/plugins'

Available Plugins [‚Äã](#available-plugins)
-----------------------------------------

*   [`actions`](https://wagmi.sh/cli/api/plugins/actions) Generate type-safe VanillaJS actions from configuration `contracts`.
*   [`blockExplorer`](https://wagmi.sh/cli/api/plugins/blockExplorer) Fetch ABIs from Block Explorers that support `?module=contract&action=getabi`.
*   [`etherscan`](https://wagmi.sh/cli/api/plugins/etherscan) Fetch ABIs from Etherscan and add into configuration.
*   [`fetch`](https://wagmi.sh/cli/api/plugins/fetch) Fetch and parse ABIs from network resource with `fetch`.
*   [`foundry`](https://wagmi.sh/cli/api/plugins/foundry) Generate ABIs and watch for Foundry project changes.
*   [`hardhat`](https://wagmi.sh/cli/api/plugins/hardhat) Generate ABIs and watch for Hardhat projects changes.
*   [`react`](https://wagmi.sh/cli/api/plugins/react) Generate type-safe React Hooks from configuration `contracts`.
*   [`sourcify`](https://wagmi.sh/cli/api/plugins/sourcify) Fetch ABIs from Sourcify from configuration `contracts`.

Create Plugin [‚Äã](#create-plugin)
---------------------------------

Creating plugins to hook into the CLI is quite simple. Plugins most commonly inject contracts into `contracts` config, e.g. [`etherscan`](https://wagmi.sh/cli/api/plugins/etherscan), and/or generate code using the `run` option, e.g. [`react`](https://wagmi.sh/cli/api/plugins/react). All you need to do is write a function that returns the `Plugin` type.

ts

    import { type Plugin, defineConfig } from '@wagmi/cli'
    
    function myPlugin(): Plugin {
      // `name` is the only required property.
      name: 'MyPlugin',
      // You likely want to at least include `contracts` or `run`.
      // ...
    }
    
    export default defineConfig({
      out: 'src/generated.ts',
      plugins: [myPlugin()],
    })</content>
</page>

<page>
  <title>foundry | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/foundry</url>
  <content>Plugin for resolving ABIs from [Foundry](https://github.com/foundry-rs/foundry) projects. Supports [`watch`](https://wagmi.sh/cli/api/commands/generate#w-watch) mode.

Import [‚Äã](#import)
-------------------

ts

    import { foundry } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({
          project: '../hello_foundry',
        }),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type FoundryConfig } from '@wagmi/cli/plugins'

### artifacts [‚Äã](#artifacts)

`string | undefined`

*   Project's artifacts directory. Same as your `foundry.toml`/`forge`s `--out` (`-o`) option.
*   Defaults to `'out/'`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({
          artifacts: 'out/', 
        }),
      ],
    })

### deployments [‚Äã](#deployments)

`{ [key: string]: address?: Address | Record<chainId, Address> | undefined } | undefined`

Mapping of addresses to attach to artifacts.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({
          deployments: { 
            Counter: { 
              1: '0x314159265dd8dbb310642f98f50c066173c1259b', 
              5: '0x112234455c3a32fd11230c42e7bccd4a84e02010', 
            }, 
          }, 
        }),
      ],
    })

### exclude [‚Äã](#exclude)

`string[] | undefined`

Artifact files to exclude relative to `artifacts`. Supports glob patterns.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({
          exclude: [ 
            // the following patterns are excluded by default
            'Common.sol/**', 
            'Components.sol/**', 
            'Script.sol/**', 
            'StdAssertions.sol/**', 
            'StdInvariant.sol/**', 
            'StdError.sol/**', 
            'StdCheats.sol/**', 
            'StdMath.sol/**', 
            'StdJson.sol/**', 
            'StdStorage.sol/**', 
            'StdUtils.sol/**', 
            'Vm.sol/**', 
            'console.sol/**', 
            'console2.sol/**', 
            'test.sol/**', 
            '**.s.sol/*.json', 
            '**.t.sol/*.json', 
          ], 
        }),
      ],
    })

### forge [‚Äã](#forge)

`{ clean?: boolean | undefined; build?: boolean | undefined; path?: string | undefined; rebuild?: boolean | undefined } | undefined`

Options for `forge`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({
          forge: {  
            clean: true,  
            build: true,  
            path: 'path/to/forge',  
            rebuild: true,  
          },  
        }),
      ],
    })

#### clean [‚Äã](#clean)

*   Remove build artifacts and cache directories on start up.
*   Defaults to `false`.

#### build [‚Äã](#build)

*   Build Foundry project before fetching artifacts.
*   Defaults to `true`.

#### path [‚Äã](#path)

*   Path to `forge` executable command.
*   Defaults to `forge`.

#### rebuild [‚Äã](#rebuild)

*   Rebuild every time a watched file or directory is changed. Used for setting up [`watch`](https://wagmi.sh/cli/api/commands/generate#w-watch) mode.
*   Defaults to `true`.

### include [‚Äã](#include)

`string[] | undefined`

Artifact files to include relative to `artifacts`. Supports glob patterns.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({
          include: [  
            // the following patterns are included by default
            '*.json',  
          ],  
        }),
      ],
    })

### namePrefix [‚Äã](#nameprefix)

`string | undefined`

Prefix to prepend to artifact names. Useful for preventing name collisions between contracts from other sources.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({  
          namePrefix: 'HelloFoundry',  
        }),  
      ],
    })

### project [‚Äã](#project)

`string | undefined`

*   Path to Foundry project.
*   Defaults to Foundry configuration using `forge config --json` command.

ts

    import { defineConfig } from '@wagmi/cli'
    import { foundry } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        foundry({ 
          project: '../hello_foundry', 
        }), 
      ],
    })</content>
</page>

<page>
  <title>actions | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/actions</url>
  <content>Plugin for type-safe VanillaJS actions.

Import [‚Äã](#import)
-------------------

ts

    import { actions } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { actions } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        actions(),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type ActionsConfig } from '@wagmi/cli/plugins'

### getActionName [‚Äã](#getactionname)

``'legacy' | ((options: { contractName: string; type: 'read' | 'simulate' | 'watch' | 'write' }) => `use${string}`)``

*   Function for setting custom hook names.
*   Defaults to `` `${type}${contractName}` ``. For example, `readErc20`, `simulateErc20`, `watchErc20Event`, `writeErc20`.
*   When `'legacy'` (deprecated), hook names are set to `@wagmi/cli@1` format.

ts

    import { defineConfig } from '@wagmi/cli'
    import { actions } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        actions({
          getActionName({ contractName, type }) { 
            return `${contractName}__${type}`
          }, 
        }),
      ],
    })

### overridePackageName [‚Äã](#overridepackagename)

`'@wagmi/core' | 'wagmi'`

*   Override detected import source.
*   Defaults to `'wagmi'` or `'@wagmi/core'` depending on which package is installed.

ts

    import { defineConfig } from '@wagmi/cli'
    import { actions } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        actions({
          overridePackageName: 'wagmi', 
        }),
      ],
    })</content>
</page>

<page>
  <title>blockExplorer | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/blockExplorer</url>
  <content>Plugin for fetching ABIs from block explorers that supports the `?module=contract&action=getabi` API format.

Import [‚Äã](#import)
-------------------

ts

    import { blockExplorer } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          baseUrl: 'https://api.etherscan.io/v2/api',
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type BlockExplorerConfig } from '@wagmi/cli/plugins'

### apiKey [‚Äã](#apikey)

`string | undefined`

API key for block explorer. Appended to the request URL as query param `&apikey=${apiKey}`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          apiKey: process.env.ETHERSCAN_API_KEY, 
          baseUrl: 'https://api.etherscan.io/v2/api',
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

### baseUrl [‚Äã](#baseurl)

`string`

Base URL for block explorer.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          baseUrl: 'https://api.etherscan.io/v2/api', 
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

### cacheDuration [‚Äã](#cacheduration)

`number | undefined`

Duration in milliseconds to cache ABIs. Defaults to `1_800_000` (30 minutes).

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          baseUrl: 'https://api.etherscan.io/v2/api',
          cacheDuration: 300_000, 
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

### chainId [‚Äã](#chainid)

`number | undefined`

Chain ID for block explorer. Appended to the request URL as query param `&chainId=${chainId}`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          apiKey: process.env.ETHERSCAN_API_KEY,
          baseUrl: 'https://api.etherscan.io/v2/api',
          chainId: 1, 
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

### contracts [‚Äã](#contracts)

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          baseUrl: 'https://api.etherscan.io/v2/api',
          contracts: [ 
            { 
              name: 'Wagmigotchi', 
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1', 
            }, 
          ], 
        }),
      ],
    })

### getAddress [‚Äã](#getaddress)

`((config: { address: Address | Record<number, Address> }) => Address) | undefined`

*   Function to get address from contract config.
*   Defaults to `({ address }) => typeof address === 'string' ? address : Object.values(address)[0]`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          baseUrl: 'https://api.etherscan.io/v2/api',
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          getAddress({ address }) { 
            if (typeof address === 'string') return address
            return Object.values(address)[0] 
          }, 
        }),
      ],
    })

### name [‚Äã](#name)

`string`

*   Name of source.
*   Defaults to `'Block Explorer'`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        blockExplorer({
          baseUrl: 'https://api.etherscan.io/v2/api',
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          name: 'Etherscan', 
        }),
      ],
    })</content>
</page>

<page>
  <title>etherscan | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/etherscan</url>
  <content>Plugin for fetching ABIs from [Etherscan](https://etherscan.io/) and adding into `contracts` config.

Import [‚Äã](#import)
-------------------

ts

    import { etherscan } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { etherscan } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY,
          chainId: 1,
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type EtherscanConfig } from '@wagmi/cli/plugins'

### apiKey [‚Äã](#apikey)

`string`

Etherscan API key. Etherscan API keys are specific per network and include testnets (e.g. Ethereum Mainnet and Sepolia share same API key).

ts

    import { defineConfig } from '@wagmi/cli'
    import { etherscan } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY, 
          chainId: 1,
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

### cacheDuration [‚Äã](#cacheduration)

`number | undefined`

*   Duration in milliseconds to cache ABIs.
*   Defaults to `1_800_000` (30 minutes).

ts

    import { defineConfig } from '@wagmi/cli'
    import { etherscan } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY,
          cacheDuration: 300_000, 
          chainId: 1,
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
        }),
      ],
    })

### chainId [‚Äã](#chainid)

`number`

Chain ID to use for fetching ABI. If [`address`](https://wagmi.sh/cli/config/options#address) is an object, `chainId` is used to select the address.

View supported chains on the [Etherscan docs](https://docs.etherscan.io/etherscan-v2/getting-started/supported-chains).

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY,
          chainId: 1, 
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
            {
              name: 'EnsRegistry',
              address: {
                1: '0x314159265dd8dbb310642f98f50c066173c1259b',
                5: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
              },
            },
          ],
        }),
      ],
    })

### contracts [‚Äã](#contracts)

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

ts

    import { defineConfig } from '@wagmi/cli'
    import { etherscan } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY,
          chainId: 1,
          contracts: [ 
            { 
              name: 'Wagmigotchi', 
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1', 
            }, 
          ], 
        }),
      ],
    })

### tryFetchProxyImplementation [‚Äã](#tryfetchproxyimplementation)

`boolean | undefined`

*   Whether to try fetching proxy implementation address of the contract.
*   Defaults to `false`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { blockExplorer } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        etherscan({
          apiKey: process.env.ETHERSCAN_API_KEY,
          chainId: 1, 
          contracts: [
            {
              name: 'FiatToken',
              address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
            },
          ],
          tryFetchProxyImplementation: true, 
        }),
      ],
    })</content>
</page>

<page>
  <title>fetch | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/fetch</url>
  <content>Plugin for fetching and parsing ABIs from network resource with `fetch`.

Import [‚Äã](#import)
-------------------

ts

    import { fetch } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        fetch({
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          request(contract) {
            if (!contract.address) throw new Error('address is required')
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0]
            return {
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
            }
          },
        }),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type FetchConfig } from '@wagmi/cli/plugins'

### cacheDuration [‚Äã](#cacheduration)

`number | undefined`

*   Duration in milliseconds to cache ABIs.
*   Defaults to `1_800_000` (30 minutes).

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        fetch({
          cacheDuration: 300_000, 
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          request(contract) {
            if (!contract.address) throw new Error('address is required')
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0]
            return {
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
            }
          },
        }),
      ],
    })

### contracts [‚Äã](#contracts)

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        fetch({
          contracts: [ 
            { 
              name: 'Wagmigotchi', 
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1', 
            }, 
          ], 
          request(contract) {
            if (!contract.address) throw new Error('address is required')
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0]
            return {
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
            }
          },
        }),
      ],
    })

### getCacheKey [‚Äã](#getcachekey)

`((config: { contract: { address: Address | Record<chainId, Address> | undefined; name: string } }) => string) | undefined`

*   Function for creating a cache key for contract. Contract data is cached at `~/.wagmi-cli/plugins/fetch/cache/`.
*   Defaults to `({ contract }) => JSON.stringify(contract)`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        fetch({
          contracts: [
            {
              name: 'wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          getCacheKey({ contract }) { 
            if (typeof contract.address === 'string') 
              return `${name}:${contract.address}`
            return `${name}:${JSON.stringify(contract.address)}`
          }, 
          request(contract) {
            if (!contract.address) throw new Error('address is required')
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0]
            return {
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
            }
          },
        }),
      ],
    })

### name [‚Äã](#name)

`string`

*   Name of source.
*   Defaults to `'Fetch'`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        fetch({
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          name: 'Etherscan', 
          request(contract) {
            if (!contract.address) throw new Error('address is required')
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0]
            return {
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
            }
          },
        }),
      ],
    })

### parse [‚Äã](#parse)

`((config: { response: Response }) => Abi | Promise<Abi>) | undefined`

*   Function for parsing ABI from fetch response.
*   Defaults to `({ response }) => response.json()`

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
     
    export default defineConfig({
      plugins: [
        fetch({
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          async parse({ response }) { 
            const json = await response.json()
            if (json.status === '0') throw new Error(json.message) 
            return json.result
          }, 
          request(contract) {
            if (!contract.address) throw new Error('address is required')
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0]
            return {
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,
            }
          },
        }),
      ],
    })

### request [‚Äã](#request)

`(config: { address?: Address | Record<chainId, Address> | undefined }) => { url: RequestInfo; init?: RequestInit | undefined } | Promise<{ url: RequestInfo; init?: RequestInit | undefined }>`

Function for returning a request to fetch ABI from.

ts

    import { defineConfig } from '@wagmi/cli'
    import { fetch } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        fetch({
          contracts: [
            {
              name: 'Wagmigotchi',
              address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
            },
          ],
          request(contract) { 
            if (!contract.address) throw new Error('address is required') 
            const address =
              typeof contract.address === 'string'
                ? contract.address
                : Object.values(contract.address)[0] 
            return { 
              url: `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`, 
            } 
          }, 
        }),
      ],
    })</content>
</page>

<page>
  <title>hardhat | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/hardhat</url>
  <content>Plugin for resolving ABIs from [Hardhat](https://hardhat.org/) projects. Supports [`watch`](https://wagmi.sh/cli/api/commands/generate#w-watch) mode.

ts

    import { hardhat } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          project: '../hello_hardhat',
        }),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type HardhatConfig } from '@wagmi/cli/plugins'

### artifacts [‚Äã](#artifacts)

`string | undefined`

*   Project's artifacts directory. Same as your project's `artifacts` [path configuration](https://hardhat.org/hardhat-runner/docs/config#path-configuration) option.
*   Defaults to `'artifacts/'`.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          artifacts: 'out/', 
          project: '../hello_hardhat',
        }),
      ],
    })

### deployments [‚Äã](#deployments)

`{ [key: string]: address?: Address | Record<chainId, Address> | undefined } | undefined`

Mapping of addresses to attach to artifacts.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          project: '../hello_hardhat',
          deployments: { 
            Counter: { 
              1: '0x314159265dd8dbb310642f98f50c066173c1259b', 
              5: '0x112234455c3a32fd11230c42e7bccd4a84e02010', 
            }, 
          }, 
        }),
      ],
    })

### exclude [‚Äã](#exclude)

`string[] | undefined`

Artifact files to exclude relative to `artifacts`. Supports glob patterns.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          exclude: [ 
            // the following patterns are excluded by default
            'build-info/**', 
            '*.dbg.json', 
          ], 
          project: '../hello_hardhat',
        }),
      ],
    })

### commands [‚Äã](#commands)

`{ clean?: string | boolean | undefined; build?: string | boolean | undefined; rebuild?: string | boolean | undefined } | undefined`

Hardhat command options.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          commands: { 
            clean: 'pnpm hardhat clean', 
            build: 'pnpm hardhat compile', 
            rebuild: 'pnpm hardhat compile', 
          }, 
          project: '../hello_hardhat',
        }),
      ],
    })

#### clean [‚Äã](#clean)

*   Remove build artifacts and cache directories on start up.
*   Defaults to `'${packageManger} hardhat clean'`.

#### build [‚Äã](#build)

*   Build Foundry project before fetching artifacts.
*   Defaults to `'${packageManger} hardhat compile'`.

#### rebuild [‚Äã](#rebuild)

*   Command to run when watched file or directory is changed. Used for setting up [`watch`](https://wagmi.sh/cli/api/commands/generate#w-watch) mode.
*   Defaults to `'${packageManger} hardhat compile'`.

### include [‚Äã](#include)

`string[] | undefined`

Artifact files to include relative to `artifacts`. Supports glob patterns.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          include: [ 
            // the following patterns are included by default
            '*.json', 
          ], 
          project: '../hello_hardhat',
        }),
      ],
    })

### namePrefix [‚Äã](#nameprefix)

`string | undefined`

Prefix to prepend to artifact names. Useful for preventing name collisions between contracts from other sources.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          namePrefix: 'HelloHardhat', 
          project: '../hello_hardhat',
        }),
      ],
    })

### project [‚Äã](#project)

`string`

Path to Hardhat project.

ts

    import { defineConfig } from '@wagmi/cli'
    import { hardhat } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        hardhat({
          project: '../hello_hardhat', 
        }),
      ],
    })</content>
</page>

<page>
  <title>react | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/react</url>
  <content>Plugin for generating type-safe [Wagmi Hooks](https://wagmi.sh/react/api/hooks).

Import [‚Äã](#import)
-------------------

ts

    import { react } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { react } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        react(),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type ReactConfig } from '@wagmi/cli/plugins'

### getHookName [‚Äã](#gethookname)

``'legacy' | ((options: { contractName: string; type: 'read' | 'simulate' | 'watch' | 'write' }) => `use${string}`)``

*   Function for setting custom hook names.
*   Defaults to `` `use${type}${contractName}` ``. For example, `useReadErc20`, `useSimulateErc20`, `useWatchErc20Event`, `useWriteErc20`.
*   When `'legacy'` (deprecated), hook names are set to `@wagmi/cli@1` format.

ts

    import { defineConfig } from '@wagmi/cli'
    import { react } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        react({
          getHookName({ contractName, type }) { 
            return `use${contractName}__${type}`
          }, 
        }),
      ],
    })</content>
</page>

<page>
  <title>Why Wagmi | Wagmi</title>
  <url>https://wagmi.sh/vue/why</url>
  <content>The Problems [‚Äã](#the-problems)
-------------------------------

Building Ethereum applications is hard. Apps need to support connecting wallets, multiple chains, signing messages and data, sending transactions, listening for events and state changes, refreshing stale blockchain data, and much more. This is all on top of solving for app-specific use-cases and providing polished user experiences.

The ecosystem is also continuously evolving, meaning you need to adapt to new improvements or get left behind. App developers should not need to worry about connecting tens of different wallets, the intricacies of multi-chain support, typos accidentally sending an order of magnitude more ETH or calling a misspelled contract function, or accidentally spamming their RPC provider, costing thousands in compute units.

Wagmi solves all these problems and more ‚Äî allowing app developers to focus on building high-quality and performant experiences for Ethereum ‚Äî by focusing on **developer experience**, **performance**, **feature coverage**, and **stability.**

Developer Experience [‚Äã](#developer-experience)
-----------------------------------------------

Wagmi delivers a great developer experience through modular and composable APIs, automatic type safety and inference, and comprehensive documentation.

It provides developers with intuitive building blocks to build their Ethereum apps. While Wagmi's APIs might seem more verbose at first, it makes Wagmi's modular building blocks extremely flexible. Easy to move around, change, and remove. It also allows developers to better understand Ethereum concepts as well as understand _what_ and _why_ certain properties are being passed through. Learning how to use Wagmi is a great way to learn how to interact with Ethereum in general.

Wagmi also provides [strongly typed APIs](https://wagmi.sh/vue/typescript), allowing consumers to get the best possible experience through [autocomplete](https://twitter.com/awkweb/status/1555678944770367493), [type inference](https://twitter.com/jakemoxey/status/1570244174502588417?s=20), as well as static validation. You often just need to provide an ABI and Wagmi can help you autocomplete your way to success, identify type errors before your users do, drill into blockchain errors [at compile and runtimes](https://wagmi.sh/vue/guides/error-handling) with surgical precision, and much more.

The API documentation is comprehensive and contains usage info for _every_ module in Wagmi. The core team uses a [documentation](https://gist.github.com/zsup/9434452) and [test driven](https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20\(TDD\),software%20against%20all%20test%20cases.) development approach to building modules, which leads to predictable and stable APIs.

Performance [‚Äã](#performance)
-----------------------------

Performance is critical for applications on all sizes. Slow page load and interactions can cause users to stop using applications. Wagmi uses and is built by the same team behind [Viem](https://viem.sh/), the most performant production-ready Ethereum library.

End users should not be required to download a module of over 100kB in order to interact with Ethereum. Wagmi is optimized for tree-shaking and dead-code elimination, allowing apps to minimize bundle size for fast page load times.

Data layer performance is also critical. Slow, unnecessary, and manual data fetching can make apps unusable and cost thousands in RPC compute units. Wagmi supports caching, deduplication, persistence, and much more through [TanStack Query](https://wagmi.sh/vue/guides/tanstack-query).

Feature Coverage [‚Äã](#feature-coverage)
---------------------------------------

Wagmi supports the most popular and commonly-used Ethereum features out of the box with 40+ Vue Composables for accounts, wallets, contracts, transactions, signing, ENS, and more. Wagmi also supports just about any wallet out there through it's official [connectors](https://wagmi.sh/vue/api/connectors), [EIP-6963 support](https://wagmi.sh/vue/api/createConfig#multiinjectedproviderdiscovery), and [extensible API](https://wagmi.sh/dev/creating-connectors).

If you need lower-level control, you can always drop down to [Wagmi Core](https://wagmi.sh/core/getting-started) or [Viem](https://viem.sh/), which Wagmi uses internally to perform blockchain operations. Wagmi also manages multi-chain support automatically so developers can focus on their applications instead of adding custom code.

Finally, Wagmi has a [CLI](https://wagmi.sh/cli/getting-started) to manage ABIs as well as a robust ecosystem of third-party libraries, like [ConnectKit](https://docs.family.co/connectkit), [RainbowKit](https://www.rainbowkit.com/), [AppKit](https://walletconnect.com/appkit), [Dynamic](https://www.dynamic.xyz/), [Privy](https://privy.io/), and many more, so you can get started quickly without needing to build everything from scratch.

Stability [‚Äã](#stability)
-------------------------

Stability is a fundamental principle for Wagmi. Many organizations, large and small, rely heavily on Wagmi and expect it to be entirely stable for their users and applications.

Wagmi's test suite runs against forked Ethereum nodes to make sure functions work across chains. The test suite also runs type tests against many different versions of peer dependencies, like TypeScript, to ensure compatibility with the latest releases of other popular software.

Wagmi follows semver so developers can upgrade between versions with confidence. Starting with Wagmi v2, new functionality will be opt-in with old functionality being deprecated alongside the new features. This means upgrading to the latest major versions will not require immediate changes.

Lastly, the core team works full-time on Wagmi and [related projects](https://github.com/wevm), and is constantly improving Wagmi and keeping it up-to-date with industry trends and changes.</content>
</page>

<page>
  <title>Error Handling | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/error-handling</url>
  <content>The `error` property in Wagmi Composables is strongly typed with it's corresponding error type. This enables you to have granular precision with handling errors in your application.

You can discriminate the error type by using the `name` property on the error object.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import {  } from 'wagmi'
    
    const { ,  } = ()
    
    
    ?.
    
    
    
    
    
    </script>
    
    <template>
      < v-if="?. === 'HttpRequestError'">
        A HTTP error occurred. Status: {{ . }}
      </>
    
      < v-else-if="?. === 'LimitExceededRpcError'">
        Rate limit exceeded. Code: {{ . }}
      </>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })</content>
</page>

<page>
  <title>Installation | Wagmi</title>
  <url>https://wagmi.sh/vue/installation</url>
  <content>Install Wagmi via your package manager, a `<script>` tag, or build from source.

Package Manager [‚Äã](#package-manager)
-------------------------------------

Install the required packages.

pnpmnpmyarnbun

bash

    pnpm add @wagmi/vue viem@2.x @tanstack/vue-query

bash

    npm install @wagmi/vue viem@2.x @tanstack/vue-query

bash

    yarn add @wagmi/vue viem@2.x @tanstack/vue-query

bash

    bun add @wagmi/vue viem@2.x @tanstack/vue-query

*   [Viem](https://viem.sh/) is a TypeScript interface for Ethereum that performs blockchain operations.
*   [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.
*   [TypeScript](https://wagmi.sh/vue/typescript) is optional, but highly recommended. Learn more about [TypeScript support](https://wagmi.sh/vue/typescript).

Requirements [‚Äã](#requirements)
-------------------------------

Wagmi is optimized for modern browsers. It is compatible with the latest versions of the following browsers.

Using Unreleased Commits [‚Äã](#using-unreleased-commits)
-------------------------------------------------------

If you can't wait for a new release to test the latest features, you can either install from the `canary` tag (tracks the [`main`](https://github.com/wevm/wagmi/tree/main) branch).

pnpmnpmyarnbun

bash

    pnpm add @wagmi/vue@canary

bash

    npm install @wagmi/vue@canary

bash

    yarn add @wagmi/vue@canary

bash

    bun add @wagmi/vue@canary

Or clone the [Wagmi repo](https://github.com/wevm/wagmi) to your local machine, build, and link it yourself.

bash

    gh repo clone wevm/wagmi
    cd wagmi
    pnpm install
    pnpm build
    cd packages/vue
    pnpm link --global

Then go to the project where you are using Wagmi and run `pnpm link --global @wagmi/vue` (or the package manager that you used to link Wagmi globally). Make sure you installed any [required peer dependencies](#package-manager) and their versions are correct.

Security [‚Äã](#security)
-----------------------

Ethereum-related projects are often targeted in attacks to steal users' assets. Make sure you follow security best-practices for your project. Some quick things to get started.

*   Pin package versions, upgrade mindfully, and inspect lockfile changes to minimize the risk of [supply-chain attacks](https://nodejs.org/en/guides/security/#supply-chain-attacks).
*   Install the [Socket Security](https://socket.dev/) [GitHub App](https://github.com/apps/socket-security) to help detect and block supply-chain attacks.
*   Add a [Content Security Policy](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) to defend against external scripts running in your app.
*   Pin [GitHub Action](https://x.com/paulmillr/status/1900948425325031448) versions to commits instead of tags.</content>
</page>

<page>
  <title>TypeScript | Wagmi</title>
  <url>https://wagmi.sh/vue/typescript</url>
  <content>Requirements [‚Äã](#requirements)
-------------------------------

Wagmi is designed to be as type-safe as possible! Things to keep in mind:

*   Types currently require using TypeScript >=5.0.4.
*   [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases.
*   Changes to types in this repository are considered non-breaking and are usually released as patch changes (otherwise every type enhancement would be a major version!).
*   It is highly recommended that you lock your `wagmi` and `typescript` versions to specific patch releases and upgrade with the expectation that types may be fixed or upgraded between any release.
*   The non-type-related public API of Wagmi still follows semver very strictly.

To ensure everything works correctly, make sure your `tsconfig.json` has [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode set to `true`.

tsconfig.json

json

    {
      "compilerOptions": {
        "strict": true
      }
    }

Config Types [‚Äã](#config-types)
-------------------------------

By default Vue Plugins does not work well with type inference. To support strong type-safety across the Vue Plugins boundary, there are two options available:

*   Declaration merging to "register" your `config` globally with TypeScript.
*   `config` property to pass your `config` directly to composables.

### Declaration Merging [‚Äã](#declaration-merging)

[Declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) allows you to "register" your `config` globally with TypeScript. The `Register` type enables Wagmi to infer types in places that wouldn't normally have access to type info via a Vue Plugin alone.

To set this up, add the following declaration to your project. Below, we co-locate the declaration merging and the `config` set up.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    declare module '@wagmi/vue' {
      interface Register {
        config: typeof config
      }
    }
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Since the `Register` type is global, you only need to add it once in your project. Once set up, you will get strong type-safety across your entire project. For example, query composables will type `chainId` based on your `config`'s `chains`.

ts

    import {  } from '@wagmi/vue'
    
    ({ chainId: 123 })Type '123' is not assignable to type 'DeepMaybeRef<1 | 11155111 | undefined>'.

You just saved yourself a runtime error and you didn't even need to pass your `config`. üéâ

### Hook `config` Property [‚Äã](#hook-config-property)

For cases where you have more than one Wagmi `config` or don't want to use the declaration merging approach, you can pass a specific `config` directly to composables via the `config` property.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, optimism } from '@wagmi/vue/chains'
    
    export const configA = createConfig({ 
      chains: [mainnet], 
      transports: { 
        [mainnet.id]: http(), 
      }, 
    })
    
    export const configB = createConfig({ 
      chains: [optimism], 
      transports: { 
        [optimism.id]: http(), 
      }, 
    })

As you expect, `chainId` is inferred correctly for each `config`.

ts

    import {  } from '@wagmi/vue'
    
    ({ chainId: 123, :  })Type '123' is not assignable to type 'DeepMaybeRef<1 | undefined>'.({ chainId: 123, :  })Type '123' is not assignable to type 'DeepMaybeRef<10 | undefined>'.

This approach is more explicit, but works well for advanced use-cases, if you don't want to use a Vue Plugin or declaration merging, etc.

Const-Assert ABIs & Typed Data [‚Äã](#const-assert-abis-typed-data)
-----------------------------------------------------------------

Wagmi can infer types based on [ABIs](https://docs.soliditylang.org/en/latest/abi-spec.html#json) and [EIP-712](https://eips.ethereum.org/EIPS/eip-712) Typed Data definitions, powered by [Viem](https://viem.sh/) and [ABIType](https://github.com/wevm/abitype). This achieves full end-to-end type-safety from your contracts to your frontend and enlightened developer experience by autocompleting ABI item names, catching misspellings, inferring argument and return types (including overloads), and more.

For this to work, you must either [const-assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) ABIs and Typed Data (more info below) or define them inline. For example, `useReadContract`'s `abi` configuration parameter:

ts

    const { data } = useReadContract({
      abi: [‚Ä¶], // <--- defined inline
    })

ts

    const abi = [‚Ä¶] as const // <--- const assertion
    const { data } = useReadContract({ abi })

If type inference isn't working, it's likely you forgot to add a `const` assertion or define the configuration parameter inline. Also, make sure your ABIs, Typed Data definitions, and [TypeScript configuration](#requirements) are valid and set up correctly.

Anywhere you see the `abi` or `types` configuration property, you can likely use const-asserted or inline ABIs and Typed Data to get type-safety and inference. These properties are also called out in the docs.

Here's what [`useReadContract`](https://wagmi.sh/vue/api/composables/useReadContract) looks like with and without a const-asserted `abi` property.

Const-AssertedNot Const-Asserted

ts

    import {  } from '@wagmi/vue'
    
    const {  } = ({
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      : 'balanceOf',
    
    
    
      : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    
    

ts

    import {  } from '@wagmi/vue'
    
    const {  } = ({
      : '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      : ,
      : 'balanceOf',
    
    
    
      : ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
    })
    
    
    

You can prevent runtime errors and be more productive by making sure your ABIs and Typed Data definitions are set up appropriately. üéâ

ts

    import {  } from '@wagmi/vue'
    
    ({
      : ,
      functionName: 'balanecOf',Type '"balanecOf"' is not assignable to type 'DeepMaybeRef<"balanceOf" | "isApprovedForAll" | "getApproved" | "ownerOf" | "tokenURI" | undefined>'. Did you mean '"balanceOf"'?})

Configure Internal Types [‚Äã](#configure-internal-types)
-------------------------------------------------------

For advanced use-cases, you may want to configure Wagmi's internal types. Most of Wagmi's types relating to ABIs and EIP-712 Typed Data are powered by [ABIType](https://github.com/wevm/abitype). See the [ABIType docs](https://abitype.dev/) for more info on how to configure types.</content>
</page>

<page>
  <title>TanStack Query | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/tanstack-query</url>
  <content>Wagmi Composables are not only a wrapper around the core [Wagmi Actions](https://wagmi.sh/core/api/actions), but they also utilize [TanStack Query](https://tanstack.com/query/v5) to enable trivial and intuitive fetching, caching, synchronizing, and updating of asynchronous data in your Vue applications.

Without an asynchronous data fetching abstraction, you would need to handle all the negative side-effects that comes as a result, such as: representing finite states (loading, error, success), handling race conditions, caching against a deterministic identifier, etc.

Queries & Mutations [‚Äã](#queries-mutations)
-------------------------------------------

Wagmi Composables represent either a **Query** or a **Mutation**.

**Queries** are used for fetching data (e.g. fetching a block number, reading from a contract, etc), and are typically invoked on mount by default. All queries are coupled to a unique [Query Key](#query-keys), and can be used for further operations such as refetching, prefetching, or modifying the cached data.

**Mutations** are used for mutating data (e.g. connecting/disconnecting accounts, writing to a contract, switching chains, etc), and are typically invoked in response to a user interaction. Unlike **Queries**, they are not coupled with a query key.

Terms [‚Äã](#terms)
-----------------

*   **Query**: An asynchronous data fetching (e.g. read data) operation that is tied against a unique Query Key.
*   **Mutation**: An asynchronous mutating (e.g. create/update/delete data or side-effect) operation.
*   **Query Key**: A unique identifier that is used to deterministically identify a query. It is typically a tuple of the query name and the query arguments.
*   **Stale Data**: Data that is unused or inactive after a certain period of time.
*   **Query Fetching**: The process of invoking an async query function.
*   **Query Refetching**: The process of refetching **rendered** queries.
*   **[Query Invalidation](https://tanstack.com/query/v5/docs/vue/guides/query-invalidation)**: The process of marking query data as stale (e.g. inactive/unused), and refetching **rendered** queries.
*   **[Query Prefetching](https://tanstack.com/query/v5/docs/vue/guides/prefetching)**: The process of prefetching queries and seeding the cache.

Query Keys [‚Äã](#query-keys)
---------------------------

Query Keys are typically used to perform advanced operations on the query such as: invalidation, refetching, prefetching, etc.

Wagmi exports Query Keys for every Composable, and they can be retrieved via the [Composable (Vue)](#composable-vue) or via an [Import (Vanilla JS)](#import-vanilla-js).

Read more about **Query Keys** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/vue/guides/query-keys)

### Composable (Vue) [‚Äã](#composable-vue)

Each Composable returns a `queryKey` value. You would use this approach when you want to utilize the query key in a Vue component as it handles reactivity for you, unlike the [Import](#import-vanilla-js) method below.

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const { data: balance } = useBalance()
    </script>
    
    <template>
      <div>{{ balance }}</div>
    </template>

### Import (Vanilla JS) [‚Äã](#import-vanilla-js)

Each Hook has a corresponding `get<X>QueryOptions` function that returns a query key. You would use this method when you want to utilize the query key outside of a Vue component in a Vanilla JS context, like in a utility function.

ts

    import { getBalanceQueryOptions } from '@wagmi/vue/query'
    import { config } from './config'
    
    function perform() {
      const { queryKey } = getBalanceQueryOptions(config, { 
        chainId: config.state.chainId
      })
    }

WARNING

The caveat of this method is that it does not handle reactivity for you (e.g. active account/chain changes, argument changes, etc). You would need to handle this yourself by explicitly passing through the arguments to `get<X>QueryOptions`.

Invalidating Queries [‚Äã](#invalidating-queries)
-----------------------------------------------

Invalidating a query is the process of marking the query data as stale (e.g. inactive/unused), and refetching the queries that are already rendered.

Read more about **Invalidating Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/vue/guides/query-invalidation)

#### Example: Watching a Users' Balance [‚Äã](#example-watching-a-users-balance)

You may want to "watch" a users' balance, and invalidate the balance after each incoming block. We can invoke `invalidateQueries` inside a `watchEffect` ‚Äì this will refetch all rendered balance queries when the `blockNumber` changes.

vue

    <script setup lang="ts">
    import { useQueryClient } from '@tanstack/vue-query' 
    import { useBlockNumber, useBalance } from '@wagmi/vue' 
    import { watchEffect } from 'vue' 
    
    const queryClient = useQueryClient()
    const { data: blockNumber } = useBlockNumber({ watch: true })
    const { data: balance, queryKey } = useBalance()
      
    watchEffect(() => {
      queryClient.invalidateQueries({ queryKey })
    })
    </script>
    
    <template>
      <div>Block Number: {{ blockNumber }}</div>
      <div>Balance: {{ balance }}</div>
    </template>

#### Example: After User Interaction [‚Äã](#example-after-user-interaction)

Maybe you want to invalidate a users' balance after some interaction. This would mark the balance as stale, and consequently refetch all rendered balance queries.

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    // 1. Extract `queryKey` from the useBalance Hook.
    const { queryKey } = useBalance()
    </script>
    
    <template>
      // 2. Add a button that invalidates the balance query.
      <button @click="queryClient.invalidateQueries({ queryKey })">
        Invalidate
      </button>
    </template>

vue

    <script setup lang="ts">
    // 3. Other `useBalance` Hooks in your rendered Vue tree will be refetched!
    const { data: balance } = useBalance()
    </script>
    
    <template>
      <div>{{ balance }}</div>
    </template>

Fetching Queries [‚Äã](#fetching-queries)
---------------------------------------

Fetching a query is the process of invoking the query function to retrieve data. If the query exists and the data is not invalidated or older than a given `staleTime`, then the data from the cache will be returned. Otherwise, the query will fetch for the latest data.

example.tsxmain.tsconfig.ts

tsx

    import { getBlockQueryOptions } from '@wagmi/vue/query'
    import { queryClient } from './main'
    import { config } from './config'
    
    export async function fetchBlockData() {
      return queryClient.fetchQuery(
        getBlockQueryOptions(config, {
          chainId: config.state.chainId,
        }
      ))
    }

ts

    import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
    import { WagmiPlugin } from '@wagmi/vue'
    import { createApp } from 'vue'
    
    import App from './App.vue'
    import { config } from './config'
    
    export const queryClient = new QueryClient()
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .use(VueQueryPlugin, { queryClient })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Retrieving & Updating Query Data [‚Äã](#retrieving-updating-query-data)
---------------------------------------------------------------------

You can retrieve and update query data imperatively with `getQueryData` and `setQueryData`. This is useful for scenarios where you want to retrieve or update a query outside of a Vue component.

Note that these functions do not invalidate or refetch queries.

example.tsxmain.tsconfig.ts

tsx

    import type { GetBalanceReturnType } from '@wagmi/vue/actions'
    import { getBalanceQueryOptions } from '@wagmi/vue/query'
    import { queryClient } from './app'
    import { config } from './config'
    
    export function getBalanceData() {
      return queryClient.getQueryData(
        getBalanceQueryOptions(config, {
          chainId: config.state.chainId,
        }
      ))
    }
    
    export function setBalanceData(parameters: Partial<GetBalanceReturnType>) {
      return queryClient.setQueryData(
        getBalanceQueryOptions(config, {
          chainId: config.state.chainId,
        },
        data => ({ ...data, ...parameters })
      ))
    }

ts

    import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
    import { WagmiPlugin } from '@wagmi/vue'
    import { createApp } from 'vue'
    
    import App from './App.vue'
    import { config } from './config'
    
    export const queryClient = new QueryClient()
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .use(VueQueryPlugin, { queryClient })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Prefetching Queries [‚Äã](#prefetching-queries)
---------------------------------------------

Prefetching a query is the process of fetching the data ahead of time and seeding the cache with the returned data. This is useful for scenarios where you want to fetch data before the user navigates to a page, or fetching data on the server to be reused on client hydration.

Read more about **Prefetching Queries** on the [TanStack Query docs.](https://tanstack.com/query/v5/docs/vue/guides/prefetching)

#### Example: Prefetching in Event Handler [‚Äã](#example-prefetching-in-event-handler)

vue

    <script setup lang="ts">
    import { useConfig, useChainId, useQueryClient } from '@wagmi/vue'
    import { getBlockQueryOptions } from '@wagmi/vue/query'
    
    const config = useConfig()
    const chainId = useChainId()
    const queryClient = useQueryClient()
    
    const prefetch = () => 
      queryClient.prefetchQuery(getBlockQueryOptions(config, { chainId })) 
    </script>
    
    <template>
      <a
        @mouseenter="prefetch" 
        @focus="prefetch" 
        href="..."
      >
        Block details
      </a>
    </template>

SSR [‚Äã](#ssr)
-------------

It is possible to utilize TanStack Query's SSR strategies with Wagmi Composables & Query Keys. Check out the [SSR guide](https://tanstack.com/query/latest/docs/framework/vue/guides/ssr).

TanStack Query includes dedicated [Devtools](https://tanstack.com/query/latest/docs/framework/vue/devtools) that assist in visualizing and debugging your queries, their cache states, and much more. You will have to pass a custom `queryKeyFn` to your `QueryClient` for Devtools to correctly serialize BigInt values for display. Alternatively, You can use the `hashFn` from `@wagmi/core/query`, which already handles this serialization.

#### Install [‚Äã](#install)

pnpmnpmyarnbun

bash

    pnpm i @tanstack/vue-query-devtools

bash

    npm i @tanstack/vue-query-devtools

bash

    yarn add @tanstack/vue-query-devtools

bash

    bun i @tanstack/vue-query-devtools

#### Usage [‚Äã](#usage)

App.vuemain.vue

vue

    <script setup>
    import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
    </script>
    
    <template>
      <VueQueryDevtools />
    </template>

vue

    <script setup lang="ts">
    import { createApp } from 'vue'
    import { WagmiPlugin } from '@wagmi/vue'
    import { QueryClient, VueQueryPlugin } from '@tanstack/vue-query'
    
    import App from './App.vue'
    import { config } from './config' 
    
    const queryClient = new QueryClient({ 
      defaultOptions: { 
        queries: { 
          queryKeyHashFn: hashFn, 
        }, 
      }, 
    });
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .use(VueQueryPlugin, { queryClient })
      .mount('#app')
    </script></content>
</page>

<page>
  <title>Viem | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/viem</url>
  <content>[Viem](https://viem.sh/) is a low-level TypeScript Interface for Ethereum that enables developers to interact with the Ethereum blockchain, including: JSON-RPC API abstractions, Smart Contract interaction, wallet & signing implementations, coding/parsing utilities and more.

**Wagmi Core** is essentially a wrapper over **Viem** that provides multi-chain functionality via [Wagmi Config](https://wagmi.sh/react/api/createConfig) and automatic account management via [Connectors](https://wagmi.sh/react/api/connectors).

Leveraging Viem Actions [‚Äã](#leveraging-viem-actions)
-----------------------------------------------------

All of the core [Wagmi Composables](https://wagmi.sh/vue/api/composables) are friendly wrappers around [Viem Actions](https://viem.sh/docs/actions/public/introduction.html) that inject a multi-chain and connector aware [Wagmi Config](https://wagmi.sh/vue/api/createConfig).

There may be cases where you might want to dig deeper and utilize Viem Actions directly (maybe a Composable doesn't exist in Wagmi yet). In these cases, you can create your own custom Wagmi Composable by importing Viem Actions directly via `viem/actions` and plugging in a Viem Client returned by the [`useClient` Composable](https://wagmi.sh/vue/api/composables/useClient).

There are two categories of Viem Actions:

*   **[Public Actions](https://viem.sh/docs/actions/public/introduction):** Actions that are "read-only" and do not require a wallet connection.
*   **[Wallet Actions](https://viem.sh/docs/actions/wallet/introduction):** Actions that interface with a Wallet and require a wallet connection.

While it is not mandatory, it is also recommended to pair Actions with either `useQuery` or `useMutation` to effectively leverage the reactivity and caching capabilities of [Tanstack Query](https://wagmi.sh/vue/guides/tanstack-query).

### Public Actions [‚Äã](#public-actions)

The example below demonstrates how to utilize Viem's `getLogs` Action with a `useQuery` Composable to create your own abstraction akin to a `useLogs` Composable.

vue

    <script setup lang="ts">
    // 1. Import modules. 
    import { useClient, useConnectorClient } from '@wagmi/vue' 
    import { useMutation, useQuery } from '@wagmi/vue/query'
    import { getLogs, watchAsset } from 'viem/actions'
    
    // 2. Extract a Viem Client for the current active chain. 
    const client = useClient() 
    
    // 3. Create a "custom" Query Composable that utilizes the Client. 
    const { data: logs } = useQuery( 
      computed(() => ({ 
        queryKey: ['logs', client.value.uid], 
        queryFn: () => getLogs(client.value) 
      })) 
    ) 
    </script>

### Wallet Actions [‚Äã](#wallet-actions)

The example below demonstrates how to utilize Viem's `watchAsset` Action with a `useMutation` Composable to create your own abstraction akin to a `useWatchAsset` Composable.

vue

    <script setup lang="ts">
    // 1. Import modules. 
    import { useConnectorClient } from '@wagmi/vue' 
    import { useMutation } from '@wagmi/vue/query'
    import { watchAsset } from 'viem/actions'
    
    // 2. Extract a Viem Client for the current active chain. 
    const { data: connectorClient } = useConnectorClient()
    
    // 3. Create a "custom" Mutation Composable that utilizes the Client. 
    const { mutate } = useMutation({
      mutationFn: (asset) => watchAsset(connectorClient, asset)
    })
    </script>

Private Key & Mnemonic Accounts [‚Äã](#private-key-mnemonic-accounts)
-------------------------------------------------------------------

It is possible to utilize Viem's [Private Key & Mnemonic Accounts](https://viem.sh/docs/accounts/local.html) with Wagmi by explicitly passing through the account via the `account` argument on Wagmi Actions.

vue

    <script setup lang="ts">
    import { privateKeyToAccount } from 'viem/accounts'
    import { useConfig } from '@wagmi/vue'
    import { sendTransactionMutationOptions, useMutation } from '@wagmi/vue/query'
    
    const config = useConfig()
    const { mutate: sendTransaction } = useMutation(
      sendTransactionMutationOptions(config)
    )
    
    const account = privateKeyToAccount('0x...')
    
    sendTransaction({
      account, 
      to: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
      value: parseEther('0.001')
    })
    </script>

INFO

Wagmi currently does not support hoisting Private Key & Mnemonic Accounts to the top-level Wagmi Config ‚Äì meaning you have to explicitly pass through the account to every Action. If you feel like this is a feature that should be added, please [open an discussion](https://github.com/wevm/wagmi/discussions/new?category=ideas).</content>
</page>

<page>
  <title>Creating Connectors | Wagmi</title>
  <url>https://wagmi.sh/dev/creating-connectors</url>
  <content>Thanks for your interest in adding a new connector to Wagmi! Please take a moment to review this document **before starting work on a new connector.**

Overview [‚Äã](#overview)
-----------------------

This guide details how to create new connectors and upstream them back into Wagmi. By following these steps, you will understand the development process, workflow, and requirements for new connectors. **Not all connectors will be accepted into Wagmi** for a variety of reasons outlined in this document.

In addition, for connector requests to be accepted, the team creating the connector must [sponsor Wagmi](https://github.com/sponsors/wevm). It takes time and effort to maintain third-party connectors. Wagmi is an OSS project that depends on sponsors and grants to continue our work. Please get in touch via [dev@wevm.dev](mailto:dev@wevm.dev) if you have questions about sponsoring.

**Please ask first before starting work on a new connector.**

To avoid having your pull request declined after investing time and effort into a new connector, we ask that contributors create a [Connector Request](https://github.com/wevm/wagmi/discussions/new?category=connector-request) before starting work. This ensures the connector solves for an important or general use-case of interest to Wagmi users and is well supported by the Wagmi and connector teams.

1\. Follow the contributing guide [‚Äã](#_1-follow-the-contributing-guide)
------------------------------------------------------------------------

Check out the [Contributing Guide](https://wagmi.sh/dev/contributing) to get your local development environment set up and learn more about the contributing workflow.

2\. Create a new file for the connector [‚Äã](#_2-create-a-new-file-for-the-connector)
------------------------------------------------------------------------------------

Create a new file in `packages/connector/src` named after the connector you want to add.

For example, if you want to add Foo, you would create a file named `foo.ts`. File names should be camel-cased and as short as possible.

3\. Create the connector object. [‚Äã](#_3-create-the-connector-object)
---------------------------------------------------------------------

Import `createConnector` from `@wagmi/core` and export a new function that accepts a parameters object and returns the `createConnector` result. This is the base of all connectors. The name of the connector name should be the same as the file name.

ts

    import { createConnector } from '@wagmi/core'
    
    export type FooBarBazParameters = {}
    
    export function fooBarBaz(parameters: FooBarBazParameters = {}) {
      return createConnector((config) => ({}))
    }

4\. Add the missing properties to the object [‚Äã](#_4-add-the-missing-properties-to-the-object)
----------------------------------------------------------------------------------------------

Now that the base of the connector is set up, you should see a type error that looks something like this:

ts

    (() => ({}))Type '{}' is missing the following properties from type '{ [x: string]: unknown; readonly icon?: string | undefined; readonly id: string; readonly name: string; readonly rdns?: string | readonly string[] | undefined; readonly supportsSimulation?: boolean | undefined; ... 14 more ...; onMessage?: ((message: ProviderMessage) => void) | undefined; }': id, name, type, connect, and 8 more.

The type error tells you what properties are missing from `createConnector`'s return type. Add them all in!

#### Properties [‚Äã](#properties)

*   `icon`: Optional icon URL for the connector.
*   `id`: The ID for the connector. This should be camel-cased and as short as possible. Example: `fooBarBaz`.
*   `name`: Human-readable name for the connector. Example: `'Foo Bar Baz'`.
*   `rdns`: Optional reverse DNS for the connector. This is used to filter out duplicate [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) injected providers when `createConfig#multiInjectedProviderDiscovery` is enabled.

#### Methods [‚Äã](#methods)

*   `connect`: Function for connecting the connector.
*   `disconnect`: Function for disconnecting the connector.
*   `getAccounts`: Function that returns the connected accounts for the connector.
*   `getChainId`: Function that returns the connected chain ID for the connector.
*   `getProvider`: Function that returns the underlying provider interface for internal use throughout the connector.
*   `isAuthorized`: Function that returns whether the connector has connected previously and is still authorized.
*   `setup`: Optional function for running when the connector is first created.
*   `switchChain`: Optional function for switching the connector's active chain.

#### Events [‚Äã](#events)

*   `onAccountsChanged`: Function for subscribing to account changes internally in the connector.
*   `onChainChanged`: Function for subscribing to chain changes internally in the connector.
*   `onConnect`: Function for subscribing to connection events internally in the connector.
*   `onDisconnect`: Function for subscribing to disconnection events internally in the connector.
*   `onMessage`: Optional function for subscribing to messages internally in the connector.

#### Parameters [‚Äã](#parameters)

`createConnector` also has the following config properties you can use within the connector:

*   `chains`: List of chains configured by the user.
*   `emitter`: Emitter for emitting events. Used to sync connector state with Wagmi `Config`. The following events are available:
    *   `change`: Emitted when the connected accounts or chain changes.
    *   `connect`: Emitted when the connector connects.
    *   `disconnect`: Emitted when the connector disconnects.
    *   `error`: Emitted when the connector receives an error.
    *   `message`: Emitted when the connector receives a message.
*   `storage`: Optional storage configured by the user. Defaults to wrapper around localStorage.

TIP

If you plan to use a third-party SDK, it should have minimal dependencies (limit bundle size, supply chain attacks, etc.) and use the most permissive license possible (ideally MIT). Any third-party packages, should also have [`"sideEffects": false`](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) in their `package.json` file for maximum tree-shakability support.

TIP

All address values returned and emitted by the connector should be checksummed using Viem's [`getAddress`](https://viem.sh/docs/utilities/getAddress).

5\. Export the connector [‚Äã](#_5-export-the-connector)
------------------------------------------------------

Export the connector from `packages/connector/src/exports/index.ts` in alphabetic order.

ts

    export { fooBarBaz } from './fooBarBaz.js'

6\. Try out the connector and add tests [‚Äã](#_6-try-out-the-connector-and-add-tests)
------------------------------------------------------------------------------------

While building a connector, it can be useful to try it out with Wagmi. You can use the [development playgrounds](https://wagmi.sh/dev/contributing#_5-running-the-dev-playgrounds) for testing your changes.

Ideally, you should also be able to add tests for the connector in a `connectorName.test.ts` file. This isn't always easy so at a minimum please create a test file with instructions for how to test the connector manually. The test file should include actual tests or "instruction tests" for the following:

*   How to connect the connector.
*   How to disconnect the connector.
*   How to switch the connector's active chain (if applicable).

Remember to include all info required to test the connector, like software to install (browser extension, mobile app, etc.), smart contracts to interact with/deploy, etc.

Finally, you should also update the test file in `packages/connectors/src/exports/index.test.ts` to include the new connector. You can do this manually or by running:

bash

    pnpm test:update packages/connectors/src/exports/index.test.ts

7\. Add your team to CODEOWNERS [‚Äã](#_7-add-your-team-to-codeowners)
--------------------------------------------------------------------

It is critical that connectors are updated in a timely manner and actively maintained so that users of Wagmi can rely on them in production settings.

The Wagmi core team will provide as much assistance as possible to keep connectors up-to-date with breaking changes from Wagmi, but it is your responsibility to ensure that any dependencies and issues/discussions related to the connector are handled in a timely manner. If issues are not resolved in a timely manner, the connector may be removed from Wagmi.

In support of this goal, add at least one member of your team to the [CODEOWNERS](https://github.com/wevm/wagmi/blob/main/.github/CODEOWNERS) file so that you get notified of pull requests, issues, etc. related to the connector. You can add your team like this:

    /packages/connectors/src/fooBarBaz @tmm @jxom

For more info about GitHub code owners, check out the [GitHub Documentation](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).

8\. Document the connector [‚Äã](#_8-document-the-connector)
----------------------------------------------------------

The connector should be documented. Follow the step on [writing documentation](https://wagmi.sh/dev/contributing#_7-writing-documentation) to get set up with running the docs site locally and add the required pages.

9\. Create a changeset [‚Äã](#_9-create-a-changeset)
--------------------------------------------------

Now that the connector works and has tests, it's time to create a changeset to prepare for release. Run the following to create a changeset:

The changeset should be a `patch` applied to the `@wagmi/connectors` repository with the description `Added [ConnectorName]`, For example, `Added Foo Bar Baz`.

10\. Create a pull request [‚Äã](#_10-create-a-pull-request)
----------------------------------------------------------

The connector is ready to go! Create a [pull request](https://wagmi.sh/dev/contributing#_8-submitting-a-pull-request) and the connector should make it into a future release of Wagmi after some review.</content>
</page>

<page>
  <title>SSR | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/ssr</url>
  <content>Wagmi uses client-only external stores (such as `localStorage` and `mipd`) to show the user the most relevant data as quickly as possible on first render.

However, the caveat of using these external client stores is that frameworks which incorporate SSR (such as Next.js) will throw hydration warnings on the client when it identifies mismatches between the server-rendered HTML and the client-rendered HTML.

To stop this from happening, you can toggle on the [`ssr`](https://wagmi.sh/vue/api/createConfig#ssr) property in the Wagmi Config.

tsx

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true,
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Turning on the `ssr` property means that content from the external stores will be hydrated on the client after the initial mount.

Persistence using Cookies [‚Äã](#persistence-using-cookies)
---------------------------------------------------------

As a result of turning on the `ssr` property, external persistent stores like `localStorage` will be hydrated on the client **after the initial mount**.

This means that you will still see a flash of "empty" data on the client (e.g. a `"disconnected"` account instead of a `"reconnecting"` account, or an empty address instead of the last connected address) until after the first mount, when the store hydrates.

In order to persist data between the server and the client, you can use cookies.

### 1\. Set up cookie storage [‚Äã](#_1-set-up-cookie-storage)

First, we will set up cookie storage in the Wagmi Config.

tsx

    import { 
      createConfig, 
      http, 
      cookieStorage,
      createStorage
    } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true,
      storage: createStorage({
        storage: cookieStorage,
      }),
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### 2\. Hydrate the cookie [‚Äã](#_2-hydrate-the-cookie)

Next, we will need to add some mechanisms to hydrate the stored cookie in Wagmi.

#### Nuxt.js [‚Äã](#nuxt-js)

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!

#### Vanilla SSR [‚Äã](#vanilla-ssr)

Would you like to contribute this content? Feel free to [open a Pull Request](https://github.com/wevm/wagmi/pulls)!</content>
</page>

<page>
  <title>Chain Properties | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/chain-properties</url>
  <content>Some chains support additional properties related to blocks and transactions. This is powered by Viem's [formatters](https://viem.sh/docs/chains/formatters) and [serializers](https://viem.sh/docs/chains/serializers). For example, Celo, ZkSync, OP Stack chains support all support additional properties. In order to use these properties in a type-safe way, there are a few things you should be aware of.

  

TIP

Make sure you follow the TypeScript guide's [Config Types](https://wagmi.sh/vue/typescript#config-types) section before moving on. The easiest way to do this is to use [Declaration Merging](https://wagmi.sh/vue/typescript#declaration-merging) to "register" your `config` globally with TypeScript.

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, celo, mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module '@wagmi/vue' {
      interface Register {
        config: typeof config
      }
    }

Narrowing Parameters [‚Äã](#narrowing-parameters)
-----------------------------------------------

Once your Config is registered with TypeScript, you are ready to access chain-specific properties! For example, Celo's `feeCurrency` is available.

index.tsxconfig.ts

ts

    import { parseEther } from 'viem'
    import { useSimulateContract } from '@wagmi/vue'
    
    const result = useSimulateContract({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
      feeCurrency: '0x‚Ä¶', 
    })

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, celo, mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module '@wagmi/vue' {
      interface Register {
        config: typeof config
      }
    }

This is great, but if you have multiple chains that support additional properties, your autocomplete could be overwhelmed with all of them. By setting the `chainId` property to a specific value (e.g. `celo.id`), you can narrow parameters to a single chain.

index.tsxconfig.ts

ts

    import { parseEther } from 'viem'
    import { useSimulateContract } from '@wagmi/vue'
    import { celo } from '@wagmi/vue/chains'
    
    const result = useSimulateContract({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
      chainId: celo.id, 
      feeCurrency: '0x‚Ä¶', 
      // ^? (property) feeCurrency?: `0x${string}` | undefined
    })

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, celo, mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module '@wagmi/vue' {
      interface Register {
        config: typeof config
      }
    }

Narrowing Return Types [‚Äã](#narrowing-return-types)
---------------------------------------------------

Return types can also have chain-specific properties attached to them. There are a couple approaches for extracting these properties.

### `chainId` Parameter [‚Äã](#chainid-parameter)

Not only can you use the `chainId` parameter to [narrow parameters](#narrowing-parameters), you can also use it to narrow the return type.

index.tsxconfig.ts

ts

    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    import { zkSync } from '@wagmi/vue/chains'
    
    const { data } = useWaitForTransactionReceipt({
      chainId: zkSync.id,
      hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
    })
    
    data?.logs
    //    ^? (property) logs: ZkSyncLog[] | undefined

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, celo, mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module '@wagmi/vue' {
      interface Register {
        config: typeof config
      }
    }

### `chainId` Data Property [‚Äã](#chainid-data-property)

Wagmi internally will set a `chainId` property on return types that you can use to narrow results. The `chainId` is determined from the `chainId` parameter or global state (e.g. connector). You can use this property to help TypeScript narrow the type.

index.tsxconfig.ts

ts

    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    import { zkSync } from '@wagmi/vue/chains'
    
    const { data } = useWaitForTransactionReceipt({
      hash: '0x16854fcdd0219cacf5aec5e4eb2154dac9e406578a1510a6fc48bd0b67e69ea9',
    })
    
    if (data?.chainId === zkSync.id) {
      data?.logs
      //    ^? (property) logs: ZkSyncLog[] | undefined
    }

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, celo, mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [base, celo, mainnet],
      transports: {
        [base.id]: http(),
        [celo.id]: http(),
        [mainnet.id]: http(),
      },
    })
    
    declare module '@wagmi/vue' {
      interface Register {
        config: typeof config
      }
    }

Troubleshooting [‚Äã](#troubleshooting)
-------------------------------------

If chain properties aren't working, make sure [TypeScript](https://wagmi.sh/vue/guides/faq#type-inference-doesn-t-work) is configured correctly. Not all chains have additional properties, to check which ones do, see the [Viem repo](https://github.com/wevm/viem/tree/main/src/chains) (chains that have a top-level directory under [`src/chains`](https://github.com/wevm/viem/tree/main/src/chains) support additional properties).</content>
</page>

<page>
  <title>Read from Contract | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/read-from-contract</url>
  <content>Overview [‚Äã](#overview)
-----------------------

The [`useReadContract` Composable](https://wagmi.sh/vue/api/composables/useReadContract) allows you to read data on a smart contract, from a `view` or `pure` (read-only) function. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

The component below shows how to retrieve the token balance of an address from the [Wagmi Example](https://etherscan.io/token/0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2) contract

ReadContract.vuecontracts.ts

vue

    <script setup lang="ts">
    import { useReadContract } from 'wagmi'
    import { wagmiContractConfig } from './contracts'
    
    const { data: balance } = useReadContract({
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
    })
    </script>
    
    <template>
      <div>Balance: {{ balance?.toString() }}</div>
    </template>

ts

    export const wagmiContractConfig = {
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      abi: [
        {
          type: 'function',
          name: 'balanceOf',
          stateMutability: 'view',
          inputs: [{ name: 'account', type: 'address' }],
          outputs: [{ type: 'uint256' }],
        },
        {
          type: 'function',
          name: 'totalSupply',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ name: 'supply', type: 'uint256' }],
        },
      ],
    } as const

If `useReadContract` depends on another value (`address` in the example below), you can use the [`query.enabled`](https://wagmi.sh/vue/api/composables/useReadContract#enabled) option to prevent the query from running until the dependency is ready.

tsx

    const { data: balance } = useReadContract({
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: [address],
      query: {
        enabled: !!address,
      },
    })

Loading & Error States [‚Äã](#loading-error-states)
-------------------------------------------------

The [`useReadContract` Composable](https://wagmi.sh/vue/api/composables/useReadContract) also returns loading & error states, which can be used to display a loading indicator while the data is being fetched, or an error message if contract execution reverts.

ReadContract.vue

vue

    <script setup lang="ts">
    import { useReadContract } from 'wagmi'
    
    const { 
      data: balance,
      error,
      isPending
    } = useReadContract({
      ...wagmiContractConfig,
      functionName: 'balanceOf',
      args: ['0x03A71968491d55603FFe1b11A9e23eF013f75bCF'],
    })
    </script>
    
    <template>
      <div v-if="isPending">Loading...</div>
    
      <div v-else-if="error">
        Error: {{ (error as BaseError).shortMessage || error.message }}
      </div>
    
      <div v-else>Balance: {{ balance?.toString() }}</div>
    </template></content>
</page>

<page>
  <title>sourcify | Wagmi</title>
  <url>https://wagmi.sh/cli/api/plugins/sourcify</url>
  <content>Plugin for fetching ABIs from [Sourcify](https://sourcify.dev/). Sourcify is a decentralized, open-source, smart contract verification and metadata repository.

Import [‚Äã](#import)
-------------------

ts

    import { sourcify } from '@wagmi/cli/plugins'

Usage [‚Äã](#usage)
-----------------

ts

    import { defineConfig } from '@wagmi/cli'
    import { sourcify } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        sourcify({
          contracts: [
            {
              name: 'deposit',
              address: '0x00000000219ab540356cbb839cbe05303d7705fa',
            },
          ],
        }),
      ],
    })

Configuration [‚Äã](#configuration)
---------------------------------

ts

    import { type SourcifyConfig } from '@wagmi/cli/plugins'

### cacheDuration [‚Äã](#cacheduration)

`number | undefined`

*   Duration in milliseconds to cache ABIs.
*   Defaults to `1_800_000` (30 minutes).

ts

    import { defineConfig } from '@wagmi/cli'
    import { sourcify } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        sourcify({
          cacheDuration: 300_000, 
          chainId: 100,
          contracts: [
            {
              name: 'Deposit',
              address: '0x00000000219ab540356cbb839cbe05303d7705fa',
            },
          ],
        }),
      ],
    })

### chainId [‚Äã](#chainid)

`number`

Chain ID to use for fetching ABI. If `address` is an object, `chainId` is used to select the address. See [Sourcify docs](https://docs.sourcify.dev/docs/chains) for supported chains.

ts

    import { defineConfig } from '@wagmi/cli'
    import { sourcify } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        sourcify({
          chainId: 100, 
          contracts: [
            {
              name: 'Community',
              address: {
                100: '0xC4c622862a8F548997699bE24EA4bc504e5cA865',
                137: '0xC4c622862a8F548997699bE24EA4bc504e5cA865',
              },
            },
          ],
        }),
      ],
    })

### contracts [‚Äã](#contracts)

`{ name: string; address?: Address | Record<number, Address> | undefined }[]`

Contracts to fetch ABIs for.

ts

    import { defineConfig } from '@wagmi/cli'
    import { sourcify } from '@wagmi/cli/plugins'
    
    export default defineConfig({
      plugins: [
        sourcify({
          chainId: 100,
          contracts: [ 
            { 
              name: 'Deposit', 
              address: '0x00000000219ab540356cbb839cbe05303d7705fa', 
            }, 
          ], 
        }),
      ],
    })</content>
</page>

<page>
  <title>FAQ / Troubleshooting | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/faq</url>
  <content>Collection of frequently asked questions with ideas on how to troubleshoot and resolve them.

Type inference doesn't work [‚Äã](#type-inference-doesn-t-work)
-------------------------------------------------------------

*   Check that you set up TypeScript correctly with `"strict": true` in your `tsconfig.json` ([TypeScript docs](https://wagmi.sh/vue/typescript#requirements))
*   Check that you [const-asserted any ABIs or Typed Data](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) you are using.
*   Restart your language server or IDE, and check for type errors in your code.

My wallet doesn't work [‚Äã](#my-wallet-doesn-t-work)
---------------------------------------------------

If you run into issues with a specific wallet, try another before opening up an issue. There are many different wallets and it's likely that the issue is with the wallet itself, not Wagmi. For example, if you are using Wallet X and sending a transaction doesn't work, try Wallet Y and see if it works.

`BigInt` Serialization [‚Äã](#bigint-serialization)
-------------------------------------------------

Using native `BigInt` with `JSON.stringify` will raise a `TypeError` as [`BigInt` values are not serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json). There are two techniques to mitigate this:

#### Lossless serialization [‚Äã](#lossless-serialization)

Lossless serialization means that `BigInt` will be converted to a format that can be deserialized later (e.g. `69420n` ‚Üí `"#bigint.69420"`). The trade-off is that these values are not human-readable and are not intended to be displayed to the user.

Lossless serialization can be achieved with wagmi's [`serialize`](https://wagmi.sh/vue/api/utilities/serialize) and [`deserialize`](https://wagmi.sh/vue/api/utilities/deserialize) utilities.

tsx

    import { serialize, deserialize } from 'wagmi'
    
    const serialized = serialize({ value: 69420n })
    // '{"value":"#bigint.69420"}'
    
    const deserialized = deserialize(serialized)
    // { value: 69420n }

#### Lossy serialization [‚Äã](#lossy-serialization)

Lossy serialization means that the `BigInt` will be converted to a normal display string (e.g. `69420n` ‚Üí `'69420'`). The trade-off is that you will not be able to deserialize the `BigInt` with `JSON.parse` as it can not distinguish between a normal string and a `BigInt`.

This method can be achieved by modifying `JSON.stringify` to include a BigInt `replacer`:

tsx

    const replacer = (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    
    JSON.stringify({ value: 69420n }, replacer)
    // '{"value":"69420"}'

How do I support the project? [‚Äã](#how-do-i-support-the-project)
----------------------------------------------------------------

Wagmi is an open source software project and free to use. If you enjoy using Wagmi or would like to support Wagmi development, you can:

*   [Become a sponsor on GitHub](https://github.com/sponsors/wevm)
*   Send us crypto
    *   Mainnet: 0x4557B18E779944BFE9d78A672452331C186a9f48
    *   Multichain: 0xd2135CfB216b74109775236E36d4b433F1DF507B
*   [Become a supporter on Drips](https://www.drips.network/app/projects/github/wevm/wagmi)

If you use Wagmi at work, consider asking your company to sponsor Wagmi. This may not be easy, but **business sponsorships typically make a much larger impact on the sustainability of OSS projects** than individual donations, so you will help us much more if you succeed.

Is Wagmi production ready? [‚Äã](#is-wagmi-production-ready)
----------------------------------------------------------

Yes. Wagmi is very stable and is used in production by thousands of organizations, like [Stripe](https://stripe.com/), [Shopify](https://shopify.com/), [Coinbase](https://coinbase.com/), [Uniswap](https://uniswap.org/), [ENS](https://ens.domains/), [Optimism](https://optimism.com/).

Is Wagmi strict with semver? [‚Äã](#is-wagmi-strict-with-semver)
--------------------------------------------------------------

Yes, Wagmi is very strict with [semantic versioning](https://semver.org/) and we will never introduce breaking changes to the runtime API in a minor version bump.

For exported types, we try our best to not introduce breaking changes in non-major versions, however, [TypeScript doesn't follow semver](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning) and often introduces breaking changes in minor releases that can cause Wagmi type issues. See the [TypeScript docs](https://wagmi.sh/vue/typescript#requirements) for more information.

How can I contribute to Wagmi? [‚Äã](#how-can-i-contribute-to-wagmi)
------------------------------------------------------------------

The Wagmi team accepts all sorts of contributions. Check out the [Contributing](https://wagmi.sh/dev/contributing) guide to get started. If you are interested in adding a new connector to Wagmi, check out the [Creating Connectors](https://wagmi.sh/dev/creating-connectors) guide.

Anything else you want to know? [‚Äã](#anything-else-you-want-to-know)
--------------------------------------------------------------------

Please create a new [GitHub Discussion thread](https://github.com/wevm/wagmi). You're also free to suggest changes to this or any other page on the site using the "Suggest changes to this page" button at the bottom of the page.</content>
</page>

<page>
  <title>Connectors | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors</url>
  <content>Released under the [MIT License](https://github.com/wevm/wagmi/blob/main/LICENSE).

Copyright ¬© 2022-present Weth, LLC</content>
</page>

<page>
  <title>createStorage | Wagmi</title>
  <url>https://wagmi.sh/vue/api/createStorage</url>
  <content>Creates new [`Storage`](#storage) object.

Import [‚Äã](#import)
-------------------

ts

    import { createStorage } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { createStorage } from '@wagmi/vue'
    
    const storage = createStorage({ storage: localStorage })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateStorageParameters } from '@wagmi/vue'

### deserialize [‚Äã](#deserialize)

`(<T>(value: string) => T) | undefined`

*   Function to deserialize data from storage.
*   Defaults to [`deserialize`](https://wagmi.sh/vue/api/utilities/deserialize).

ts

    import { createStorage, deserialize } from '@wagmi/vue'
    
    const storage = createStorage({
      deserialize, 
      storage: localStorage,
    })

WARNING

If you use a custom `deserialize` function, make sure it can handle `bigint` and `Map` values.

### key [‚Äã](#key)

`string | undefined`

*   Key prefix to use when persisting data.
*   Defaults to `'wagmi'`.

ts

    import { createStorage } from '@wagmi/vue'
    
    const storage = createStorage({
      key: 'my-app', 
      storage: localStorage,
    })

### serialize [‚Äã](#serialize)

`(<T>(value: T) => string) | undefined`

*   Function to serialize data for storage.
*   Defaults to [`serialize`](https://wagmi.sh/vue/api/utilities/serialize).

ts

    import { createStorage, serialize } from '@wagmi/vue'
    
    const storage = createStorage({
      serialize, 
      storage: localStorage,
    })

WARNING

If you use a custom `serialize` function, make sure it can handle `bigint` and `Map` values.

### storage [‚Äã](#storage)

`{ getItem(key: string): string | null | undefined | Promise<string | null | undefined>; setItem(key: string, value: string): void | Promise<void>; removeItem(key: string): void | Promise<void>; }`

*   Storage interface to use for persisting data.
*   Defaults to `localStorage`.
*   Supports synchronous and asynchronous storage methods.

ts

    import { createStorage } from '@wagmi/vue'
    // Using IndexedDB via https://github.com/jakearchibald/idb-keyval
    import { del, get, set } from 'idb-keyval'
    
    const storage = createStorage({
      storage: { 
        async getItem(name) { 
          return get(name)
        }, 
        async setItem(name, value) { 
          await set(name, value) 
        }, 
        async removeItem(name) { 
          await del(name) 
        }, 
      }, 
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type Storage } from '@wagmi/vue'

Storage [‚Äã](#storage-1)
-----------------------

Object responsible for persisting Wagmi [`State`](https://wagmi.sh/vue/api/createConfig#state-1) and other data.

ts

    import { type Storage } from '@wagmi/vue'

### getItem [‚Äã](#getitem)

`getItem(key: string, defaultValue?: value | null | undefined): value | null | Promise<value | null>`

ts

    import { createStorage } from '@wagmi/vue'
    
    const storage = createStorage({ storage: localStorage })
    const recentConnectorId = storage.getItem('recentConnectorId')

### setItem [‚Äã](#setitem)

`setItem(key: string, value: any): void | Promise<void>`

ts

    import { createStorage } from '@wagmi/vue'
    
    const storage = createStorage({ storage: localStorage })
    storage.setItem('recentConnectorId', 'foo')

### removeItem [‚Äã](#removeitem)

`removeItem(key: string): void | Promise<void>`

ts

    import { createStorage } from '@wagmi/vue'
    
    const storage = createStorage({ storage: localStorage })
    storage.removeItem('recentConnectorId')</content>
</page>

<page>
  <title>createConfig | Wagmi</title>
  <url>https://wagmi.sh/vue/api/createConfig</url>
  <content>Creates new [`Config`](#config) object.

Import [‚Äã](#import)
-------------------

ts

    import { createConfig } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

Integrating a Viem Client

Instead of using [`transports`](#transports), it's possible to provide a function that returns a Viem [`Client`](https://viem.sh/docs/clients/custom.html) via the [`client`](#client) property for more fine-grained control over Wagmi's internal `Client` creation.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { createClient } from 'viem'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      client({ chain }) {
        return createClient({ chain, transport: http() })
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CreateConfigParameters } from '@wagmi/vue'

### chains [‚Äã](#chains)

`readonly [Chain, ...Chain[]]`

*   Chains used by the `Config`.
*   See [Chains](https://wagmi.sh/vue/api/chains) for more details about built-in chains and the `Chain` type.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia], 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### connectors [‚Äã](#connectors)

`CreateConnectorFn[] | undefined`

[Connectors](https://wagmi.sh/vue/api/connectors) used by the `Config`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { injected } from '@wagmi/vue/connectors'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()], 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### multiInjectedProviderDiscovery [‚Äã](#multiinjectedproviderdiscovery)

`boolean | undefined`

*   Enables discovery of injected providers via [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) using the [`mipd`](https://github.com/wevm/mipd) library and converting to [injected](https://wagmi.sh/vue/api/connectors/injected) connectors.
*   Defaults to `true`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      multiInjectedProviderDiscovery: false, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### ssr [‚Äã](#ssr)

`boolean | undefined`

Flag to indicate if the config is being used in a server-side rendering environment. Defaults to `false`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      ssr: true, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### storage [‚Äã](#storage)

`Storage | null | undefined`

*   [`Storage`](https://wagmi.sh/vue/api/createStorage#storage) used by the config. Persists `Config`'s [`State`](#state-1) between sessions.
*   Defaults to `createStorage({ storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage })`.

ts

    import { createConfig, createStorage, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      storage: createStorage({ storage: window.localStorage }), 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Keep the [`State['chainId']`](#chainid) in sync with the current connection.
*   Defaults to `true`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      syncConnectedChain: false, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

* * *

### batch [‚Äã](#batch)

`{ multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | { [_ in chains[number]["id"]]?: { multicall?: boolean | { batchSize?: number | undefined; wait?: number | undefined } | undefined } | undefined } | undefined`

*   Batch settings. See [Viem docs](https://viem.sh/docs/clients/custom.html#batch-optional) for more info.
*   Defaults to `{ multicall: true }`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      batch: { multicall: true }, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### cacheTime [‚Äã](#cachetime)

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

*   Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/public.html#cachetime-optional) for more info.
*   Defaults to [`pollingInterval`](#pollinginterval) or `4_000`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      cacheTime: 4_000, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### pollingInterval [‚Äã](#pollinginterval)

`number | { [_ in chains[number]['id']]?: number | undefined } | undefined`

*   Frequency in milliseconds for polling enabled features. See [Viem docs](https://viem.sh/docs/clients/custom.html#pollinginterval-optional) for more info.
*   Defaults to `4_000`.

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      pollingInterval: 4_000, 
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### transports [‚Äã](#transports)

`Record<chains[number]['id'], Transport>`

Mapping of [chain IDs](#chains) to [`Transport`](https://wagmi.sh/vue/api/transports)s. This mapping is used internally when creating chain-aware Viem [`Client`](https://viem.sh/docs/clients/custom.html) objects. See the [Transport docs](https://wagmi.sh/vue/api/transports) for more info.

ts

    import { createConfig, fallback, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      transports: { 
        [mainnet.id]: fallback([ 
          http('https://...'), 
          http('https://...'), 
        ]), 
        [sepolia.id]: http('https://...'), 
      }, 
    })

* * *

### client [‚Äã](#client)

`(parameters: { chain: chains[number] }) => Client<Transport, chains[number]>`

Function for creating new Viem [`Client`](https://viem.sh/docs/clients/custom.html) to be used internally. Exposes more control over the internal `Client` creation logic versus using the [`transports`](#transports) property.

ts

    import { createClient, http } from 'viem'
    import { createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    const config = createConfig({
      chains: [mainnet, sepolia],
      client({ chain }) { 
        return createClient({ chain, transport: http('https://...') }) 
      }, 
    })

WARNING

When using this option, you likely want to pass `parameters.chain` straight through to [`createClient`](https://viem.sh/docs/clients/custom.html#createclient) to ensure the Viem `Client` is in sync with any active connections.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type Config } from '@wagmi/vue'

Config [‚Äã](#config)
-------------------

Object responsible for managing Wagmi state and internals.

ts

    import { type Config } from '@wagmi/vue'

### chains [‚Äã](#chains-1)

`readonly [Chain, ...Chain[]]`

[`chains`](#chains) passed to `createConfig`.

### connectors [‚Äã](#connectors-1)

`readonly Connector[]`

Connectors set up from passing [`connectors`](#connectors) and [`multiInjectedProviderDiscovery`](#multiinjectedproviderdiscovery) to `createConfig`.

### state [‚Äã](#state)

`State<chains>`

The `Config` object's internal state. See [`State`](#state-1) for more info.

### storage [‚Äã](#storage-1)

`Storage | null`

[`storage`](#storage) passed to `createConfig`.

### getClient [‚Äã](#getclient)

`(parameters?: { chainId?: chainId | chains[number]['id'] | undefined }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>`

Creates new Viem [`Client`](https://viem.sh/docs/clients/custom.html) object.

index.tsconfig.ts

ts

    import { config } from './config'
    
    const client = config.getClient({ chainId: 1 })

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

### setState [‚Äã](#setstate)

`(value: State<chains> | ((state: State<chains>) => State<chains>)) => void`

Updates the `Config` object's internal state. See [`State`](#state-1) for more info.

index.tsconfig.ts

ts

    import { mainnet } from '@wagmi/vue/chains'
    import { config } from './config'
    
    config.setState((x) => ({
      ...x,
      chainId: x.current ? x.chainId : mainnet.id,
    }))

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

WARNING

Exercise caution when using this method. It is intended for internal and advanced use-cases only. Manually setting state can cause unexpected behavior.

### subscribe [‚Äã](#subscribe)

`(selector: (state: State<chains>) => state, listener: (selectedState: state, previousSelectedState: state) => void, options?: { emitImmediately?: boolean | undefined; equalityFn?: ((a: state, b: state) => boolean) | undefined } | undefined) => (() => void)`

Listens for state changes matching the `selector` function. Returns a function that can be called to unsubscribe the listener.

index.tsconfig.ts

ts

    import { config } from './config'
    
    const unsubscribe = config.subscribe(
      (state) => state.chainId,
      (chainId) => console.log(`Chain ID changed to ${chainId}`),
    )
    unsubscribe()

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http('https://mainnet.example.com'),
        [sepolia.id]: http('https://sepolia.example.com'),
      },
    })

State [‚Äã](#state-1)
-------------------

ts

    import { type State } from '@wagmi/vue'

### chainId [‚Äã](#chainid)

`chains[number]['id']`

Current chain ID. When `syncConnectedChain` is `true`, `chainId` is kept in sync with the current connection. Defaults to first chain in [`chains`](#chains).

### connections [‚Äã](#connections)

`Map<string, Connection>`

Mapping of unique connector identifier to [`Connection`](#connection) object.

### current [‚Äã](#current)

`string | undefined`

Unique identifier of the current connection.

### status [‚Äã](#status)

`'connected' | 'connecting' | 'disconnected' | 'reconnecting'`

Current connection status.

*   `'connecting'` attempting to establish connection.
*   `'reconnecting'` attempting to re-establish connection to one or more connectors.
*   `'connected'` at least one connector is connected.
*   `'disconnected'` no connection to any connector.

Connection [‚Äã](#connection)
---------------------------

ts

    import { type Connection } from '@wagmi/vue'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Array of addresses associated with the connection.

### chainId [‚Äã](#chainid-1)

`number`

Chain ID associated with the connection.

### connector [‚Äã](#connector)

`Connector`

Connector associated with the connection.</content>
</page>

<page>
  <title>Chains | Wagmi</title>
  <url>https://wagmi.sh/vue/api/chains</url>
  <content>Viem `Chain` objects. More info at the [Viem docs](https://viem.sh/docs/chains/introduction).

Import [‚Äã](#import)
-------------------

Import via the `'@wagmi/vue/chains'` entrypoint (proxies all chains from `'viem/chains'`).

ts

    import { mainnet } from '@wagmi/vue/chains'

Available Chains [‚Äã](#available-chains)
---------------------------------------

Chain definitions as of `viem@2.23.12`. For `viem@latest`, visit the [Viem repo](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

266 Chains

OP Mainnet

`optimism`

10 - ETH

Flare Mainnet

`flare`

14 - FLR

Coston

`songbirdTestnet`

16 - CFLR

Songbird Mainnet

`songbird`

19 - SGB

Cronos Mainnet

`cronos`

25 - CRO

Rootstock Mainnet

`rootstock`

30 - RBTC

Rootstock Testnet

`rootstockTestnet`

31 - tRBTC

Telos

`telosTestnet`

41 - TLOS

Darwinia Network

`darwinia`

46 - RING

XinFin Network

`xdc`

50 - XDC

Apothem Network

`xdcTestnet`

51 - TXDC

BNB Smart Chain

`bsc`

56 - BNB

Syscoin Mainnet

`syscoin`

57 - SYS

Ethereum Classic

`classic`

61 - ETC

Conflux eSpace Testnet

`confluxESpaceTestnet`

71 - CFX

Meter Testnet

`meterTestnet`

83 - MTR

Binance Smart Chain Testnet

`bscTestnet`

97 - tBNB

Shibarium

`shibarium`

109 - BONE

Coston2

`flareTestnet`

114 - C2FLR

Fuse Sparknet

`fuseSparknet`

123 - SPARK

Polygon

`polygon`

137 - MATIC

Manta Pacific Mainnet

`manta`

169 - ETH

X1 Testnet

`x1Testnet`

195 - OKB

X1 Testnet

`xLayerTestnet`

195 - OKB

X Layer Mainnet

`xLayer`

196 - OKB

BitTorrent

`bitTorrent`

199 - BTT

Edgeless Testnet

`edgelessTestnet`

202 - EwETH

Nexilix Smart Chain

`nexilix`

240 - NEXILIX

Fraxtal

`fraxtal`

252 - frxETH

zkSync InMemory Node

`zkSyncInMemoryNode`

260 - ETH

zkSync CLI Local Node

`zkSyncLocalNode`

270 - ETH

zkSync Era Testnet

`zkSyncTestnet`

280 - ETH

Boba Network

`boba`

288 - ETH

Hedera Mainnet

`hedera`

295 - HBAR

Hedera Testnet

`hederaTestnet`

296 - HBAR

Hedera Previewnet

`hederaPreviewnet`

297 - HBAR

zkSync Sepolia Testnet

`zkSyncSepoliaTestnet`

300 - ETH

Filecoin Mainnet

`filecoin`

314 - FIL

zkSync Era

`zkSync`

324 - ETH

Cronos Testnet

`cronosTestnet`

338 - tCRO

PulseChain

`pulsechain`

369 - PLS

Optimism Goerli

`optimismGoerli`

420 - ETH

Areon Network Testnet

`areonNetworkTestnet`

462 - TAREA

Areon Network

`areonNetwork`

463 - AREA

FlowEVM Testnet

`flowTestnet`

545 - FLOW

Rollux Mainnet

`rollux`

570 - SYS

MetaChain Mainnet

`metachain`

571 - MTC

Mandala TC9

`mandala`

595 - mACA

Metis Goerli

`metisGoerli`

599 - METIS

FlowEVM Previewnet

`flowPreviewnet`

646 - FLOW

FlowEVM Mainnet

`flowMainnet`

747 - FLOW

Taraxa Mainnet

`taraxa`

841 - TARA

Taraxa Testnet

`taraxaTestnet`

842 - TARA

Wanchain

`wanchain`

888 - WAN

Mode Testnet

`modeTestnet`

919 - ETH

PulseChain V4

`pulsechainV4`

943 - v4PLS

5ireChain Thunder Testnet

`thunderTestnet`

997 - 5IRE

Wanchain Testnet

`wanchainTestnet`

999 - WANt

Zora Goerli Testnet

`zoraTestnet`

999 - ETH

Klaytn Baobab Testnet

`klaytnBaobab`

1001 - KLAY

Ekta Testnet

`ektaTestnet`

1004 - EKTA

BNB Greenfield Chain

`bscGreenfield`

1017 - BNB

BitTorrent Chain Testnet

`bitTorrentTestnet`

1028 - BTT

Conflux eSpace

`confluxESpace`

1030 - CFX

Bronos Testnet

`bronosTestnet`

1038 - tBRO

Shimmer Testnet

`shimmerTestnet`

1073 - SMR

Polygon zkEVM

`polygonZkEvm`

1101 - ETH

WEMIX Testnet

`wemixTestnet`

1112 - tWEMIX

Core Dao

`coreDao`

1116 - CORE

DeFiChain EVM Mainnet

`defichainEvm`

1130 - DFI

DeFiChain EVM Testnet

`defichainEvmTestnet`

1131 - DFI

Moonbeam Development Node

`moonbeamDev`

1281 - DEV

Moonbeam

`moonbeam`

1284 - GLMR

Moonriver

`moonriver`

1285 - MOVR

Moonbase Alpha

`moonbaseAlpha`

1287 - DEV

Localhost

`localhost`

1337 - ETH

Polygon zkEVM Testnet

`polygonZkEvmTestnet`

1442 - ETH

MetaChain Istanbul

`metachainIstanbul`

1453 - MTC

Horizen Gobi Testnet

`gobi`

1663 - tZEN

Mint Sepolia Testnet

`mintSepoliaTestnet`

1686 - ETH

Reya Network

`reyaNetwork`

1729 - ETH

LightLink Phoenix Mainnet

`lightlinkPhoenix`

1890 - ETH

LightLink Pegasus Testnet

`lightlinkPegasus`

1891 - ETH

Dogechain

`dogechain`

2000 - DC

Telcoin Adiri Testnet

`telcoinTestnet`

2017 - TEL

Edgeware EdgeEVM Mainnet

`edgeware`

2021 - EDG

Saigon Testnet

`saigon`

2021 - RON

Beresheet BereEVM Testnet

`edgewareTestnet`

2022 - tEDG

Edgeless Network

`edgeless`

2026 - EwETH

Kava EVM Testnet

`kavaTestnet`

2221 - KAVA

RSS3 VSL Sepolia Testnet

`rss3Sepolia`

2331 - RSS3

Kroma Sepolia

`kromaSepolia`

2358 - ETH

Polygon zkEVM Cardona

`polygonZkEvmCardona`

2442 - ETH

Fraxtal Testnet

`fraxtalTestnet`

2522 - frxETH

inEVM Mainnet

`inEVM`

2525 - INJ

Morph Sepolia

`morphSepolia`

2710 - ETH

Filecoin Hyperspace

`filecoinHyperspace`

3141 - tFIL

Crossbell

`crossbell`

3737 - CSB

Astar zkEVM

`astarZkEVM`

3776 - ETH

APEX Testnet

`apexTestnet`

3993 - ETH

Fantom Testnet

`fantomTestnet`

4002 - FTM

Oasis Testnet

`oasisTestnet`

4090 - FTN

LUKSO Testnet

`luksoTestnet`

4201 - LYXt

Lisk Sepolia

`liskSepolia`

4202 - ETH

IoTeX Testnet

`iotexTestnet`

4690 - IOTX

MEVerse Chain Testnet

`mevTestnet`

4759 - MEV

BlackFort Exchange Network Testnet

`bxnTestnet`

4777 - TBXN

BlackFort Exchange Network

`bxn`

4999 - BXN

Mantle Testnet

`mantleTestnet`

5001 - MNT

Mantle Sepolia Testnet

`mantleSepoliaTestnet`

5003 - MNT

opBNB Testnet

`opBNBTestnet`

5611 - tBNB

Syscoin Tanenbaum Testnet

`syscoinTestnet`

5700 - SYS

ZetaChain

`zetachain`

7000 - ZETA

ZetaChain Athens Testnet

`zetachainAthensTestnet`

7001 - aZETA

MEVerse Chain Mainnet

`mev`

7518 - MEV

Shardeum Sphinx

`shardeumSphinx`

8082 - SHM

Evmos Testnet

`evmosTestnet`

9000 - EVMOS

OORT MainnetDev

`oortMainnetDev`

9700 - OORT

Gnosis Chiado

`gnosisChiado`

10200 - xDAI

HAQQ Mainnet

`haqqMainnet`

11235 - ISLM

BEVM Mainnet

`bevmMainnet`

11501 - BTC

Fibo Chain

`fibo`

12306 - FIBO

RSS3 VSL Mainnet

`rss3`

12553 - RSS3

Beam Testnet

`beamTestnet`

13337 - BEAM

Immutable zkEVM

`immutableZkEvm`

13371 - IMX

Phoenix Blockchain

`phoenix`

13381 - PHX

Immutable zkEVM Testnet

`immutableZkEvmTestnet`

13473 - IMX

EOS EVM Testnet

`eosTestnet`

15557 - EOS

Holesky

`holesky`

17000 - ETH

Oasis Sapphire

`sapphire`

23294 - ROSE

Oasis Sapphire Testnet

`sapphireTestnet`

23295 - TEST

DreyerX Mainnet

`dreyerxMainnet`

23451 - DRX

Foundry

`foundry`

31337 - ETH

Hardhat

`hardhat`

31337 - ETH

Zilliqa

`zilliqa`

32769 - ZIL

Zilliqa Testnet

`zilliqaTestnet`

33101 - ZIL

Mode Mainnet

`mode`

34443 - ETH

Q Mainnet

`qMainnet`

35441 - Q

Q Testnet

`qTestnet`

35443 - Q

Arbitrum One

`arbitrum`

42161 - ETH

Arbitrum Nova

`arbitrumNova`

42170 - ETH

ZKFair Mainnet

`zkFair`

42766 - USDC

Avalanche Fuji

`avalancheFuji`

43113 - AVAX

Avalanche

`avalanche`

43114 - AVAX

ZKFair Testnet

`zkFairTestnet`

43851 - USDC

Alfajores

`celoAlfajores`

44787 - A-CELO

Yooldo Verse

`yooldoVerse`

50005 - OAS

Yooldo Verse Testnet

`yooldoVerseTestnet`

50006 - OAS

DODOchain Testnet

`dodochainTestnet`

53457 - DODO

DFK Chain

`dfk`

53935 - JEWEL

HAQQ Testedge 2

`haqqTestedge2`

54211 - ISLMT

Rollux Testnet

`rolluxTestnet`

57000 - SYS

PGN

`pgnTestnet`

58008 - ETH

Linea Goerli Testnet

`lineaGoerli`

59140 - ETH

Linea Goerli Testnet

`lineaTestnet`

59140 - ETH

Linea Sepolia Testnet

`lineaSepolia`

59141 - ETH

Linea Mainnet

`linea`

59144 - ETH

Fantom Sonic Open Testnet

`fantomSonicTestnet`

64240 - FTM

Polygon Mumbai

`polygonMumbai`

80001 - MATIC

Polygon Amoy

`polygonAmoy`

80002 - MATIC

Berachain Artio

`berachainTestnet`

80085 - BERA

Base Goerli

`baseGoerli`

84531 - ETH

Base Sepolia

`baseSepolia`

84532 - ETH

Chiliz Spicy Testnet

`spicy`

88882 - CHZ

Chiliz Chain

`chiliz`

88888 - CHZ

Jibchain Testnet

`jbcTestnet`

88991 - tJBC

Vechain

`vechain`

100009 - VET

Stratis Mainnet

`stratis`

105105 - STRAX

Etherlink Testnet

`etherlinkTestnet`

128123 - XTZ

Taiko (Alpha-3 Testnet)

`taikoTestnetSepolia`

167005 - ETH

Taiko Jolnir (Alpha-5 Testnet)

`taikoJolnir`

167007 - ETH

Taiko Katla (Alpha-6 Testnet)

`taikoKatla`

167008 - ETH

Taiko Hekla L2

`taikoHekla`

167009 - ETH

Bitlayer Testnet

`btrTestnet`

200810 - ETH

Auroria Testnet

`auroria`

205205 - tSTRAX

Filecoin Calibration

`filecoinCalibration`

314159 - tFIL

Arbitrum Goerli

`arbitrumGoerli`

421613 - ETH

Arbitrum Sepolia

`arbitrumSepolia`

421614 - ETH

Scroll Sepolia

`scrollSepolia`

534351 - ETH

Scroll Testnet

`scrollTestnet`

534353 - ETH

Bear Network Chain Mainnet

`bearNetworkChainMainnet`

641230 - BRNKC

Sei Devnet

`seiDevnet`

713715 - SEI

Bear Network Chain Testnet

`bearNetworkChainTestnet`

751230 - tBRNKC

Zhejiang

`zhejiang`

1337803 - ZhejETH

PlayFi Albireo Testnet

`playfiAlbireo`

1612127 - ETH

Manta Pacific Testnet

`mantaTestnet`

3441005 - ETH

Manta Pacific Sepolia Testnet

`mantaSepoliaTestnet`

3441006 - ETH

Astar zkEVM Testnet zKyoto

`astarZkyoto`

6038361 - ETH

Sepolia

`sepolia`

11155111 - ETH

OP Sepolia

`optimismSepolia`

11155420 - ETH

Ancient8 Testnet

`ancient8Sepolia`

28122024 - ETH

SKALE Nebula Testnet

`skaleNebulaTestnet`

37084624 - sFUEL

Otim Devnet

`otimDevnet`

41144114 - ETH

Cyber Testnet

`cyberTestnet`

111557560 - ETH

Plume Testnet

`plumeTestnet`

161221135 - ETH

Blast Sepolia

`blastSepolia`

168587773 - ETH

Neon EVM DevNet

`neonDevnet`

245022926 - NEON

Neon EVM MainNet

`neonMainnet`

245022934 - NEON

SKALE | Razor Network

`skaleRazor`

278611351 - sFUEL

SKALE | Block Brawlers

`skaleBlockBrawlers`

391845894 - BRAWL

Degen

`degen`

666666666 - DEGEN

Ancient8

`ancient8`

888888888 - ETH

SKALE Calypso Testnet

`skaleCalypsoTestnet`

974399131 - sFUEL

Zora Sepolia

`zoraSepolia`

999999999 - ETH

SKALE Titan Hub

`skaleTitanTestnet`

1020352220 - sFUEL

SKALE | CryptoBlades

`skaleCryptoBlades`

1026062157 - sFUEL

SKALE | Crypto Colosseum

`skaleCryptoColosseum`

1032942172 - sFUEL

SKALE | Human Protocol

`skaleHumanProtocol`

1273227453 - sFUEL

Aurora

`aurora`

1313161554 - ETH

Aurora Testnet

`auroraTestnet`

1313161555 - ETH

SKALE | Titan Community Hub

`skaleTitan`

1350216234 - sFUEL

SKALE Europa Testnet

`skaleEuropaTestnet`

1444673419 - sFUEL

SKALE | Nebula Gaming Hub

`skaleNebula`

1482601649 - sFUEL

SKALE | Calypso NFT Hub

`skaleCalypso`

1564830818 - sFUEL

Harmony One

`harmonyOne`

1666600000 - ONE

SKALE | Europa Liquidity Hub

`skaleEuropa`

2046399126 - sFUEL

SKALE | Exorde

`skaleExorde`

2139927552 - sFUEL

Palm Testnet

`palmTestnet`

11297108099 - PALM

Palm

`palm`

11297108109 - PALM

Kakarot Sepolia

`kakarotSepolia`

107107114116 - ETH

Create Chain [‚Äã](#create-chain)
-------------------------------

Import the `Chain` type from Viem and create a new object that is asserted `as const` and `satisfies` the type. You can also use the `defineChain` function from Viem.

as const satisfies ChaindefineChain

ts

    import { type  } from 'viem'
    
    export const  = {} as  satisfies Type '{}' does not satisfy the expected type 'Chain'.
      Type '{}' is missing the following properties from type 'Chain': id, name, nativeCurrency, rpcUrls

ts

    import {  } from 'viem'
    
    export const  = ({})Argument of type '{}' is not assignable to parameter of type 'Chain<ChainFormatters>'.
      Type '{}' is missing the following properties from type 'Chain<ChainFormatters>': id, name, nativeCurrency, rpcUrls

Now, add the missing required properties to the object until the error goes away.

as const satisfies ChaindefineChain

ts

    import { type  } from 'viem'
    
    export const  = {
      : 1,
      : 'Ethereum',
      : { : 'Ether', : 'ETH', : 18 },
      : {
        : { : ['https://eth.merkle.io'] },
      },
      : {
        : { : 'Etherscan', : 'https://etherscan.io' },
      },
      : {
        : {
          : '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        : {
          : '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
          : 16773775,
        },
        : {
          : '0xca11bde05977b3631167028862be2a173976ca11',
          : 14353601,
        },
      },
    } as  satisfies 

ts

    import {  } from 'viem'
    
    export const  = ({
      : 1,
      : 'Ethereum',
      : { : 'Ether', : 'ETH', : 18 },
      : {
        : { : ['https://eth.merkle.io'] },
      },
      : {
        : { : 'Etherscan', : 'https://etherscan.io' },
      },
      : {
        : {
          : '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        : {
          : '0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da',
          : 16773775,
        },
        : {
          : '0xca11bde05977b3631167028862be2a173976ca11',
          : 14353601,
        },
      },
    })

The more properties you add, the better the chain will be to use with Wagmi. Most of these attributes exist within the [`ethereum-lists/chains` repository](https://github.com/ethereum-lists/chains/tree/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains).

*   `id`: The chain ID for the network. This can be found by typing the network name into [ChainList](https://chainlist.org/). Example: "Ethereum Mainnet" has a Chain ID of `1`.
*   `name`: Human-readable name for the chain. Example: "Ethereum Mainnet"
*   `nativeCurrency`: The native currency of the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L20-L24).
*   `rpcUrls`: At least one public, credible RPC URL. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L4-L18).
*   `blockExplorers`: A set of block explorers for the chain. Found from [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains/blob/3fbd4eeac7ce116579634bd042b84e2b1d89886a/_data/chains/eip155-56.json#L30-L36).
*   `contracts`: A set of deployed contracts for the chain. If you are deploying one of the following contracts yourself, make sure it is verified.
    *   `multicall3` is optional, but it's address is most likely `0xca11bde05977b3631167028862be2a173976ca11` ‚Äì you can find the deployed block number on the block explorer. Check out [`mds1/multicall`](https://github.com/mds1/multicall#multicall3-contract-addresses) for more info.
    *   `ensRegistry` is optional ‚Äì not all Chains have a ENS Registry. See [ENS Deployments](https://docs.ens.domains/ens-deployments) for more info.
    *   `ensUniversalResolver` is optional ‚Äì not all Chains have a ENS Universal Resolver.
*   `sourceId`: Source Chain ID (e.g. the L1 chain).
*   `testnet`: Whether or not the chain is a testnet.</content>
</page>

<page>
  <title>metaMask | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors/metaMask</url>
  <content>Connector for [MetaMask SDK](https://github.com/MetaMask/metamask-sdk).

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/metamask-sdk/javascript) for more information.

Import [‚Äã](#import)
-------------------

ts

    import { metaMask } from '@wagmi/vue/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { metaMask } from '@wagmi/vue/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [metaMask()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MetaMaskParameters } from '@wagmi/vue/connectors'

Check out the [MetaMask SDK docs](https://docs.metamask.io/wallet/connect/3rd-party-libraries/wagmi/) for more info. A few options are omitted that Wagmi manages internally.

### dappMetadata [‚Äã](#dappmetadata)

`DappMetadata | undefined`

Metadata is used to fill details for the UX on confirmation screens in MetaMask, including the following fields:

*   `name`: `string` - The name of the dapp.
*   `url`: `string` - URL of the dapp (defaults to `window.location.origin`).
*   `iconUrl`: `string` - URL to the dapp's favicon or icon.

ts

    import { metaMask } from '@wagmi/vue/connectors'
    
    const connector = metaMask({
      dappMetadata: { 
        name: 'My Wagmi App', 
        url: 'https://example.com', 
        iconUrl: 'https://example.com/favicon.ico', 
      }
    })

### logging [‚Äã](#logging)

`SDKLoggingOptions | undefined`

Enables SDK-side logging to provide visibility into:

*   RPC methods being called.
*   Events received for syncing the chain or active account.
*   Raw RPC responses.

In this context, this is especially useful to observe what calls are made through Wagmi hooks.

Relevant options:

ts

    {
      developerMode: boolean, // Enables developer mode logs
      sdk: boolean           // Enables SDK-specific logs
    }

ts

    import { metaMask } from '{{connectorsPackageName}}'
    
    const connector = metaMask({
      logging: { developerMode: true, sdk: true } 
    })

### headless [‚Äã](#headless)

`boolean | undefined`

*   Enables headless mode, disabling MetaMask's built-in modal.
*   Allows developers to create their own modal, such as for displaying a QR code.

This is particularly relevant for web-only setups using Wagmi, where developers want complete control over the UI.

To get the deeplink to display in the QR code, listen to the `display_uri` event.

The default is `false`.

ts

    import { metaMask } from '@wagmi/vue/connectors'
    
    const connector = metaMask({
      headless: true
    })

Advanced [‚Äã](#advanced)
-----------------------

By default, if the EIP-6963 MetaMask injected provider is detected, this connector will replace it.

EIP-6963 defines a standard way for dapps to interact with multiple wallets simultaneously by injecting providers into the browser. Wallets that implement this standard can make their presence known to dapps in a consistent and predictable manner.

When MetaMask SDK detects an EIP-6963-compliant provider (such as MetaMask itself), the connector will automatically replace the default injected provider (like `window.ethereum`) with the one provided by MetaMask SDK.

See the [`rdns` property](https://wagmi.sh/dev/creating-connectors#properties) for more information.</content>
</page>

<page>
  <title>injected | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors/injected</url>
  <content>Connector for [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Providers.

Import [‚Äã](#import)
-------------------

ts

    import { injected } from '@wagmi/vue/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { injected } from '@wagmi/vue/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type InjectedParameters } from '@wagmi/vue/connectors'

### shimDisconnect [‚Äã](#shimdisconnect)

`boolean | undefined`

*   MetaMask and other injected providers do not support programmatic disconnect.
*   This flag simulates the disconnect behavior by keeping track of connection status in storage. See [GitHub issue](https://github.com/MetaMask/metamask-extension/issues/10353) for more info.
*   Defaults to `true`.

ts

    import { injected } from '@wagmi/vue/connectors'
    
    const connector = injected({
      shimDisconnect: false, 
    })

### target [‚Äã](#target)

`TargetId | (TargetMap[TargetId] & { id: string }) | (() => (TargetMap[TargetId] & { id: string }) | undefined) | undefined`

*   [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target.
*   [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) supported via `createConfig`'s [`multiInjectedProviderDiscovery`](https://wagmi.sh/vue/api/createConfig#multiinjectedproviderdiscovery) property.

ts

    import { injected } from '@wagmi/vue/connectors'
    
    const connector = injected({
      target() { 
        return { 
          id: 'windowProvider', 
          name: 'Window Provider', 
          provider: window.ethereum, 
        } 
      }, 
    })

### unstable\_shimAsyncInject [‚Äã](#unstable-shimasyncinject)

`boolean | number | undefined`

Watches for async provider injection via the `ethereum#initialized` event. When `true`, defaults to `1_000` milliseconds. Otherwise, uses a provided value of milliseconds.

ts

    import { injected } from '@wagmi/vue/connectors'
    
    const connector = injected({
      unstable_shimAsyncInject: 2_000, 
    })</content>
</page>

<page>
  <title>coinbaseWallet | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors/coinbaseWallet</url>
  <content>Connector for the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk).

Import [‚Äã](#import)
-------------------

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [coinbaseWallet()], 
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Before going to production, it is highly recommended to set an [`appName`](#appname) and [`appLogoUrl`](#applogourl) for your application that can be displayed upon connection to the wallet.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type CoinbaseWalletParameters } from '@wagmi/vue/connectors'

Check out the [Coinbase Wallet SDK docs](https://github.com/coinbase/coinbase-wallet-sdk) for more info.

### appName [‚Äã](#appname)

`string`

Application name.

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App', 
    })

### appLogoUrl [‚Äã](#applogourl)

`string | null | undefined`

Application logo image URL; favicon is used if unspecified.

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      appLogoUrl: 'https://example.com/myLogoUrl.png', 
    })

### headlessMode deprecated [‚Äã](#headlessmode)

`boolean | undefined`

*   Whether or not onboarding overlay popup should be displayed.
*   `headlessMode` will be removed in the next major version. Upgrade to [`version: '4'`](#version).

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      headlessMode: false, 
    })

### preference \>=2.9.0 [‚Äã](#preference)

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

*   `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
*   `'smartWalletOnly'`: Displays Smart Wallet popup.
*   `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      preference: 'smartWalletOnly', 
    })

WARNING

Passing `preference` as a string is deprecated and will be removed in the next major version. Instead you should use [`preference#options`](#options).

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      preference: { 
        options: 'smartWalletOnly'
      }, 
    })

#### attribution \>=2.12.33 [‚Äã](#attribution)

``{ auto?: boolean | undefined; dataSuffix?: `0x${string}` | undefined }``

This option only applies to Coinbase Smart Wallet. When a valid data suffix is supplied, it is appended to the `initCode` and `executeBatch` calldata. Coinbase Smart Wallet expects a 16 byte hex string. If the data suffix is not a 16 byte hex string, the Smart Wallet will ignore the property. If auto is true, the Smart Wallet will generate a 16 byte hex string from the apps origin.

#### keysUrl \>=2.12.33 [‚Äã](#keysurl)

`string`

*   The URL for the keys popup.
*   By default, `https://keys.coinbase.com/connect` is used for production. Use `https://keys-dev.coinbase.com/connect` for development environments.

#### options \>=2.12.33 [‚Äã](#options)

`"all" | "eoaOnly" | "smartWalletOnly"`

Preference for the type of wallet to display.

*   `'eoaOnly'`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
*   `'smartWalletOnly'`: Displays Smart Wallet popup.
*   `'all'` (default): Supports both `'eoaOnly'` and `'smartWalletOnly'` based on context.

### version \>=2.13.0 [‚Äã](#version)

*   Coinbase Wallet SDK version
*   Defaults to `'4'`. If [`headlessMode: true`](#headlessmode), defaults to `'3'`.

ts

    import { coinbaseWallet } from '@wagmi/vue/connectors'
    
    const connector = coinbaseWallet({
      appName: 'My Wagmi App',
      version: '4', 
    })</content>
</page>

<page>
  <title>safe | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors/safe</url>
  <content>Connector for [Safe Apps SDK](https://github.com/safe-global/safe-apps-sdk).

Import [‚Äã](#import)
-------------------

ts

    import { safe } from '@wagmi/vue/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { safe } from '@wagmi/vue/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [safe()],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type SafeParameters } from '@wagmi/vue/connectors'

Check out the [Safe docs](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-sdk) for more info.

### allowedDomains [‚Äã](#alloweddomains)

`RegExp[] | undefined`

ts

    import { safe } from '@wagmi/vue/connectors'
    
    const connector = safe({
      allowedDomains: [/app.safe.global$/], 
    })

### debug [‚Äã](#debug)

`boolean | undefined`

ts

    import { safe } from '@wagmi/vue/connectors'
    
    const connector = safe({
      debug: true, 
    })

### shimDisconnect [‚Äã](#shimdisconnect)

`boolean | undefined`

*   This flag simulates disconnect behavior by keeping track of connection status in storage.
*   Defaults to `false`.

ts

    import { safe } from '@wagmi/vue/connectors'
    
    const connector = safe({
      shimDisconnect: true, 
    })</content>
</page>

<page>
  <title>mock | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors/mock</url>
  <content>Connector for mocking Wagmi functionality.

Import [‚Äã](#import)
-------------------

ts

    import { mock } from '@wagmi/vue/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { mock } from '@wagmi/vue/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [
        mock({
          accounts: [
            '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
            '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
            '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
          ],
        }),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type MockParameters } from '@wagmi/vue/connectors'

### accounts [‚Äã](#accounts)

`readonly [Address, ...Address[]]`

Accounts to use with the connector.

ts

    import { mock } from '@wagmi/vue/connectors'
    
    const connector = mock({
      accounts: [ 
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', 
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', 
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', 
        '0x90F79bf6EB2c4f870365E785982E1f101E93b906', 
        '0x15d34aaf54267db7d7c367839aaf71a00a2c6a65', 
        '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', 
        '0x976EA74026E726554dB657fA54763abd0C3a0aa9', 
        '0x14dC79964da2C08b23698B3D3cc7Ca32193d9955', 
        '0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f', 
        '0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', 
      ], 
    })

### features [‚Äã](#features)

`{ connectError?: boolean | Error | undefined; reconnect?: boolean | undefined; signMessageError?: boolean | Error | undefined; signTypedDataError?: boolean | Error | undefined; switchChainError?: boolean | Error | undefined; } | undefined`

Feature flags that change behavior of Wagmi internals.

ts

    import { mock } from '@wagmi/vue/connectors'
    import { UserRejectedRequestError } from 'viem'
    
    const connector = mock({
      accounts: [
        '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
        '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
        '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
      ],
      features: { 
        connectError: new UserRejectedRequestError(new Error('Failed to connect.')), 
        reconnect: false, 
      }, 
    })

#### defaultConnected [‚Äã](#defaultconnected)

`boolean | undefined`

Whether the connector is connected by default.

#### connectError [‚Äã](#connecterror)

`boolean | Error | undefined`

Whether to throw an error when `connector.connect` is called.

#### reconnect [‚Äã](#reconnect)

`boolean | undefined`

Enables reconnecting to connector.

#### signMessageError [‚Äã](#signmessageerror)

`boolean | Error | undefined`

Whether to throw an error when `'personal_sign'` is called.

#### signTypedDataError [‚Äã](#signtypeddataerror)

`boolean | Error | undefined`

Whether to throw an error when `'eth_signTypedData_v4'` is called.

#### switchChainError [‚Äã](#switchchainerror)

`boolean | Error | undefined`

Whether to throw an error when `connector.switchChain` is called.</content>
</page>

<page>
  <title>walletConnect | Wagmi</title>
  <url>https://wagmi.sh/vue/api/connectors/walletConnect</url>
  <content>Connector for [WalletConnect](https://walletconnect.com/).

Import [‚Äã](#import)
-------------------

ts

    import { walletConnect } from '@wagmi/vue/connectors'

Usage [‚Äã](#usage)
-----------------

ts

    import { createConfig, http } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    import { walletConnect } from '@wagmi/vue/connectors'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [
        walletConnect({
          projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
        }),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WalletConnectParameters } from '@wagmi/vue/connectors'

Check out the [WalletConnect docs](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/providers/ethereum-provider) for more info. A few options are omitted that Wagmi manages internally.

### customStoragePrefix @wagmi/vue@>=0.0.40 [‚Äã](#customstorageprefix)

`string | undefined`

Custom storage prefix for persisting provider state.

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      customStoragePrefix: 'wagmi', 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### disableProviderPing [‚Äã](#disableproviderping)

`boolean | undefined`

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      disableProviderPing: false, 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

### isNewChainsStale [‚Äã](#isnewchainsstale)

`boolean | undefined`

*   If a new chain is added to a previously existing configured connector `chains`, this flag will determine if that chain should be considered as stale. A stale chain is a chain that WalletConnect has yet to establish a relationship with (e.g. the user has not approved or rejected the chain).
*   Defaults to `true`.

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      isNewChainsStale: true, 
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
    })

More info

Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when a user tries to switch to a chain that they have not approved.

This flag mainly affects the behavior when a wallet does not support dynamic chain authorization with WalletConnect v2.

If `true` (default), the new chain will be treated as a stale chain. If the user has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect session, the connector will disconnect upon the dapp auto-connecting, and the user will have to reconnect to the dapp (revalidate the chain) in order to approve the newly added chain. This is the default behavior to avoid an unexpected error upon switching chains which may be a confusing user experience (e.g. the user will not know they have to reconnect unless the dapp handles these types of errors).

If `false`, the new chain will be treated as a validated chain. This means that if the user has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully auto-connect the user. This comes with the trade-off that the connector will throw an error when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly modifies their configured chains, and they do not want to disconnect the user upon auto-connecting. If the user decides to switch to the unapproved chain, it is important that the dapp handles this error and prompts the user to reconnect to the dapp in order to approve the newly added chain.

### metadata [‚Äã](#metadata)

`CoreTypes.Metadata | undefined`

Metadata related to the app requesting the connection.

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      metadata: { 
        name: 'Example', 
        description: 'Example website', 
        url: 'https://example.com', 
      }, 
    })

### projectId [‚Äã](#projectid)

`string`

WalletConnect Cloud project identifier. You can find your `projectId` on your [WalletConnect dashboard](https://cloud.reown.com/sign-in).

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68', 
    })

### qrModalOptions [‚Äã](#qrmodaloptions)

`QrModalOptions | undefined`

Options for rendering QR modal.

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      qrModalOptions: { 
        themeMode: 'dark', 
      }, 
    })

### relayUrl [‚Äã](#relayurl)

`string | undefined`

*   WalletConnect relay URL to use.
*   Defaults to `'wss://relay.walletconnect.com'`.

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      relayUrl: 'wss://relay.walletconnect.org', 
    })

### storageOptions [‚Äã](#storageoptions)

`KeyValueStorageOptions | undefined`

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      storageOptions: {}, 
    })

### showQrModal [‚Äã](#showqrmodal)

`boolean | undefined`

*   Whether to show the QR code modal upon calling `connector.connect()`.
*   Defaults to `true`.

ts

    import { walletConnect } from '@wagmi/vue/connectors'
    
    const connector = walletConnect({
      projectId: '3fcc6bba6f1de962d911bb5b5c3dba68',
      showQrModal: true, 
    })

TIP

This can be disabled and you can listen for a `'message'` event with payload `{ type: 'display_uri'; data: string }` if you want to render your own QR code.</content>
</page>

<page>
  <title>Transports | Wagmi</title>
  <url>https://wagmi.sh/vue/api/transports</url>
  <content>[`createConfig`](https://wagmi.sh/vue/api/createConfig) can be instantiated with a set of Transports for each chain. A Transport is the intermediary layer that is responsible for executing outgoing JSON-RPC requests to the RPC Provider (e.g. Alchemy, Infura, etc).

Import [‚Äã](#import)
-------------------

ts

    import { http } from '@wagmi/vue'

Built-In Transports [‚Äã](#built-in-transports)
---------------------------------------------

Available via the `'@wagmi/vue'` entrypoint.

*   [custom (EIP-1193)](https://wagmi.sh/core/api/transports/custom)
*   [fallback](https://wagmi.sh/core/api/transports/fallback)
*   [http](https://wagmi.sh/core/api/transports/http)
*   [unstable\_connector](https://wagmi.sh/core/api/transports/unstable_connector)
*   [webSocket](https://wagmi.sh/core/api/transports/webSocket)</content>
</page>

<page>
  <title>http | Wagmi</title>
  <url>https://wagmi.sh/vue/api/transports/http</url>
  <content>The `http` Transport connects to a JSON-RPC API via HTTP. Wraps Viem's [`http` Transport](https://viem.sh/docs/clients/transports/http.html).

Import [‚Äã](#import)
-------------------

ts

    import { http } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      http
    } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: http('https://foo-bar-baz.quiknode.pro/...'), 
        [sepolia.id]: http('https://foo-bar-sep.quiknode.pro/...'), 
      },
    })

WARNING

If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.

### Batch JSON-RPC [‚Äã](#batch-json-rpc)

The `http` Transport supports Batch JSON-RPC. This means that multiple JSON-RPC requests can be sent in a single HTTP request.

The Transport will batch up Actions over a given period and execute them in a single Batch JSON-RPC HTTP request. By default, this period is a [zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays) meaning that the batch request will be executed at the end of the current [JavaScript message queue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#queue). Consumers can specify a custom time period `wait` (in ms).

You can enable Batch JSON-RPC by setting the `batch` flag to `true`:

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: true
    })

Parameters [‚Äã](#parameters)
---------------------------

### url [‚Äã](#url)

`string`

URL of the JSON-RPC API. Defaults to `chain.rpcUrls.default.http[0]`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...')

### batch [‚Äã](#batch)

`boolean | BatchOptions`

Toggle to enable Batch JSON-RPC. Defaults to `false`

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: true
    })

### batch.batchSize [‚Äã](#batch-batchsize)

`number`

The maximum number of JSON-RPC requests to send in a batch. Defaults to `1_000`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: {
        batchSize: 2_000
      }
    })

### batch.wait [‚Äã](#batch-wait)

`number`

The maximum number of milliseconds to wait before sending a batch. Defaults to `0` ([zero delay](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#zero_delays)).

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      batch: {
        wait: 16
      }
    })

### fetchOptions [‚Äã](#fetchoptions)

[`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)

[Fetch options](https://developer.mozilla.org/en-US/docs/Web/API/fetch) to pass to the internal `fetch` function. Useful for passing auth headers or cache options.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      fetchOptions: { 
        headers: {
          'Authorization': 'Bearer ...'
        }
      }
    })

### key [‚Äã](#key)

`string`

A key for the Transport. Defaults to `"http"`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      key: 'alchemy', 
    })

### name [‚Äã](#name)

`string`

A name for the Transport. Defaults to `"HTTP JSON-RPC"`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      name: 'Alchemy HTTP Provider', 
    })

### retryCount [‚Äã](#retrycount)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      retryCount: 5, 
    })

### retryDelay [‚Äã](#retrydelay)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      retryDelay: 100, 
    })

### timeout [‚Äã](#timeout)

`number`

The timeout for requests. Defaults to `10_000`.

ts

    const transport = http('https://foo-bar-baz.quiknode.pro/...', {
      timeout: 60_000, 
    })</content>
</page>

<page>
  <title>custom | Wagmi</title>
  <url>https://wagmi.sh/vue/api/transports/custom</url>
  <content>The `custom` Transport connects to a JSON-RPC API via custom. Wraps Viem's [`custom` Transport](https://viem.sh/docs/clients/transports/custom.html).

Import [‚Äã](#import)
-------------------

ts

    import { custom } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      custom
    } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    import { customRpc } from './rpc'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: custom({ 
          async request({ method, params }) { 
            const response = await customRpc.request(method, params)
            return response
          } 
        }) 
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

### provider [‚Äã](#provider)

`{ request({ method: string, params: unknown[] }): Promise<unknown> }`

An [EIP-1193 `request` function](https://eips.ethereum.org/EIPS/eip-1193#request) function.

ts

    import { customRpc } from './rpc'
    
    const transport = custom({
      async request({ method, params }) { 
        const response = await customRpc.request(method, params)
        return response
      }
    })

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"custom"`.

ts

    const transport = custom(
      provider,
      { 
        key: 'windowProvider', 
      }
    )

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"Ethereum Provider"`.

ts

    const transport = custom(
      provider,
      { 
        name: 'Window Ethereum Provider', 
      }
    )

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = custom(provider, {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = custom(provider, {
      retryDelay: 100, 
    })</content>
</page>

<page>
  <title>webSocket | Wagmi</title>
  <url>https://wagmi.sh/vue/api/transports/webSocket</url>
  <content>The `webSocket` Transport connects to a JSON-RPC API via a WebSocket. Wraps Viem's [`webSocket` Transport](https://viem.sh/docs/clients/transports/webSocket.html).

Import [‚Äã](#import)
-------------------

ts

    import { webSocket } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      webSocket
    } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      connectors: [injected()],
      transports: {
        [mainnet.id]: webSocket('wss://foo-bar-baz.quiknode.pro/...'), 
        [sepolia.id]: webSocket('wss://foo-bar-sep.quicknode.pro/...'), 
      },
    })

WARNING

If no URL is provided, then the transport will fall back to a public RPC URL on the chain. It is highly recommended to provide an authenticated RPC URL to prevent rate-limiting.

Parameters [‚Äã](#parameters)
---------------------------

### url [‚Äã](#url)

`string`

URL of the JSON-RPC API.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...')

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"webSocket"`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
      key: 'alchemy',  
    })

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"WebSocket JSON-RPC"`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', { 
      name: 'Alchemy WebSocket Provider',  
    })

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      retryDelay: 100, 
    })

### timeout (optional) [‚Äã](#timeout-optional)

`number`

The timeout for async WebSocket requests. Defaults to `10_000`.

ts

    const transport = webSocket('wss://foo-bar-baz.quiknode.pro/...', {
      timeout: 60_000, 
    })</content>
</page>

<page>
  <title>unstable_connector | Wagmi</title>
  <url>https://wagmi.sh/vue/api/transports/unstable_connector</url>
  <content>The `unstable_connector` Transport connects to a JSON-RPC API via the provided [Connector](https://wagmi.sh/vue/api/connectors).

For example, if the provided Connector is [`injected`](https://wagmi.sh/vue/api/connectors/injected) and the end-user uses MetaMask, then outgoing JSON-RPC requests will be sent via the MetaMask EIP-1193 Provider (`window.ethereum`).

Import [‚Äã](#import)
-------------------

ts

    import { unstable_connector } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      fallback,
      unstable_connector,
    } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: fallback([
          unstable_connector(injected), 
          http('https://foo-bar-baz.quiknode.pro/...')
        ])
      },
    })

WARNING

It is **highly recommended** to use the `unstable_connector` Transport inside of a [`fallback` Transport](https://wagmi.sh/vue/api/transports/fallback). This ensures that if the Connector request fails, the Transport will fall back to a different Transport in the fallback set.

Some common cases for a Connector request to fail are:

*   Chain ID mismatches,
*   Connector RPC not supporting the requested method and/or only supporting a subset of methods for connected accounts,
*   Rate-limiting of Connector RPC.

Parameters [‚Äã](#parameters)
---------------------------

### connector [‚Äã](#connector)

`Connector`

The Connector to use for the Transport.

ts

    import { unstable_connector } from 'wagmi'
    import { safe } from 'wagmi/connectors'
    
    const transport = unstable_connector(safe)

### key (optional) [‚Äã](#key-optional)

`string`

A key for the Transport. Defaults to `"connector"`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, { 
      key: 'injected',  
    })

### name (optional) [‚Äã](#name-optional)

`string`

A name for the Transport. Defaults to `"Connector"`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, { 
      name: 'Injected',  
    })

### retryCount (optional) [‚Äã](#retrycount-optional)

`number`

The max number of times to retry when a request fails. Defaults to `3`.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, {
      retryCount: 5, 
    })

### retryDelay (optional) [‚Äã](#retrydelay-optional)

`number`

The base delay (in ms) between retries. By default, the Transport will use [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) (`~~(1 << count) * retryDelay`), which means the time between retries is not constant.

ts

    import { unstable_connector } from 'wagmi'
    import { injected } from 'wagmi/connectors'
    
    const transport = unstable_connector(injected, {
      retryDelay: 100, 
    })</content>
</page>

<page>
  <title>fallback | Wagmi</title>
  <url>https://wagmi.sh/vue/api/transports/fallback</url>
  <content>The `fallback` Transport consumes **multiple** Transports. If a Transport request fails, it will fall back to the next one in the list. Wraps Viem's [`fallback` Transport](https://viem.sh/docs/clients/transports/fallback.html).

Import [‚Äã](#import)
-------------------

ts

    import { fallback } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { 
      createConfig, 
      fallback,
      http,
    } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet],
      connectors: [injected()],
      transports: {
        [mainnet.id]: fallback([ 
          http('https://foo-bar-baz.quiknode.pro/...'), 
          http('https://mainnet.infura.io/v3/...'), 
        ]) 
      },
    })</content>
</page>

<page>
  <title>Nuxt | Wagmi</title>
  <url>https://wagmi.sh/vue/api/Nuxt</url>
  <content>[Nuxt Module](https://nuxt.com/docs/guide/concepts/modules) for Wagmi. Adds all [Composables](https://wagmi.sh/vue/api/composables) as [auto-imports](https://nuxt.com/docs/guide/concepts/auto-imports).

Usage [‚Äã](#usage)
-----------------

nuxt.config.tsindex.vueconfig.ts

ts

    import {  } from 'nuxt/config'
    
    export default ({
      : ['@wagmi/vue/nuxt'],
    })

vue

    <script setup lang="ts">
    // No need to import `useAccount`!
    const account = useAccount()
    </script>
    
    <template>
      Address: {{ account.address }}
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })</content>
</page>

<page>
  <title>WagmiPlugin | Wagmi</title>
  <url>https://wagmi.sh/vue/api/WagmiPlugin</url>
  <content>[Vue Plugin](https://vuejs.org/guide/reusability/plugins.html#plugins) for Wagmi.

Import [‚Äã](#import)
-------------------

ts

    import { WagmiPlugin } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

main.tsconfig.ts

ts

    import { createApp } from 'vue'
    import { WagmiPlugin } from '@wagmi/vue'
    
    import App from './App.vue'
    import { config } from './config' 
    
    createApp(App)
      .use(WagmiPlugin, { config })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WagmiPluginProps } from '@wagmi/vue'

### config [‚Äã](#config)

[`Config`](https://wagmi.sh/vue/api/createConfig#config) object to inject with context.

main.tsconfig.ts

ts

    import { createApp } from 'vue'
    import { WagmiPlugin } from '@wagmi/vue'
    
    import App from './App.vue'
    import { config } from './config' 
    
    createApp(App)
      .use(WagmiPlugin, { 
        config
      })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### initialState [‚Äã](#initialstate)

`State | undefined`

*   Initial state to hydrate into the [Wagmi Config](https://wagmi.sh/vue/api/createConfig). Useful for SSR.

main.tsconfig.ts

ts

    import { createApp } from 'vue'
    import { WagmiPlugin } from '@wagmi/vue'
    
    import App from './App.vue'
    import { config } from './config' 
    
    createApp(App)
      .use(WagmiPlugin, { 
        config,
        initialState: /* ... */
      })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### reconnectOnMount [‚Äã](#reconnectonmount)

`boolean | undefined`

*   Whether or not to reconnect previously connected [connectors](https://wagmi.sh/vue/api/createConfig#connectors) on mount.
*   Defaults to `true`.

main.tsconfig.ts

ts

    import { createApp } from 'vue'
    import { WagmiPlugin } from '@wagmi/vue'
    
    import App from './App.vue'
    import { config } from './config' 
    
    createApp(App)
      .use(WagmiPlugin, { 
        config,
        reconnectOnMount: false
      })
      .mount('#app')

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

configKey [‚Äã](#configkey)
-------------------------

Key to use to provide/inject `Config` via `WagmiPlugin`.

ts

    import { configKey, type Config } from '@wagmi/vue'
    import { inject } from 'vue'
    
    inject<Config | undefined>(configKey)</content>
</page>

<page>
  <title>Composables | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables</url>
  <content>Released under the [MIT License](https://github.com/wevm/wagmi/blob/main/LICENSE).

Copyright ¬© 2022-present Weth, LLC</content>
</page>

<page>
  <title>useAccount | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useAccount</url>
  <content>Composable for getting current account.

Import [‚Äã](#import)
-------------------

ts

    import { useAccount } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import {  } from '@wagmi/vue'
    
    const  = ()
    </script>
    
    <template>
      Address: {{ . }}
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type  } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useAccount } from '@wagmi/vue'
    import { config } from './config'
    
    const account = useAccount({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type  } from '@wagmi/vue'

### address [‚Äã](#address)

`Address | undefined`

*   Connected address from connector.
*   Defaults to first address in [`addresses`](#addresses).

### addresses [‚Äã](#addresses)

`readonly Address[] | undefined`

Connected addresses from connector.

### chain [‚Äã](#chain)

`Chain | undefined`

Connected chain from connector. If chain is not configured by config, it will be `undefined`.

### chainId [‚Äã](#chainid)

`number | undefined`

Connected chain id from connector.

### connector [‚Äã](#connector)

`Connector | undefined`

Connected connector.

### isConnecting / isReconnecting / isConnected / isDisconnected [‚Äã](#isconnecting-isreconnecting-isconnected-isdisconnected)

`boolean`

Boolean variables derived from [`status`](#status).

### status [‚Äã](#status)

`'connecting' | 'reconnecting' | 'connected' | 'disconnected'`

*   `'connecting'` attempting to establish connection.
*   `'reconnecting'` attempting to re-establish connection to one or more connectors.
*   `'connected'` at least one connector is connected.
*   `'disconnected'` no connection to any connector.

You can use `status` to narrow the return type.

For example, when `status` is `'connected'` properties like `address` are guaranteed to be defined.

ts

    if (. === 'connected') {
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

Or when status is `'disconnected'` properties like `address` are guaranteed to be `undefined`:

ts

    if (. === 'disconnected') {
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

Action [‚Äã](#action)
-------------------

*   [`getAccount`](https://wagmi.sh/core/api/actions/getAccount)</content>
</page>

<page>
  <title>Connect Wallet | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/connect-wallet</url>
  <content>The ability for a user to connect their wallet is a core function for any Dapp. It allows users to perform tasks such as: writing to contracts, signing messages, or sending transactions.

Wagmi contains everything you need to get started with building a Connect Wallet module. To get started, you can either use a [third-party library](#third-party-libraries) or [build your own](#build-your-own).

Third-party Libraries [‚Äã](#third-party-libraries)
-------------------------------------------------

You can use a pre-built Connect Wallet module from a third-party library such as:

*   [AppKit](https://walletconnect.com/appkit) - [Guide](https://docs.walletconnect.com/appkit/vue/core/installation)

The above libraries are all built on top of Wagmi, handle all the edge cases around wallet connection, and provide a seamless Connect Wallet UX that you can use in your Dapp.

Build Your Own [‚Äã](#build-your-own)
-----------------------------------

Wagmi provides you with the Composables to get started building your own Connect Wallet module.

It takes less than five minutes to get up and running with Browser Wallets, WalletConnect, and Coinbase Wallet.

### 1\. Configure Wagmi [‚Äã](#_1-configure-wagmi)

Before we get started with building the functionality of the Connect Wallet module, we will need to set up the Wagmi configuration.

Let's create a `config.ts` file and export a `config` object.

config.ts

tsx

    import { http, createConfig } from '@wagmi/vue'
    import { base, mainnet, optimism } from '@wagmi/vue/chains'
    import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

In the above configuration, we want to set up connectors for Injected (browser), WalletConnect (browser + mobile), MetaMask, and Safe wallets. This configuration uses the **Mainnet** and **Base** chains, but you can use whatever you want.

WARNING

Make sure to replace the `projectId` with your own WalletConnect Project ID, if you wish to use WalletConnect!

[Get your Project ID](https://cloud.walletconnect.com/)

### 2\. Inject the WagmiPlugin onto your App [‚Äã](#_2-inject-the-wagmiplugin-onto-your-app)

Next, we will need to inject our App with plugins so that our application is aware of Wagmi & Vue Query's reactive state and in-memory caching.

main.tsApp.vueconfig.ts

ts

    // 1. Import modules.
    import { VueQueryPlugin } from '@tanstack/vue-query';
    import { WagmiPlugin } from '@wagmi/vue';
    import { createApp } from 'vue';
    
    import App from './App.vue';
    import { config } from './wagmi';
    
    createApp(App)
      // 2. Inject the Wagmi plugin.
      .use(WagmiPlugin, { config })
      // 3. Inject the Vue Query plugin.
      .use(VueQueryPlugin, {})
      .mount('#app');

vue

    <script setup lang="ts">
    </script>
    
    <template>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, mainnet, optimism } from '@wagmi/vue/chains'
    import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### 3\. Display Wallet Options [‚Äã](#_3-display-wallet-options)

After that, we will create a `Connect` component that will display our connectors. This will allow users to select a wallet and connect.

Below, we are rendering a list of `connectors` retrieved from `useConnect`. When the user clicks on a connector, the `connect` function will connect the users' wallet.

Connect.vueApp.vuemain.tsconfig.ts

vue

    <script setup lang="ts">
    import { useConnect, useChainId } from '@wagmi/vue';
    
    const chainId = useChainId();
    const { connectors, connect } = useConnect();
    </script>
    
    <template>
      <button
        v-for="connector in connectors"
        @click="connect({ connector, chainId })"
      >
        {{ connector.name }}
      </button>
    </template>

vue

    <script setup lang="ts">
    </script>
    
    <template>
    </template>

ts

    // 1. Import modules.
    import { VueQueryPlugin } from '@tanstack/vue-query';
    import { WagmiPlugin } from '@wagmi/vue';
    import { createApp } from 'vue';
    
    import App from './App.vue';
    import { config } from './wagmi';
    
    createApp(App)
      // 2. Inject the Wagmi plugin.
      .use(WagmiPlugin, { config })
      // 3. Inject the Vue Query plugin.
      .use(VueQueryPlugin, {})
      .mount('#app');

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, mainnet, optimism } from '@wagmi/vue/chains'
    import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### 4\. Display Connected Account [‚Äã](#_4-display-connected-account)

Lastly, if an account is connected, we want to show some basic information, like the connected address and ENS name and avatar.

Below, we are using hooks like `useAccount`, `useEnsAvatar` and `useEnsName` to extract this information.

We are also utilizing `useDisconnect` to show a "Disconnect" button so a user can disconnect their wallet.

Account.vueConnect.vueApp.vuemain.tsconfig.ts

vue

    <script setup lang="ts">
    import { useAccount, useDisconnect } from '@wagmi/vue';
    
    const { address, connector } = useAccount();
    const { disconnect } = useDisconnect();
    </script>
    
    <template>
      <div>Address: {{ address }}</div>
      <div>Connected to {{ connector?.name }} Connector.</div>
      <button @click="disconnect()">Disconnect</button>
    </template>

vue

    <script setup lang="ts">
    import { useConnect, useChainId } from '@wagmi/vue';
    
    const chainId = useChainId();
    const { connectors, connect } = useConnect();
    </script>
    
    <template>
      <button
        v-for="connector in connectors"
        @click="connect({ connector, chainId })"
      >
        {{ connector.name }}
      </button>
    </template>

vue

    <script setup lang="ts">
    </script>
    
    <template>
    </template>

ts

    // 1. Import modules.
    import { VueQueryPlugin } from '@tanstack/vue-query';
    import { WagmiPlugin } from '@wagmi/vue';
    import { createApp } from 'vue';
    
    import App from './App.vue';
    import { config } from './wagmi';
    
    createApp(App)
      // 2. Inject the Wagmi plugin.
      .use(WagmiPlugin, { config })
      // 3. Inject the Vue Query plugin.
      .use(VueQueryPlugin, {})
      .mount('#app');

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, mainnet, optimism } from '@wagmi/vue/chains'
    import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### 5\. Wire it up! [‚Äã](#_5-wire-it-up)

Finally, we can wire up our Connect and Account components to our application's entrypoint.

App.vueAccount.vueConnect.vuemain.tsconfig.ts

vue

    <script setup lang="ts">
    import { useAccount } from '@wagmi/vue';
    import Account from './Account.vue';
    import Connect from './Connect.vue';
    
    const { isConnected } = useAccount();
    </script>
    
    <template>
      <Account v-if="isConnected" />
      <Connect v-else />
    </template>

vue

    <script setup lang="ts">
    import { useAccount, useDisconnect } from '@wagmi/vue';
    
    const { address, connector } = useAccount();
    const { disconnect } = useDisconnect();
    </script>
    
    <template>
      <div>Address: {{ address }}</div>
      <div>Connected to {{ connector?.name }} Connector.</div>
      <button @click="disconnect()">Disconnect</button>
    </template>

vue

    <script setup lang="ts">
    import { useConnect, useChainId } from '@wagmi/vue';
    
    const chainId = useChainId();
    const { connectors, connect } = useConnect();
    </script>
    
    <template>
      <button
        v-for="connector in connectors"
        @click="connect({ connector, chainId })"
      >
        {{ connector.name }}
      </button>
    </template>

ts

    // 1. Import modules.
    import { VueQueryPlugin } from '@tanstack/vue-query';
    import { WagmiPlugin } from '@wagmi/vue';
    import { createApp } from 'vue';
    
    import App from './App.vue';
    import { config } from './wagmi';
    
    createApp(App)
      // 2. Inject the Wagmi plugin.
      .use(WagmiPlugin, { config })
      // 3. Inject the Vue Query plugin.
      .use(VueQueryPlugin, {})
      .mount('#app');

ts

    import { http, createConfig } from '@wagmi/vue'
    import { base, mainnet, optimism } from '@wagmi/vue/chains'
    import { injected, metaMask, safe, walletConnect } from '@wagmi/vue/connectors'
    
    const projectId = '<WALLETCONNECT_PROJECT_ID>'
    
    export const config = createConfig({
      chains: [mainnet, base],
      connectors: [
        injected(),
        walletConnect({ projectId }),
        metaMask(),
        safe(),
      ],
      transports: {
        [mainnet.id]: http(),
        [base.id]: http(),
      },
    })

### Playground [‚Äã](#playground)

Want to see the above steps all wired up together in an end-to-end example? Check out the below StackBlitz playground.</content>
</page>

<page>
  <title>Send Transaction | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/send-transaction</url>
  <content>The following guide teaches you how to send transactions in Wagmi. The example below builds on the [Connect Wallet guide](https://wagmi.sh/vue/guides/connect-wallet) and uses the [useSendTransaction](https://wagmi.sh/vue/api/composables/useSendTransaction) & [useWaitForTransaction](https://wagmi.sh/vue/api/composables/useWaitForTransactionReceipt) composables.

Example [‚Äã](#example)
---------------------

Feel free to check out the example before moving on:

Steps [‚Äã](#steps)
-----------------

### 1\. Connect Wallet [‚Äã](#_1-connect-wallet)

Follow the [Connect Wallet guide](https://wagmi.sh/vue/guides/connect-wallet) guide to get this set up.

### 2\. Create a new component [‚Äã](#_2-create-a-new-component)

Create your `SendTransaction` component that will contain the send transaction logic.

SendTransaction.vue

tsx

    <script setup lang="ts">
    </script>
    
    <template>
      <form>
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button type="submit">Send</button>
      </form>
    </template>

### 3\. Add a form handler [‚Äã](#_3-add-a-form-handler)

Next, we will need to add a handler to the form that will send the transaction when the user hits "Send". This will be a basic handler in this step.

SendTransaction.vue

vue

    <script setup lang="ts">
      function submit(event: Event) {
        const formData = new FormData(event.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
        sendTransaction({ to, value: parseEther(value) })
      }
    </script>
    
    <template>
      <form>
      <form @submit.prevent="submit">
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button type="submit">Send</button>
      </form>
    </template>

### 4\. Hook up the `useSendTransaction` Composable [‚Äã](#_4-hook-up-the-usesendtransaction-composable)

Now that we have the form handler, we can hook up the [`useSendTransaction` Composable](https://wagmi.sh/vue/api/composables/useSendTransaction) to send the transaction.

SendTransaction.vue

vue

    <script setup lang="ts">
      import { useSendTransaction } from 'wagmi'
      import { parseEther } from 'viem'
    
      const { data: hash, sendTransaction } = useSendTransaction()
    
      function submit(event: Event) {
        const formData = new FormData(event.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
        sendTransaction({ to, value: parseEther(value) })
      }
    </script>
    
    <template>
      <form @submit.prevent="submit">
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button type="submit">Send</button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
      </form>
    </template>

### 5\. Add loading state (optional) [‚Äã](#_5-add-loading-state-optional)

We can optionally add a loading state to the "Send" button while we are waiting confirmation from the user's wallet.

SendTransaction.vue

vue

    <script setup lang="ts">
      import { useSendTransaction } from 'wagmi'
      import { parseEther } from 'viem'
    
      const { 
        data: hash, 
        isPending,
        sendTransaction 
      } = useSendTransaction()
    
      function submit(event: Event) {
        const formData = new FormData(event.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
        sendTransaction({ to, value: parseEther(value) })
      }
    </script>
    
    <template>
      <form @submit.prevent="submit">
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
      </form>
    </template>

### 6\. Wait for transaction receipt (optional) [‚Äã](#_6-wait-for-transaction-receipt-optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Composable](https://wagmi.sh/vue/api/composables/useWaitForTransactionReceipt).

SendTransaction.vue

vue

    <script setup lang="ts">
      import { 
        useSendTransaction,
        useWaitForTransactionReceipt,
      } from 'wagmi'
      import { parseEther } from 'viem'
    
      const { 
        data: hash, 
        isPending,
        sendTransaction 
      } = useSendTransaction()
    
      function submit(event: Event) {
        const formData = new FormData(event.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
        sendTransaction({ to, value: parseEther(value) })
      }
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } =
        useWaitForTransactionReceipt({ 
          hash, 
        })
    </script>
    
    <template>
      <form @submit.prevent="submit">
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
        <div v-if="isConfirming">Waiting for confirmation...</div>
        <div v-if="isConfirmed">Transaction Confirmed!</div>
      </form>
    </template>

### 7\. Handle errors (optional) [‚Äã](#_7-handle-errors-optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

SendTransaction.vue

vue

    <script setup lang="ts">
      import { 
        useSendTransaction,
        useWaitForTransactionReceipt,
      } from 'wagmi'
      import { parseEther } from 'viem'
    
      const { 
        data: hash, 
        error,
        isPending,
        sendTransaction 
      } = useSendTransaction()
    
      function submit(event: Event) {
        const formData = new FormData(event.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
        sendTransaction({ to, value: parseEther(value) })
      }
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } = 
        useWaitForTransactionReceipt({ 
          hash, 
        }) 
    </script>
    
    <template>
      <form @submit.prevent="submit">
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
        <div v-if="isConfirming">Waiting for confirmation...</div> 
        <div v-if="isConfirmed">Transaction Confirmed!</div> 
        <div v-if="error">
          Error: {{ (error as BaseError).shortMessage || error.message }}
        </div>
      </form>
    </template>

### 8\. Wire it up! [‚Äã](#_8-wire-it-up)

Finally, we can wire up our Send Transaction component to our application's entrypoint.

App.vueSendTransaction.vue

vue

    <script setup lang="ts">
    import { useAccount } from '@wagmi/vue';
    import Account from './Account.vue';
    import Connect from './Connect.vue';
    import SendTransaction from './SendTransaction.vue';
    
    const { isConnected } = useAccount();
    </script>
    
    <template>
      <Account v-if="isConnected" />
      <Connect v-else />
      <SendTransaction v-if="isConnected" />
    </template>

vue

    <script setup lang="ts">
      import { 
        useSendTransaction,
        useWaitForTransactionReceipt,
      } from 'wagmi'
      import { parseEther } from 'viem'
    
      const { 
        data: hash, 
        error,
        isPending,
        sendTransaction 
      } = useSendTransaction()
    
      function submit(event: Event) {
        const formData = new FormData(event.target as HTMLFormElement)
        const to = formData.get('address') as `0x${string}`
        const value = formData.get('value') as string
        sendTransaction({ to, value: parseEther(value) })
      }
    
      const { isLoading: isConfirming, isSuccess: isConfirmed } = 
        useWaitForTransactionReceipt({ 
          hash, 
        }) 
    </script>
    
    <template>
      <form @submit.prevent="submit">
        <input name="address" placeholder="0xA0Cf‚Ä¶251e" required />
        <input name="value" placeholder="0.05" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
        <div v-if="isConfirming">Waiting for confirmation...</div> 
        <div v-if="isConfirmed">Transaction Confirmed!</div> 
        <div v-if="error">
          Error: {{ (error as BaseError).shortMessage || error.message }}
        </div>
      </form>
    </template>

[See the Example.](#example)</content>
</page>

<page>
  <title>useChainId | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useChainId</url>
  <content>Composable for getting current chain ID.

Import [‚Äã](#import)
-------------------

ts

    import { useChainId } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useChainId } from '@wagmi/vue'
    
    const chainId = useChainId()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseChainIdParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useChainId } from '@wagmi/vue'
    import { config } from './config'
    
    const chainId = useChainId({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseChainIdReturnType } from '@wagmi/vue'

`number`

Current chain ID from [`config.state.chainId`](https://wagmi.sh/vue/api/createConfig#chainid).

INFO

Only returns chain IDs for chains configured via `createConfig`'s [`chains`](https://wagmi.sh/vue/api/createConfig#chains) parameter.

If the active [connection](https://wagmi.sh/vue/api/createConfig#connection) [`chainId`](https://wagmi.sh/vue/api/createConfig#chainid-1) is not from a chain included in your Wagmi `Config`, `useChainId` will return the last configured chain ID.

Action [‚Äã](#action)
-------------------

*   [`getChainId`](https://wagmi.sh/core/api/actions/getChainId)
*   [`watchChainId`](https://wagmi.sh/core/api/actions/watchChainId)</content>
</page>

<page>
  <title>useChains | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useChains</url>
  <content>Composable for getting configured chains

Import [‚Äã](#import)
-------------------

ts

    import { useChains } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useChains } from '@wagmi/vue'
    
    const chains = useChains()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseChainsParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useChains } from '@wagmi/vue'
    import { config } from './config'
    
    const chains = useChains({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseChainsReturnType } from '@wagmi/vue'

`readonly [Chain, ...Chain[]]`

Chains from [`config.chains`](https://wagmi.sh/vue/api/createConfig#chains).

Action [‚Äã](#action)
-------------------

*   [`getChains`](https://wagmi.sh/core/api/actions/getChains)</content>
</page>

<page>
  <title>useBlockNumber | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useBlockNumber</url>
  <content>Composable for fetching the number of the most recent block seen.

Import [‚Äã](#import)
-------------------

ts

    import { useBlockNumber } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    
    const { data: blockNumber } = useBlockNumber()
    </script>
    
    <template>
      Block Number: {{ blockNumber }}
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBlockNumberParameters } from '@wagmi/vue'

### cacheTime [‚Äã](#cachetime)

`MaybeRef<number> | undefined`

Time in milliseconds that cached block number will remain in memory.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    
    const { data: blockNumber } = useBlockNumber({
      cacheTime: 4_000
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`MaybeRef<config['chains'][number]['id']> | undefined`

ID of chain to use when fetching data.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    const { data: blockNumber } = useBlockNumber({
      chainId: mainnet.id, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    import { config } from './config'
    
    const { data: blockNumber } = useBlockNumber({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`MaybeRef<string> | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    
    const { data: blockNumber } = useBlockNumber({
      scopeKey: 'foo', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### watch [‚Äã](#watch)

`MaybeRef<boolean | UseWatchBlockNumberParameters> | undefined`

*   Enables/disables listening for block number changes.
*   Can pass a subset of [`UseWatchBlockNumberParameters`](https://wagmi.sh/vue/api/composables/useWatchBlockNumber#parameters) directly to [`useWatchBlockNumber`](https://wagmi.sh/vue/api/composables/useWatchBlockNumber).

index.vueindex-2.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    
    const { data: blockNumber } = useBlockNumber({
      watch: true, 
    })
    </script>

vue

    <script setup lang="ts">
    import { useBlockNumber } from '@wagmi/vue'
    
    const { data: blockNumber } = useBlockNumber({
      watch: { 
        pollingInterval: 4_000
      }, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBlockNumberErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBlockNumberErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBlockNumberReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBlockNumberErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBlockNumberErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, GetBlockNumberErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBlockNumberData,
      type GetBlockNumberOptions,
      type GetBlockNumberQueryFnData,
      type GetBlockNumberQueryKey,
      getBlockNumberQueryKey,
      getBlockNumberQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getBlockNumber`](https://wagmi.sh/core/api/actions/getBlockNumber)
*   [`watchBlockNumber`](https://wagmi.sh/core/api/actions/watchBlockNumber)</content>
</page>

<page>
  <title>useAccountEffect | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useAccountEffect</url>
  <content>Composable for listening to account lifecycle events.

Import [‚Äã](#import)
-------------------

ts

    import { useAccountEffect } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useAccountEffect } from '@wagmi/vue'
    
    useAccountEffect({
      onConnect(data) {
        console.log('Connected!', data)
      },
      onDisconnect() {
        console.log('Disconnected!')
      },
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type useAccountEffectParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useAccountEffect } from '@wagmi/vue'
    import { config } from './config'
    
    useAccountEffect({
      config, 
      onConnect(data) {
        console.log('Connected!', data)
      },
      onDisconnect() {
        console.log('Disconnected!')
      },
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onConnect [‚Äã](#onconnect)

``MaybeRef<((data: { address: `0x${string}`; addresses: readonly [`0x${string}`, ...`0x${string}`[]]; chain: Chain | undefined chainId: number; connector: Connector; isReconnected: boolean }) => void)> | undefined``

Callback that is called when accounts are connected.

index.tsxconfig.ts

tsx

    import { useAccountEffect } from '@wagmi/vue'
    
    function App() {
      useAccountEffect({
        onConnect(data) {
          console.log('Connected!', data)
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### onDisconnect [‚Äã](#ondisconnect)

`MaybeRef<(() => void)> | undefined`

Callback that is called when no more accounts are connected.

index.tsxconfig.ts

tsx

    import { useAccountEffect } from '@wagmi/vue'
    
    function App() {
      useAccountEffect({
        onDisconnect() {
          console.log('Disconnected!')
        },
      })
    }

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Action [‚Äã](#action)
-------------------

*   [`getAccount`](https://wagmi.sh/core/api/actions/getAccount)
*   [`watchAccount`](https://wagmi.sh/core/api/actions/watchAccount)</content>
</page>

<page>
  <title>useBalance | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useBalance</url>
  <content>Composable for fetching native currency or token balance.

Import [‚Äã](#import)
-------------------

ts

    import { useBalance } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBalanceParameters } from '@wagmi/vue'

### address [‚Äã](#address)

`Address | undefined`

Address to get balance for. [`enabled`](#enabled) set to `false` if `address` is `undefined`.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get balance at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      blockNumber: 17829139n, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get balance at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      blockTag: 'latest', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      chainId: mainnet.id, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      scopeKey: 'foo', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### token [‚Äã](#token)

`Address | undefined`

ERC-20 token address to get balance for.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      token: '0x6B175474E89094C44Da98b954EedeAC495271d0F', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### unit [‚Äã](#unit)

`'ether' | 'gwei' | 'wei' | number | undefined`

*   Units to use when formatting result.
*   Defaults to `'ether'`.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBalance } from '@wagmi/vue'
    
    const result = useBalance({
      address: '0x4557B18E779944BFE9d78A672452331C186a9f48',
      unit: 'ether', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`{ decimals: number; formatted: string; symbol: string; value: bigint; } | (() => { decimals: number; formatted: string; symbol: string; value: bigint; }) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`{ decimals: number; formatted: string; symbol: string; value: bigint; } | ((previousValue: { decimals: number; formatted: string; symbol: string; value: bigint; } | undefined; previousQuery: Query | undefined) => { decimals: number; formatted: string; symbol: string; value: bigint; }) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: { decimals: number; formatted: string; symbol: string; value: bigint; } | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBalanceErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBalanceErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: { decimals: number; formatted: string; symbol: string; value: bigint; }) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: { decimals: number; formatted: string; symbol: string; value: bigint; } | undefined, newData: { decimals: number; formatted: string; symbol: string; value: bigint; }) => { decimals: number; formatted: string; symbol: string; value: bigint; })) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBalanceReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`{ decimals: number; formatted: string; symbol: string; value: bigint; }`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBalanceErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBalanceErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<{ decimals: number; formatted: string; symbol: string; value: bigint; }, GetBalanceErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBalanceData,
      type GetBalanceOptions,
      type GetBalanceQueryFnData,
      type GetBalanceQueryKey,
      getBalanceQueryKey,
      getBalanceQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getBalance`](https://wagmi.sh/core/api/actions/getBalance)</content>
</page>

<page>
  <title>useBytecode | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useBytecode</url>
  <content>Composable for retrieving the bytecode at an address.

Import [‚Äã](#import)
-------------------

ts

    import { useBytecode } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseBytecodeParameters } from '@wagmi/vue'

### address [‚Äã](#address)

`Address | undefined`

The contract address.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

The block number to check the bytecode at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      blockNumber: 16280770n, 
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

The block tag to check the bytecode at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      blockTag: 'safe', 
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The chain ID to check the bytecode at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      chainId: mainnet.id, 
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    import { config } from './config'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      config, 
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Hooks that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useBytecode } from '@wagmi/vue'
    import { config } from './config'
    
    const { data: byteCode } = useBytecode({
      address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
      scopeKey: 'foo', 
    })
    </script>
    
    <template>
      Byte Code: {{ byteCode }}
    </template>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetBytecodeData | (() => GetBytecodeData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetBytecodeData | ((previousValue: GetBytecodeData | undefined; previousQuery: Query | undefined) => GetBytecodeData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetBytecodeData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetBytecodeErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetBytecodeErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetBytecodeData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetBytecodeData | undefined, newData: GetBytecodeData) => GetBytecodeData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseBytecodeReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetBytecodeData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetBytecodeErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetBytecodeErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetBytecodeData, GetBytecodeErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetBytecodeData,
      type GetBytecodeOptions,
      type GetBytecodeQueryFnData,
      type GetBytecodeQueryKey,
      getBytecodeQueryKey,
      getBytecodeQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getBytecode`](https://wagmi.sh/core/api/actions/getBytecode)</content>
</page>

<page>
  <title>useClient | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useClient</url>
  <content>Composable for getting Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

Import [‚Äã](#import)
-------------------

ts

    import { useClient } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useClient } from '@wagmi/vue'
    
    const client = useClient()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseClientParameters } from '@wagmi/vue'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when getting Viem Client.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useClient } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    import { config } from './config'
    
    const client = useClient({
      chainId: mainnet.id, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useClient } from '@wagmi/vue'
    import { config } from './config'
    
    const client = useClient({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseClientReturnType } from '@wagmi/vue'

`Client | undefined`

Viem [`Client`](https://viem.sh/docs/clients/custom.html) instance.

Action [‚Äã](#action)
-------------------

*   [`getClient`](https://wagmi.sh/core/api/actions/getClient)
*   [`watchClient`](https://wagmi.sh/core/api/actions/watchClient)</content>
</page>

<page>
  <title>useConfig | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useConfig</url>
  <content>Composable for getting [`Config`](https://wagmi.sh/vue/api/createConfig#config) from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

Import [‚Äã](#import)
-------------------

ts

    import { useConfig } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.vue

vue

    <script setup lang="ts">
    import { useConfig } from 'wagmi'
    
    const config = useConfig()
    </script>

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConfigReturnType } from 'wagmi'</content>
</page>

<page>
  <title>useConnectorClient | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useConnectorClient</url>
  <content>Composable for getting a Viem [`Client`](https://viem.sh/docs/clients/custom.html) object for the current or provided connector.

Import [‚Äã](#import)
-------------------

ts

    import { useConnectorClient } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnectorClient } from '@wagmi/vue'
    
    const result = useConnectorClient()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseConnectorClientParameters } from '@wagmi/vue'

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use with client. Throws if account is not found on [`connector`](#connector).

vue

    <script setup lang="ts">
    import { useConnectorClient } from '@wagmi/vue'
    
    const result = useConnectorClient({
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })
    </script>

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use with client.

vue

    <script setup lang="ts">
    import { useConnectorClient } from '@wagmi/vue'
    
    const result = useConnectorClient({
      chainId: mainnet.id, 
    })
    </script>

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnectorClient } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useConnectorClient({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

*   Connector to get client for.
*   Defaults to current connector.

vue

    <script setup lang="ts">
    import { useConnections, useConnectorClient } from '@wagmi/vue'
    
    const connections = useConnections(config)
    const result = useConnectorClient({
      connector: connections[0]?.connector, 
    })
    </script>

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### initialData [‚Äã](#initialdata)

`Client | (() => Client) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`Client | ((previousValue: Client | undefined; previousQuery: Query | undefined) => Client) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: Client | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetConnectorClientErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetConnectorClientErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: Client) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: Client | undefined, newData: Client) => Client)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectorClientReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`Client`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetConnectorClientErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetConnectorClientErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<Client, GetConnectorClientErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetConnectorClientData,
      type GetConnectorClientOptions,
      type GetConnectorClientQueryFnData,
      type GetConnectorClientQueryKey,
      getConnectorClientQueryKey,
      getConnectorClientQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getConnectorClient`](https://wagmi.sh/core/api/actions/getConnectorClient)</content>
</page>

<page>
  <title>useConnect | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useConnect</url>
  <content>Composable for connecting accounts with [connectors](https://wagmi.sh/vue/api/connectors).

Import [‚Äã](#import)
-------------------

ts

    import { useConnect } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnect } from '@wagmi/vue'
    import { injected } from '@wagmi/connectors'
    
    const { connect } = useConnect()
    </script>
    
    <template>
      <button @click="connect({ connector: injected() })">
        Connect
      </button>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseConnectParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnect } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useConnect({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`connect`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: ConnectErrorType, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; }, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; }, error: ConnectErrorType, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ConnectErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ConnectErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectReturnType } from '@wagmi/vue'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Globally configured connectors via [`createConfig`](https://wagmi.sh/vue/api/createConfig#connectors). Useful for rendering a list of available connectors.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnect } from '@wagmi/vue'
    
    const { connect, connectors } = useConnect()
    </script>
    
    <template>
      <div>
        <button v-for="connector in connectors" :key="connector.id" @click="connect({ connector })">
          {{ connector.name }}
        </button>
      </div>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### connect [‚Äã](#mutate)

`(variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }`
    
    The variables object to pass to the [`connect`](https://wagmi.sh/core/api/actions/connect#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; }, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: ConnectErrorType, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; } | undefined, error: ConnectErrorType | null, variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### connectAsync [‚Äã](#mutate-async)

`(variables: { chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; }, { onSuccess, onSettled, onError }) => Promise<{ accounts: readonly [Address, ...Address[]]; chainId: number; }>`

Similar to [`connect`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`{ accounts: readonly [Address, ...Address[]]; chainId: number; } | undefined`

*   [`connect` return type](https://wagmi.sh/core/api/actions/connect#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`ConnectErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`ConnectErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`{ chainId?: number | undefined; connector?: CreateConnectorFn | Connector | undefined; } | undefined`

*   The variables object passed to [`connect`](#mutate).
*   Defaults to `undefined`.

TIP

Not all connectors support connecting directly to a `chainId` (e.g. they don't support programmatic chain switching). In those cases, the connector will connect to whatever chain the connector's provider (e.g. wallet) is connected to.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ConnectData,
      type ConnectVariables,
      type ConnectMutate,
      type ConnectMutateAsync,
      connectMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`connect`](https://wagmi.sh/core/api/actions/connect)</content>
</page>

<page>
  <title>useConnections | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useConnections</url>
  <content>Composable for getting active connections.

Import [‚Äã](#import)
-------------------

ts

    import { useConnections } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnections } from 'wagmi'
    
    const connections = useConnections()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseConnectionsParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnections } from 'wagmi'
    import { config } from './config'
    
    const connections = useConnections({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectionsReturnType } from 'wagmi'

Action [‚Äã](#action)
-------------------

*   [`getConnections`](https://wagmi.sh/core/api/actions/getConnections)
*   [`watchConnections`](https://wagmi.sh/core/api/actions/watchConnections)</content>
</page>

<page>
  <title>useConnectors | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useConnectors</url>
  <content>Composable for getting configured connectors.

Import [‚Äã](#import)
-------------------

ts

    import { useConnectors } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnectors } from '@wagmi/vue'
    
    const connectors = useConnectors()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseConnectorsReturnType } from '@wagmi/vue'

`readonly Connector[]`

Connectors from [`config.connectors`](https://wagmi.sh/vue/api/createConfig#connectors-1).

Action [‚Äã](#action)
-------------------

*   [`getConnectors`](https://wagmi.sh/core/api/actions/getConnectors)</content>
</page>

<page>
  <title>useDisconnect | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useDisconnect</url>
  <content>Composable for disconnecting connections.

Import [‚Äã](#import)
-------------------

ts

    import { useDisconnect } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useDisconnect } from '@wagmi/vue'
    
    const { disconnect } = useDisconnect()
    </script>
    
    <template>
      <button @click="disconnect()">
        Disconnect
      </button>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseDisconnectParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useDisconnect } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useDisconnect({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`disconnect`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: DisconnectErrorType, variables: { connector?: Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: { connector?: Connector | undefined; }) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: void, variables: { connector?: Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: void, error: DisconnectErrorType, variables: { connector?: Connector | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: DisconnectErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: DisconnectErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseDisconnectReturnType } from '@wagmi/vue'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Connectors that are currently connected. Useful for rendering a list of connectors to disconnect.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useDisconnect } from '@wagmi/vue'
    import { mainnet } from 'wagmi/chains'
    
    const { connectors, disconnect } = useDisconnect()
    </script>
    
    <template>
      <div>
        <button v-for="connector in connectors" :key="connector.id" @click="disconnect({ connector })">
          {{ connector.name }}
        </button>
      </div>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### disconnect [‚Äã](#mutate)

`(variables: { connector?: Connector | undefined; }, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `{ connector?: Connector | undefined; }`
    
    The variables object to pass to the [`disconnect`](https://wagmi.sh/core/api/actions/disconnect#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: void, variables: { connector?: Connector | undefined; }, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: DisconnectErrorType, variables: { connector?: Connector | undefined; }, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: void | undefined, error: DisconnectErrorType | null, variables: { connector?: Connector | undefined; }, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### disconnectAsync [‚Äã](#mutate-async)

`(variables: { connector?: Connector | undefined; }, { onSuccess, onSettled, onError }) => Promise<void>`

Similar to [`disconnect`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`void | undefined`

*   [`disconnect` return type](https://wagmi.sh/core/api/actions/disconnect#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`DisconnectErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`DisconnectErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`{ connector?: Connector | undefined; } | undefined`

*   The variables object passed to [`disconnect`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type DisconnectData,
      type DisconnectVariables,
      type DisconnectMutate,
      type DisconnectMutateAsync,
      disconnectMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`disconnect`](https://wagmi.sh/core/api/actions/connect)</content>
</page>

<page>
  <title>useEnsAvatar | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useEnsAvatar</url>
  <content>Composable for fetching ENS avatar for name.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsAvatar } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAvatar`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsAvatarParameters } from '@wagmi/vue'

* * *

### assetGatewayUrls viem@>=2.3.1 [‚Äã](#assetgatewayurls)

`{ ipfs?: string | undefined; arweave?: string | undefined } | undefined`

Gateway urls to resolve IPFS and/or Arweave assets.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { getEnsAvatar } from '@wagmi/core'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const result = useEnsAvatar({
      assetGatewayUrls: { 
        ipfs: 'https://cloudflare-ipfs.com', 
      }, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS avatar at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      blockNumber: 17829139n, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS avatar at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      name: normalize('wevm.eth'),
      blockTag: 'latest', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { mainnet } from 'wagmi/chains'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      chainId: mainnet.id, // [!code focus],
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const result = useEnsAvatar({
      config, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gatewayUrls [‚Äã](#gatewayurls)

`string[] | undefined`

A set of Universal Resolver gateways, used for resolving CCIP-Read requests made through the ENS Universal Resolver Contract.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      gatewayUrls: ['https://cloudflare-ipfs.com'], 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string | undefined`

Name to get the avatar for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      name: normalize('wevm.eth'), 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      name: normalize('wevm.eth'),
      scopeKey: 'foo', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAvatar } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAvatar({
      name: normalize('wevm.eth'),
      universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | null | (() => string | null) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | null | ((previousValue: string | null | undefined; previousQuery: Query | undefined) => string | null) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | null | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsAvatarErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsAvatarErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string | null) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | null | undefined, newData: string | null) => string | null)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsAvatarReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string | null`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsAvatarErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsAvatarErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string | null, GetEnsAvatarErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsAvatarData,
      type GetEnsAvatarOptions,
      type GetEnsAvatarQueryFnData,
      type GetEnsAvatarQueryKey,
      getEnsAvatarQueryKey,
      getEnsAvatarQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsAvatar`](https://wagmi.sh/core/api/actions/getEnsAvatar)</content>
</page>

<page>
  <title>useEnsAddress | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useEnsAddress</url>
  <content>Composable for fetching ENS address for name.

Import [‚Äã](#import)
-------------------

ts

    import { useEnsAddress } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

WARNING

Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `useEnsAddress`. You can use Viem's built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEnsAddressParameters } from '@wagmi/vue'

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get ENS address at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      blockNumber: 17829139n, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get ENS address at.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      name: normalize('wevm.eth'),
      blockTag: 'latest', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      chainId: mainnet.id, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### coinType [‚Äã](#cointype)

`number | undefined`

The [ENSIP-9](https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution) coin type to fetch the address for.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      coinType: 60, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    import { config } from './config'
    
    const result = useEnsAddress({
      config, 
      name: normalize('wevm.eth'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### name [‚Äã](#name)

`string | undefined`

Name to get the address for. [`enabled`](#enabled) set to `false` if `name` is `undefined`.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      name: normalize('wevm.eth'), 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      name: normalize('wevm.eth'),
      scopeKey: 'foo', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### universalResolverAddress [‚Äã](#universalresolveraddress)

`Address | undefined`

*   Address of ENS Universal Resolver Contract.
*   Defaults to current chain's Universal Resolver Contract address.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEnsAddress } from '@wagmi/vue'
    import { normalize } from 'viem/ens'
    
    const result = useEnsAddress({
      name: normalize('wevm.eth'),
      universalResolverAddress: '0x74E20Bd2A1fE0cdbe45b9A1d89cb7e0a45b36376', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`string | (() => string) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`string | ((previousValue: string | undefined; previousQuery: Query | undefined) => string) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: string | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetEnsAddressErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetEnsAddressErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: string) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: string | undefined, newData: string) => string)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEnsAddressReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`string`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetEnsAddressErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetEnsAddressErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<string, GetEnsAddressErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetEnsAddressData,
      type GetEnsAddressOptions,
      type GetEnsAddressQueryFnData,
      type GetEnsAddressQueryKey,
      getEnsAddressQueryKey,
      getEnsAddressQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getEnsAddress`](https://wagmi.sh/core/api/actions/getEnsAddress)</content>
</page>

<page>
  <title>Write to Contract | Wagmi</title>
  <url>https://wagmi.sh/vue/guides/write-to-contract</url>
  <content>The [`useWriteContract` Composable](https://wagmi.sh/vue/api/composables/useWriteContract) allows you to mutate data on a smart contract, from a `payable` or `nonpayable` (write) function. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

In the guide below, we will teach you how to implement a "Mint NFT" form that takes in a dynamic argument (token ID) using Wagmi. The example below builds on the [Connect Wallet guide](https://wagmi.sh/vue/guides/connect-wallet) and uses the [useWriteContract](https://wagmi.sh/vue/api/composables/useWriteContract) & [useWaitForTransaction](https://wagmi.sh/vue/api/composables/useWaitForTransactionReceipt) composables.

If you have already completed the [Sending Transactions guide](https://wagmi.sh/vue/guides/send-transaction), this guide will look very similar! That's because writing to a contract internally broadcasts & sends a transaction.

Example [‚Äã](#example)
---------------------

Feel free to check out the example before moving on:

Steps [‚Äã](#steps)
-----------------

### 1\. Connect Wallet [‚Äã](#_1-connect-wallet)

Follow the [Connect Wallet guide](https://wagmi.sh/vue/guides/connect-wallet) guide to get this set up.

### 2\. Create a new component [‚Äã](#_2-create-a-new-component)

Create your `MintNft` component that will contain the Mint NFT logic.

MintNft.vue

vue

    <script setup lang="ts">
    </script>
     
    <template>
      <form>
        <input name="tokenId" placeholder="69420" required />
        <button type="submit">Mint</button>
      </form>
    </template>

### 3\. Add a form handler [‚Äã](#_3-add-a-form-handler)

Next, we will need to add a handler to the form that will send the transaction when the user hits "Mint". This will be a basic handler in this step.

MintNft.vue

vue

    <script setup lang="ts">
    function submit(event: Event) {
      const formData = new FormData(e.target as HTMLFormElement)
      const tokenId = formData.get('tokenId') as string
    }
    </script>
    
    <template
      <form>
      <form @submit.prevent="submit">
        <input name="tokenId" placeholder="69420" required />
        <button type="submit">Mint</button>
      </form>
    </template>

### 4\. Hook up the `useWriteContract` Composable [‚Äã](#_4-hook-up-the-usewritecontract-composable)

Now that we have the form handler, we can hook up the [`useWriteContract` Composable](https://wagmi.sh/vue/api/composables/useWriteContract) to send the transaction.

MintNft.vueabi.ts

vue

    <script setup lang="ts">
    import { useWriteContract } from 'wagmi'
    import { abi } from './abi'
    
    const { data: hash, writeContract } = useWriteContract()
    
    function submit(event: Event) { 
      const formData = new FormData(e.target as HTMLFormElement) 
      const tokenId = formData.get('tokenId') as string 
      writeContract({ 
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', 
        abi, 
        functionName: 'mint', 
        args: [BigInt(tokenId)], 
      })
    } 
    </script>
    
    <template
      <form @submit.prevent="submit"> 
        <input name="tokenId" placeholder="69420" required />
        <button type="submit">Mint</button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
      </form>
    </template>

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 5\. Add loading state (optional) [‚Äã](#_5-add-loading-state-optional)

We can optionally add a loading state to the "Mint" button while we are waiting confirmation from the user's wallet.

MintNft.vueabi.ts

vue

    <script setup lang="ts">
    import { useWriteContract } from 'wagmi'
    import { abi } from './abi'
    
    const { 
      data: hash, 
      isPending,
      writeContract 
    } = useWriteContract()
    
    function submit(event: Event) { 
      const formData = new FormData(e.target as HTMLFormElement) 
      const tokenId = formData.get('tokenId') as string 
      writeContract({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        abi,
        functionName: 'mint',
        args: [BigInt(tokenId)],
      })
    } 
    </script>
    
    <template
      <form @submit.prevent="submit"> 
        <input name="tokenId" placeholder="69420" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
      </form>
    </template>

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 6\. Wait for transaction receipt (optional) [‚Äã](#_6-wait-for-transaction-receipt-optional)

We can also display the transaction confirmation status to the user by using the [`useWaitForTransactionReceipt` Composable](https://wagmi.sh/vue/api/composables/useWaitForTransactionReceipt).

MintNft.vueabi.ts

vue

    <script setup lang="ts">
    import { 
      useWaitForTransactionReceipt,
      useWriteContract 
    } from 'wagmi'
    import { abi } from './abi'
    
    const { 
      data: hash, 
      isPending,
      writeContract 
    } = useWriteContract()
    
    function submit(event: Event) { 
      const formData = new FormData(e.target as HTMLFormElement) 
      const tokenId = formData.get('tokenId') as string 
      writeContract({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        abi,
        functionName: 'mint',
        args: [BigInt(tokenId)],
      })
    } 
    
    const { isLoading: isConfirming, isSuccess: isConfirmed } =
      useWaitForTransactionReceipt({ 
        hash, 
      })
    </script>
    
    <template
      <form @submit.prevent="submit"> 
        <input name="tokenId" placeholder="69420" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
        <div v-if="isConfirming">Waiting for confirmation...</div>
        <div v-if="isConfirmed">Transaction Confirmed!</div>
      </form>
    </template>

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 7\. Handle errors (optional) [‚Äã](#_7-handle-errors-optional)

If the user rejects the transaction, or the user does not have enough funds to cover the transaction, we can display an error message to the user.

MintNft.vueabi.ts

vue

    <script setup lang="ts">
    import { 
      useWaitForTransactionReceipt,
      useWriteContract 
    } from 'wagmi'
    import { abi } from './abi'
    
    const { 
      data: hash,
      error,
      isPending,
      writeContract 
    } = useWriteContract()
    
    function submit(event: Event) { 
      const formData = new FormData(e.target as HTMLFormElement) 
      const tokenId = formData.get('tokenId') as string 
      writeContract({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        abi,
        functionName: 'mint',
        args: [BigInt(tokenId)],
      })
    } 
    
    const { isLoading: isConfirming, isSuccess: isConfirmed } =
      useWaitForTransactionReceipt({
        hash,
      })
    </script>
    
    <template
      <form @submit.prevent="submit"> 
        <input name="tokenId" placeholder="69420" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
        <div v-if="isConfirming">Waiting for confirmation...</div>
        <div v-if="isConfirmed">Transaction Confirmed!</div>
        <div v-if="error">
          Error: {{ (error as BaseError).shortMessage || error.message }}
        </div>
      </form>
    </template>

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

### 8\. Wire it up! [‚Äã](#_8-wire-it-up)

Finally, we can wire up our Send Transaction component to our application's entrypoint.

App.vueMintNft.vueabi.ts

vue

    <script setup lang="ts">
    import { useAccount } from '@wagmi/vue';
    import Account from './Account.vue';
    import Connect from './Connect.vue';
    import MintNft from './MintNft.vue';
    
    const { isConnected } = useAccount();
    </script>
    
    <template>
      <Account v-if="isConnected" />
      <Connect v-else />
      <MintNft v-if="isConnected" />
    </template>

vue

    <script setup lang="ts">
    import { 
      useWaitForTransactionReceipt,
      useWriteContract 
    } from 'wagmi'
    import { abi } from './abi'
    
    const { 
      data: hash,
      error, 
      isPending,
      writeContract 
    } = useWriteContract()
    
    function submit(event: Event) { 
      const formData = new FormData(e.target as HTMLFormElement) 
      const tokenId = formData.get('tokenId') as string 
      writeContract({
        address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
        abi,
        functionName: 'mint',
        args: [BigInt(tokenId)],
      })
    } 
    
    const { isLoading: isConfirming, isSuccess: isConfirmed } =
      useWaitForTransactionReceipt({
        hash,
      })
    </script>
    
    <template
      <form @submit.prevent="submit"> 
        <input name="tokenId" placeholder="69420" required />
        <button :disabled="isPending" type="submit">
          <span v-if="isPending">Sending...</span>
          <span v-else>Send</span>
        </button>
        <div v-if="hash">Transaction Hash: {{ hash }}</div>
        <div v-if="isConfirming">Waiting for confirmation...</div>
        <div v-if="isConfirmed">Transaction Confirmed!</div>
        <div v-if="error">
          Error: {{ (error as BaseError).shortMessage || error.message }}
        </div>
      </form>
    </template>

ts

    export const abi = [
      {
        name: 'mint',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ internalType: 'uint32', name: 'tokenId', type: 'uint32' }],
        outputs: [],
      },
    ] as const

[See the Example.](#example)</content>
</page>

<page>
  <title>useSendTransaction | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useSendTransaction</url>
  <content>Composable for creating, signing, and sending transactions to networks.

Import [‚Äã](#import)
-------------------

ts

    import { useSendTransaction } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSendTransaction } from '@wagmi/vue'
    import { parseEther } from 'viem'
    
    const { sendTransaction } = useSendTransaction()
    </script>
    
    <template>
      <button
        @click="sendTransaction({
          to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          value: parseEther('0.01')
        })"
      >
        Send transaction
      </button>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSendTransactionParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSendTransaction } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useSendTransaction({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`sendTransaction`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SendTransactionErrorType, variables: SendTransactionVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SendTransactionVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SendTransactionData, variables: SendTransactionVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SendTransactionData, error: SendTransactionErrorType, variables: SendTransactionVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SendTransactionErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SendTransactionErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSendTransactionReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### sendTransaction [‚Äã](#mutate)

`(variables: SendTransactionVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SendTransactionVariables`
    
    The variables object to pass to the [`sendTransaction`](https://wagmi.sh/core/api/actions/sendTransaction#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SendTransactionData, variables: SendTransactionVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SendTransactionErrorType, variables: SendTransactionVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SendTransactionData | undefined, error: SendTransactionErrorType | null, variables: SendTransactionVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### sendTransactionAsync [‚Äã](#mutate-async)

`(variables: SendTransactionVariables, { onSuccess, onSettled, onError }) => Promise<SendTransactionData>`

Similar to [`sendTransaction`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SendTransactionData | undefined`

*   [`sendTransaction` return type](https://wagmi.sh/core/api/actions/sendTransaction#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SendTransactionErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SendTransactionErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SendTransactionVariables | undefined`

*   The variables object passed to [`sendTransaction`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SendTransactionData,
      type SendTransactionVariables,
      type SendTransactionMutate,
      type SendTransactionMutateAsync,
      sendTransactionMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`sendTransaction`](https://wagmi.sh/core/api/actions/sendTransaction)</content>
</page>

<page>
  <title>useReadContract | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useReadContract</url>
  <content>Composable for calling a **read-only** function on a contract, and returning the response.

A **read-only** function (constant function) on a Solidity contract is denoted by a pure or view keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.

Import [‚Äã](#import)
-------------------

ts

    import { useReadContract } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseReadContractParameters } from '@wagmi/vue'

### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi, 
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Account | undefined`

Account to use when calling the contract (`msg.sender`).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf',
      args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'totalSupply',
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf',
      args: ['0x6b175474e89094c44da98b954eedeac495271d0f'], 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to call contract at.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      blockNumber: 17829139n, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      blockTag: 'safe', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      chainId: mainnet.id, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'totalSupply',
      config, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf', 
      args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useReadContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useReadContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'balanceOf',
      args: ['0x6b175474e89094c44da98b954eedeac495271d0f'],
      scopeKey: 'foo', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: 'supply', type: 'uint256' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`ReadContractReturnType | (() => ReadContractReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`ReadContractReturnType | ((previousValue: ReadContractReturnType | undefined; previousQuery: Query | undefined) => ReadContractReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: ReadContractReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ReadContractErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ReadContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: ReadContractReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: ReadContractReturnType | undefined, newData: ReadContractReturnType) => ReadContractReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseReadContractReturnType } from '@wagmi/vue'

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) for more info.

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`ReadContractReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | ReadContractErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | ReadContractErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<ReadContractReturnType, ReadContractErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and the return type. See the Wagmi [TypeScript docs](https://wagmi.sh/vue/typescript) for more information.

InlineConst-Asserted

ts

    const  = ({
      : [
        {
          : 'function',
          : 'balanceOf',
          : 'view',
          : [{ : 'account', : 'address' }],
          : [{ : 'uint256' }],
        },
        {
          : 'function',
          : 'totalSupply',
          : 'view',
          : [],
          : [{ : 'supply', : 'uint256' }],
        },
      ],
      : '0x6b175474e89094c44da98b954eedeac495271d0f',
      : 'balanceOf',
    
    
      : ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    
    
    
    })
    
    .
    

ts

    const  = [
      {
        : 'function',
        : 'balanceOf',
        : 'view',
        : [{ : 'account', : 'address' }],
        : [{ : 'uint256' }],
      },
      {
        : 'function',
        : 'totalSupply',
        : 'view',
        : [],
        : [{ : 'supply', : 'uint256' }],
      },
    ] as 
    
    const  = ({
      ,
      : '0x6b175474e89094c44da98b954eedeac495271d0f',
      : 'balanceOf',
    
    
      : ['0x6b175474e89094c44da98b954eedeac495271d0f'],
    })
    
    .
    

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReadContractData,
      type ReadContractOptions,
      type ReadContractQueryFnData,
      type ReadContractQueryKey,
      readContractQueryKey,
      readContractQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`readContract`](https://wagmi.sh/core/api/actions/readContract)</content>
</page>

<page>
  <title>useReconnect | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useReconnect</url>
  <content>Composable for reconnecting [connectors](https://wagmi.sh/core/api/connectors).

Import [‚Äã](#import)
-------------------

ts

    import { useReconnect } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vue

vue

    <script setup lang="ts">
    import { useReconnect } from '@wagmi/vue'
    import { useEffect } from 'react'
    
    const { reconnect } = useReconnect()
    
    reconnect()
    </script>

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseReconnectParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useReconnect } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useReconnect({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`reconnect`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: ReconnectErrorType, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }, error: ReconnectErrorType, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: ReconnectErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: ReconnectErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseReconnectReturnType } from '@wagmi/vue'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Globally configured connectors via [`createConfig`](https://wagmi.sh/vue/api/createConfig#connectors).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useReconnect } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    const { reconnect, connectors } = useReconnect()
    
    reconnect({ connectors })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### reconnect [‚Äã](#mutate)

`(variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `{ connectors?: (CreateConnectorFn | Connector)[] | undefined; }`
    
    The variables object to pass to the [`reconnect`](https://wagmi.sh/core/api/actions/reconnect#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: ReconnectErrorType, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: { accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector } | undefined, error: ReconnectErrorType | null, variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### reconnectAsync [‚Äã](#mutate-async)

`(variables: { connectors?: (CreateConnectorFn | Connector)[] | undefined; }, { onSuccess, onSettled, onError }) => Promise<{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector }>`

Similar to [`reconnect`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`{ accounts: readonly [Address, ...Address[]]; chainId: number; connector: Connector } | undefined`

*   [`reconnect` return type](https://wagmi.sh/core/api/actions/reconnect#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`ReconnectErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`ReconnectErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`{ connectors?: (CreateConnectorFn | Connector)[] | undefined; } | undefined`

*   The variables object passed to [`reconnect`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type ReconnectData,
      type ReconnectVariables,
      type ReconnectMutate,
      type ReconnectMutateAsync,
      reconnectMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`reconnect`](https://wagmi.sh/core/api/actions/reconnect)</content>
</page>

<page>
  <title>useSignMessage | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useSignMessage</url>
  <content>Composable for signing messages.

Import [‚Äã](#import)
-------------------

ts

    import { useSignMessage } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSignMessage } from '@wagmi/vue'
    
    const { signMessage } = useSignMessage()
    </script>
    
    <template>
      <button @click="signMessage({ message: 'hello world' })">
        Sign message
      </button>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSignMessageParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSignMessage } from '@wagmi/vue'
    import { config } from './config'
    
    const { signMessage } = useSignMessage({
      config
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`signMessage`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SignMessageErrorType, variables: SignMessageVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SignMessageVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SignMessageData, variables: SignMessageVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SignMessageData, error: SignMessageErrorType, variables: SignMessageVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SignMessageErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SignMessageErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSignMessageReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### signMessage [‚Äã](#mutate)

`(variables: SignMessageVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SignMessageVariables`
    
    The variables object to pass to the [`signMessage`](https://wagmi.sh/core/api/actions/signMessage#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SignMessageData, variables: SignMessageVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SignMessageErrorType, variables: SignMessageVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SignMessageData | undefined, error: SignMessageErrorType | null, variables: SignMessageVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### signMessageAsync [‚Äã](#mutate-async)

`(variables: SignMessageVariables, { onSuccess, onSettled, onError }) => Promise<SignMessageData>`

Similar to [`signMessage`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SignMessageData | undefined`

*   [`signMessage` return type](https://wagmi.sh/core/api/actions/signMessage#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SignMessageErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SignMessageErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SignMessageVariables | undefined`

*   The variables object passed to [`signMessage`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SignMessageData,
      type SignMessageVariables,
      type SignMessageMutate,
      type SignMessageMutateAsync,
      signMessageMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`signMessage`](https://wagmi.sh/core/api/actions/signMessage)</content>
</page>

<page>
  <title>useSignTypedData | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useSignTypedData</url>
  <content>Composable for signing typed data and calculating an Ethereum-specific [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature.

Import [‚Äã](#import)
-------------------

ts

    import { useSignTypedData } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSignTypedData } from '@wagmi/vue'
    
    const { signTypedData } = useSignTypedData()
    </script>
    
    <template>
      <button
        @click="signTypedData({
          types: {
            Person: [
              { name: 'name', type: 'string' },
              { name: 'wallet', type: 'address' },
            ],
            Mail: [
              { name: 'from', type: 'Person' },
              { name: 'to', type: 'Person' },
              { name: 'contents', type: 'string' },
            ],
          },
          primaryType: 'Mail',
          message: {
            from: {
              name: 'Cow',
              wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
            },
            to: {
              name: 'Bob',
              wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
            },
            contents: 'Hello, Bob!',
          },
        })"
      >
        Sign message
      </button>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSignTypedDataParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSignTypedData } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useSignTypedData({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`signTypedData`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SignTypedDataErrorType, variables: SignTypedDataVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SignTypedDataVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SignTypedDataData, variables: SignTypedDataVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SignTypedDataData, error: SignTypedDataErrorType, variables: SignTypedDataVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SignTypedDataErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SignTypedDataErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSignTypedDataReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### signTypedData [‚Äã](#mutate)

`(variables: SignTypedDataVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SignTypedDataVariables`
    
    The variables object to pass to the [`signTypedData`](https://wagmi.sh/core/api/actions/signTypedData#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SignTypedDataData, variables: SignTypedDataVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SignTypedDataErrorType, variables: SignTypedDataVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SignTypedDataData | undefined, error: SignTypedDataErrorType | null, variables: SignTypedDataVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### signTypedDataAsync [‚Äã](#mutate-async)

`(variables: SignTypedDataVariables, { onSuccess, onSettled, onError }) => Promise<SignTypedDataData>`

Similar to [`signTypedData`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SignTypedDataData | undefined`

*   [`signTypedData` return type](https://wagmi.sh/core/api/actions/signTypedData#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SignTypedDataErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SignTypedDataErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SignTypedDataVariables | undefined`

*   The variables object passed to [`signTypedData`](#mutate).
*   Defaults to `undefined`.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`types`](https://wagmi.sh/core/api/actions/signTypedData#types) setup correctly, TypeScript will infer the correct types for [`domain`](https://wagmi.sh/core/api/actions/signTypedData#domain), [`message`](https://wagmi.sh/core/api/actions/signTypedData#message), and [`primaryType`](https://wagmi.sh/core/api/actions/signTypedData#primarytype). See the Wagmi [TypeScript docs](https://wagmi.sh/vue/typescript) for more information.

InlineConst-Asserted

ts

    const {  } = ()
    
    ({
      : {
        : [
          { : 'name', : 'string' },
          { : 'wallet', : 'address' },
        ],
        : [
          { : 'from', : 'Person' },
          { : 'to', : 'Person' },
          { : 'contents', : 'string' },
        ],
      },
      : 'Mail',
    
    
      : {
    
    
    
    
    
    
    
    
    
    
    
    
        : {
          : 'Cow',
          : '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        : {
          : 'Bob',
          : '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        : 'Hello, Bob!',
      },
    })

ts

    const  = {
      : [
        { : 'name', : 'string' },
        { : 'wallet', : 'address' },
      ],
      : [
        { : 'from', : 'Person' },
        { : 'to', : 'Person' },
        { : 'contents', : 'string' },
      ],
    } as 
    
    const {  } = ()
    
    ({
      ,
      : 'Mail',
    
    
      : {
    
    
    
    
    
    
    
    
    
    
    
    
        : {
          : 'Cow',
          : '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        : {
          : 'Bob',
          : '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        : 'Hello, Bob!',
      },
    })

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SignTypedDataData,
      type SignTypedDataVariables,
      type SignTypedDataMutate,
      type SignTypedDataMutateAsync,
      signTypedDataMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`signTypedData`](https://wagmi.sh/core/api/actions/signTypedData)</content>
</page>

<page>
  <title>useEstimateGas | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useEstimateGas</url>
  <content>Composable for estimating the gas necessary to complete a transaction without submitting it to the network.

Import [‚Äã](#import)
-------------------

ts

    import { useEstimateGas } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    
    const result = useEstimateGas()
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseEstimateGasParameters } from '@wagmi/vue'

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      accessList: [{ 
        address: '0x1', 
        storageKeys: ['0x1'], 
      }], 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Address | Account | undefined`

Account to use when estimating gas.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

Chain ID to target when estimating gas.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      chainId: mainnet.id, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

Connector to estimate with. If no [`account`](#account) is provided, will use default account from connector.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useConnections, useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const connections = useConnections()
    const result = useEstimateGas({
      connector: connections[0]?.connector, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### data [‚Äã](#data)

`` `0x${string}` | undefined ``

A contract hashed method call with encoded function data.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      gas: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      gasPrice: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      maxFeePerGas: parseGwei('20'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther, parseGwei } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      nonce: 123, 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      scopeKey: 'foo', 
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### to [‚Äã](#to)

`Address | undefined`

The transaction recipient or contract address.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
      type: 'eip1559', 
      value: parseEther('0.01'),
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useEstimateGas } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { config } from './config'
    
    const result = useEstimateGas({
      to: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
      value: parseEther('0.01'), 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`bigint | (() => bigint) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`bigint | ((previousValue: bigint | undefined; previousQuery: Query | undefined) => bigint) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: bigint | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: EstimateGasErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: EstimateGasErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: bigint) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: bigint | undefined, newData: bigint) => bigint)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseEstimateGasReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data-1)

`bigint`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | EstimateGasErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | EstimateGasErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<bigint, EstimateGasErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type EstimateGasData,
      type EstimateGasOptions,
      type EstimateGasQueryFnData,
      type EstimateGasQueryKey,
      estimateGasQueryKey,
      estimateGasQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`estimateGas`](https://wagmi.sh/core/api/actions/estimateGas)</content>
</page>

<page>
  <title>useSwitchAccount | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useSwitchAccount</url>
  <content>Composable for switching the current account.

Import [‚Äã](#import)
-------------------

ts

    import { useSwitchAccount } from 'wagmi'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSwitchAccount } from 'wagmi'
    
    const { connectors, switchAccount } = useSwitchAccount()
    </script>
    
    <template>
      <div>
        <button 
          v-for="connector in connectors" 
          :key="connector.id" 
          @click="switchAccount({ connector })"
        >
          {{ connector.name }}
        </button>
      </div>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSwitchAccountParameters } from 'wagmi'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSwitchAccount } from 'wagmi'
    import { config } from './config'
    
    const result = useSwitchAccount({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`switchAccount`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SwitchAccountErrorType, variables: SwitchAccountVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SwitchAccountVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SwitchAccountData, variables: SwitchAccountVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SwitchAccountData, error: SwitchAccountErrorType, variables: SwitchAccountVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SwitchAccountErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SwitchAccountErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSwitchAccountReturnType } from 'wagmi'

### connectors [‚Äã](#connectors)

`readonly Connector[]`

Globally configured and actively connected connectors. Useful for rendering a list of available connectors to switch to.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSwitchAccount } from 'wagmi'
    
    const { connectors, switchAccount } = useSwitchAccount()
    </script>
    
    <template>
      <div>
        <button 
          v-for="connector in connectors" 
          :key="connector.id" 
          @click="switchAccount({ connector })"
        >
          {{ connector.name }}
        </button>
      </div>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### switchAccount [‚Äã](#mutate)

`(variables: SwitchAccountVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SwitchAccountVariables`
    
    The variables object to pass to the [`switchAccount`](https://wagmi.sh/core/api/actions/switchAccount#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SwitchAccountData, variables: SwitchAccountVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SwitchAccountErrorType, variables: SwitchAccountVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SwitchAccountData | undefined, error: SwitchAccountErrorType | null, variables: SwitchAccountVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### switchAccountAsync [‚Äã](#mutate-async)

`(variables: SwitchAccountVariables, { onSuccess, onSettled, onError }) => Promise<SwitchAccountData>`

Similar to [`switchAccount`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SwitchAccountData | undefined`

*   [`switchAccount` return type](https://wagmi.sh/core/api/actions/switchAccount#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SwitchAccountErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SwitchAccountErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SwitchAccountVariables | undefined`

*   The variables object passed to [`switchAccount`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SwitchAccountData,
      type SwitchAccountVariables,
      type SwitchAccountMutate,
      type SwitchAccountMutateAsync,
      switchAccountMutationOptions,
    } from 'wagmi/query'

Action [‚Äã](#action)
-------------------

*   [`switchAccount`](https://wagmi.sh/core/api/actions/switchAccount)</content>
</page>

<page>
  <title>useSwitchChain | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useSwitchChain</url>
  <content>Composable for switching the target chain for a connector or the Wagmi [`Config`](https://wagmi.sh/vue/api/createConfig#config).

Import [‚Äã](#import)
-------------------

ts

    import { useSwitchChain } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSwitchChain } from '@wagmi/vue'
    
    const { chains, switchChain } = useSwitchChain()
    </script>
    
    <template>
      <div>
        <button 
          v-for="chain in chains" 
          :key="chain.id" 
          @click="switchChain({ chainId: chain.id })"
        >
          {{ chain.name }}
        </button>
      </div>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

TIP

When connected, `switchChain` will switch the target chain for the connector. When not connected, `switchChain` will switch the target chain for the Wagmi [`Config`](https://wagmi.sh/vue/api/createConfig#config).

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSwitchChainParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSwitchChain } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useSwitchChain({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`switchChain`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: SwitchChainErrorType, variables: SwitchChainVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: SwitchChainVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: SwitchChainData, variables: SwitchChainVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: SwitchChainData, error: SwitchChainErrorType, variables: SwitchChainVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SwitchChainErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SwitchChainErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSwitchChainReturnType } from '@wagmi/vue'

### chains [‚Äã](#chains)

`readonly [Chain, ...Chain[]]`

Globally configured chains. Useful for rendering a list of available chains to switch to.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useSwitchChain } from '@wagmi/vue'
    
    const { chains, switchChain } = useSwitchChain()
    </script>
    
    <template>
      <div>
        <button 
          v-for="chain in chains" 
          :key="chain.id" 
          @click="switchChain({ chainId: chain.id })"
        >
          {{ chain.name }}
        </button>
      </div>
    </template>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### switchChain [‚Äã](#mutate)

`(variables: SwitchChainVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `SwitchChainVariables`
    
    The variables object to pass to the [`switchChain`](https://wagmi.sh/core/api/actions/switchChain#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: SwitchChainData, variables: SwitchChainVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: SwitchChainErrorType, variables: SwitchChainVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: SwitchChainData | undefined, error: SwitchChainErrorType | null, variables: SwitchChainVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### switchChainAsync [‚Äã](#mutate-async)

`(variables: SwitchChainVariables, { onSuccess, onSettled, onError }) => Promise<SwitchChainData>`

Similar to [`switchChain`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`SwitchChainData | undefined`

*   [`switchChain` return type](https://wagmi.sh/core/api/actions/switchChain#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`SwitchChainErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`SwitchChainErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`SwitchChainVariables | undefined`

*   The variables object passed to [`switchChain`](#mutate).
*   Defaults to `undefined`.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SwitchChainData,
      type SwitchChainVariables,
      type SwitchChainMutate,
      type SwitchChainMutateAsync,
      switchChainMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`switchChain`](https://wagmi.sh/core/api/actions/switchChain)</content>
</page>

<page>
  <title>useTransaction | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useTransaction</url>
  <content>Composable for fetching transactions given hashes or block identifiers.

Import [‚Äã](#import)
-------------------

ts

    import { useTransaction } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    
    const result = useTransaction({
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTransactionParameters } from '@wagmi/vue'

* * *

### blockHash [‚Äã](#blockhash)

`bigint | undefined`

Block hash to get transaction at (with [`index`](#index)).

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    
    const result = useTransaction({
      blockHash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
      index: 0,
    })
    </script>

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to get transaction at (with [`index`](#index)).

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    
    const result = useTransaction({
      blockNumber: 17829139n, 
      index: 0,
    })
    </script>

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to get transaction at (with [`index`](#index)).

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    
    const result = useTransaction({
      blockTag: 'safe', 
      index: 0,
    })
    </script>

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    import { mainnet } from 'wagmi/chains'
    
    const result = useTransaction({
      chainId: mainnet.id, 
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
    })
    </script>

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useTransaction({
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5',
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

Hash to get transaction. [`enabled`](#enabled) set to `false` if `hash` and [`index`](#index) are `undefined`.

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    
    const result = useTransaction({
      hash: '0x0fa64daeae54e207aa98613e308c2ba8abfe274f75507e741508cc4db82c8cb5', 
    })
    </script>

### index [‚Äã](#index)

`number | undefined`

An index to be used with a block identifier ([hash](#blockhash), [number](#blocknumber), or [tag](#blocktag)). [`enabled`](#enabled) set to `false` if `index` and [`hash`](#hash) are `undefined`.

vue

    <script setup lang="ts">
    import { useTransaction } from '@wagmi/vue'
    
    const result = useTransaction({
      blockTag: 'safe',
      index: 0
    })
    </script>

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetTransactionData | (() => GetTransactionData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetTransactionData | ((previousValue: GetTransactionData | undefined; previousQuery: Query | undefined) => GetTransactionData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetTransactionData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTransactionErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTransactionErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetTransactionData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetTransactionData | undefined, newData: GetTransactionData) => GetTransactionData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTransactionReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetTransactionData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTransactionErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTransactionErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetTransactionData, GetTransactionErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionData,
      type GetTransactionOptions,
      type GetTransactionQueryFnData,
      type GetTransactionQueryKey,
      getTransactionQueryKey,
      getTransactionQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getTransaction`](https://wagmi.sh/core/api/actions/getTransaction)</content>
</page>

<page>
  <title>useWatchBlockNumber | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useWatchBlockNumber</url>
  <content>Composable that watches for block number changes.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchBlockNumber } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

ts

    <script setup lang="ts">
    import { useWatchBlockNumber } from '@wagmi/vue'
    
    useWatchBlockNumber({
      onBlockNumber(blockNumber) {
        console.log('Block number changed!', blockNumber)
      },
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchBlockNumberParameters } from '@wagmi/vue'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to watch blocks at.

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

### emitMissed [‚Äã](#emitmissed)

`boolean`

Whether or not to emit missed blocks to the callback. Defaults to `false`.

Missed blocks may occur in instances where internet connection is lost, or the block time is lesser than the polling interval of the client.

### emitOnBegin [‚Äã](#emitonbegin)

`boolean`

Whether or not to emit the block to the callback when the subscription opens. Defaults to `false`.

### enabled [‚Äã](#enabled)

`boolean`

Whether or not to watch for blocks. Defaults to `true`.

### onBlockNumber [‚Äã](#onblocknumber)

`(block: Block, prevblock: Block | undefined) => void`

Callback for when block changes.

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block.

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchBlockNumberReturnType } from '@wagmi/vue'

Function for cleaning up watcher.

Action [‚Äã](#action)
-------------------

*   [`watchBlockNumber`](https://wagmi.sh/core/api/actions/watchBlockNumber)</content>
</page>

<page>
  <title>useTransactionReceipt | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useTransactionReceipt</url>
  <content>Composable for return the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.

Import [‚Äã](#import)
-------------------

ts

    import { useTransactionReceipt } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransactionReceipt } from '@wagmi/vue'
    
    const result = useTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseTransactionReceiptParameters } from '@wagmi/vue'

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

A transaction hash.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransactionReceipt } from '@wagmi/vue'
    
    const result = useTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

The ID of chain to return the transaction receipt from.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransactionReceipt } from '@wagmi/vue'
    import { mainnet } from 'wagmi/chains'
    
    const result = useTransactionReceipt({
      chainId: mainnet.id, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransactionReceipt } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useTransactionReceipt({
      config, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useTransactionReceipt } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useTransactionReceipt({
      scopeKey: 'foo'
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`GetTransactionReceiptData | (() => GetTransactionReceiptData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`GetTransactionReceiptData | ((previousValue: GetTransactionReceiptData | undefined; previousQuery: Query | undefined) => GetTransactionReceiptData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: GetTransactionReceiptData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: GetTransactionReceiptErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: GetTransactionReceiptErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: GetTransactionReceiptData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: GetTransactionReceiptData | undefined, newData: GetTransactionReceiptData) => GetTransactionReceiptData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseTransactionReceiptReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`GetTransactionReceiptData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | GetTransactionReceiptErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | GetTransactionReceiptErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<GetTransactionReceiptData, GetTransactionReceiptErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type GetTransactionReceiptData,
      type GetTransactionReceiptOptions,
      type GetTransactionReceiptQueryFnData,
      type GetTransactionReceiptQueryKey,
      getTransactionReceiptQueryKey,
      getTransactionReceiptQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`getTransactionReceipt`](https://wagmi.sh/core/api/actions/getTransactionReceipt)</content>
</page>

<page>
  <title>useWatchContractEvent | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useWatchContractEvent</url>
  <content>Composable that watches and returns emitted contract event logs.

Import [‚Äã](#import)
-------------------

ts

    import { useWatchContractEvent } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueabi.tsconfig.ts

ts

    <script setup lang="ts">
    import { useWatchContractEvent } from '@wagmi/vue'
    import { abi } from './abi'
    
    useWatchContractEvent({
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      abi,
      eventName: 'Transfer',
      onLogs(logs) {
        console.log('New logs!', logs)
      },
    })
    </script>

ts

    export const abi = [
      {
        type: 'event',
        name: 'Approval',
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
      {
        type: 'event',
        name: 'Transfer',
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' },
        ],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWatchContractEventParameters } from '@wagmi/vue'

### abi [‚Äã](#abi)

`Abi`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

### args [‚Äã](#args)

`object | readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`eventName`](#eventname).

### batch [‚Äã](#batch)

`boolean | undefined`

*   Whether or not the events should be batched on each invocation.
*   Defaults to `true`.

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/react/api/createConfig#config) to use instead of retrieving from the nearest [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider).

### eventName [‚Äã](#eventname)

`string`

*   Event to listen for the contract.
*   Inferred from [`abi`](#abi).

### onError [‚Äã](#onerror)

`((error: Error) => void) | undefined`

Error thrown from getting the block number.

### onLogs [‚Äã](#onlogs)

`(logs: Log[], prevLogs: Log[] | undefined) => void`

Callback for when logs changes.

### poll [‚Äã](#poll)

`boolean | undefined`

*   Whether or not to use a polling mechanism to check for new blocks instead of a WebSocket subscription.
*   Defaults to `false` for WebSocket Clients, and `true` for non-WebSocket Clients.

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/core/api/createConfig#pollinginterval).

### strict [‚Äã](#strict)

`boolean | undefined`

*   Defaults to `false`.

### syncConnectedChain [‚Äã](#syncconnectedchain)

`boolean | undefined`

*   Set up subscriber for connected chain changes.
*   Defaults to [`Config['syncConnectedChain']`](https://wagmi.sh/core/api/createConfig#syncconnectedchain).

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWatchContractEventReturnType } from '@wagmi/vue'

Hook returns `void`

Action [‚Äã](#action)
-------------------

*   [`watchContractEvent`](https://wagmi.sh/core/api/actions/watchContractEvent)</content>
</page>

<page>
  <title>useWaitForTransactionReceipt | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useWaitForTransactionReceipt</url>
  <content>Composable that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.

Import [‚Äã](#import)
-------------------

ts

    import { useWaitForTransactionReceipt } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    
    const result = useWaitForTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type WaitForTransactionReceiptParameters } from '@wagmi/core'

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    import { mainnet } from '@wagmi/vue/chains'
    
    const result = useWaitForTransactionReceipt({
      chainId: mainnet.id, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useWaitForTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### confirmations [‚Äã](#confirmations)

`number | undefined`

The number of confirmations (blocks that have passed) to wait before resolving.

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    
    const result = useWaitForTransactionReceipt({
      confirmations: 2, 
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
    })
    </script>

### onReplaced [‚Äã](#onreplaced)

`(({ reason: 'replaced' | 'repriced' | 'cancelled'; replacedTransaction: Transaction; transaction: Transaction; transactionReceipt: TransactionReceipt }) => void) | undefined`

Optional callback to emit if the transaction has been replaced.

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    
    const result = useWaitForTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      onReplaced: replacement => console.log(replacement), 
    })
    </script>

### pollingInterval [‚Äã](#pollinginterval)

`number | undefined`

*   Polling frequency (in milliseconds).
*   Defaults to the [Config's `pollingInterval` config](https://wagmi.sh/vue/api/createConfig#pollinginterval).

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    
    const result = useWaitForTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
      pollingInterval: 1_000, 
    })
    </script>

### hash [‚Äã](#hash)

`` `0x${string}` | undefined ``

The transaction hash to wait for. [`enabled`](#enabled) set to `false` if `hash` is `undefined`.

vue

    <script setup lang="ts">
    import { useWaitForTransactionReceipt } from '@wagmi/vue'
    
    const result = useWaitForTransactionReceipt({
      hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', 
    })
    </script>

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`WaitForTransactionReceiptData | (() => WaitForTransactionReceiptData) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`WaitForTransactionReceiptData | ((previousValue: WaitForTransactionReceiptData | undefined; previousQuery: Query | undefined) => WaitForTransactionReceiptData) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: WaitForTransactionReceiptData | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: WaitForTransactionReceiptErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: WaitForTransactionReceiptErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: WaitForTransactionReceiptData) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: WaitForTransactionReceiptData | undefined, newData: WaitForTransactionReceiptData) => WaitForTransactionReceiptData)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWaitForTransactionReceiptReturnType } from '@wagmi/vue'

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`WaitForTransactionReceiptData`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | WaitForTransactionReceiptErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | WaitForTransactionReceiptErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<WaitForTransactionReceiptData, WaitForTransactionReceiptErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WaitForTransactionReceiptData,
      type WaitForTransactionReceiptOptions,
      type WaitForTransactionReceiptQueryFnData,
      type WaitForTransactionReceiptQueryKey,
      waitForTransactionReceiptQueryKey,
      waitForTransactionReceiptQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`waitForTransactionReceipt`](https://wagmi.sh/core/api/actions/waitForTransactionReceipt)</content>
</page>

<page>
  <title>useWriteContract | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useWriteContract</url>
  <content>Composable for executing a write function on a contract.

A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, hence a transaction is broadcasted in order to change the state.

Import [‚Äã](#import)
-------------------

ts

    import { useWriteContract } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useWriteContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const { writeContract } = useWriteContract()
    </script>
    
    <template>
      <button @click="writeContract({ 
        abi,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f',
        functionName: 'transferFrom',
        args: [
          '0xd2135CfB216b74109775236E36d4b433F1DF507B',
          '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
          123n,
        ],
      })">
        Transfer
      </button>
    </template>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseWriteContractParameters } from '@wagmi/vue'

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { useWriteContract } from '@wagmi/vue'
    import { config } from './config'
    
    const result = useWriteContract({
      config, 
    })
    </script>

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### mutation [‚Äã](#mutation)

TanStack Query parameters. See the [TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `mutationFn` and `mutationKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/utils/query.ts#L30) to see what parameters are not supported. All parameters listed below are supported.

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   The time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever [`writeContract`](#mutate) is available (e.g. [`onError`](#onerror), [`onSuccess`](#onsuccess) functions).

#### networkMode [‚Äã](#networkmode)

`'online' | 'always' | 'offlineFirst' | undefined`

*   defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### onError [‚Äã](#onerror)

`((error: WriteContractErrorType, variables: WriteContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire if the mutation encounters an error and will be passed the error.

#### onMutate [‚Äã](#onmutate)

`((variables: WriteContractVariables) => Promise<context | void> | context | void) | undefined`

*   This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive
*   Useful to perform optimistic updates to a resource in hopes that the mutation succeeds
*   The value returned from this function will be passed to both the `onError` and `onSettled` functions in the event of a mutation failure and can be useful for rolling back optimistic updates.

#### onSuccess [‚Äã](#onsuccess)

`((data: WriteContractReturnType, variables: WriteContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is successful and will be passed the mutation's result.

#### onSettled [‚Äã](#onsettled)

`((data: WriteContractReturnType, error: WriteContractErrorType, variables: WriteContractVariables, context?: context | undefined) => Promise<unknown> | unknown) | undefined`

This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error

#### queryClient [‚Äã](#queryclient)

`QueryClient`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: WriteContractErrorType) => boolean) | undefined`

*   Defaults to `0`.
*   If `false`, failed mutations will not retry.
*   If `true`, failed mutations will retry infinitely.
*   If set to an `number`, e.g. `3`, failed mutations will retry until the failed mutations count meets that number.

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: WriteContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseWriteContractReturnType } from '@wagmi/vue'

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) for more info.

  

* * *

[TanStack Query mutation docs](https://tanstack.com/query/v5/docs/react/reference/useMutation)

### writeContract [‚Äã](#mutate)

`(variables: WriteContractVariables, { onSuccess, onSettled, onError }) => void`

The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.

*   #### variables [‚Äã](#variables)
    
    `WriteContractVariables`
    
    The variables object to pass to the [`writeContract`](https://wagmi.sh/core/api/actions/writeContract#parameters) action.
    
*   #### onSuccess [‚Äã](#onsuccess-1)
    
    `(data: WriteContractReturnType, variables: WriteContractVariables, context: TContext) => void`
    
    This function will fire when the mutation is successful and will be passed the mutation's result.
    
*   #### onError [‚Äã](#onerror-1)
    
    `(error: WriteContractErrorType, variables: WriteContractVariables, context: TContext | undefined) => void`
    
    This function will fire if the mutation encounters an error and will be passed the error.
    
*   #### onSettled [‚Äã](#onsettled-1)
    
    `(data: WriteContractReturnType | undefined, error: WriteContractErrorType | null, variables: WriteContractVariables, context: TContext | undefined) => void`
    
    *   This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error
    *   If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

### writeContractAsync [‚Äã](#mutate-async)

`(variables: WriteContractVariables, { onSuccess, onSettled, onError }) => Promise<WriteContractReturnType>`

Similar to [`writeContract`](#mutate) but returns a promise which can be awaited.

### data [‚Äã](#data)

`WriteContractReturnType | undefined`

*   [`writeContract` return type](https://wagmi.sh/core/api/actions/writeContract#return-type)
*   Defaults to `undefined`
*   The last successfully resolved data for the mutation.

### error [‚Äã](#error)

`WriteContractErrorType | null`

The error object for the mutation, if an error was encountered.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the mutation.
*   Incremented every time the mutation fails.
*   Reset to `0` when the mutation succeeds.

### failureReason [‚Äã](#failurereason)

`WriteContractErrorType | null`

*   The failure reason for the mutation retry.
*   Reset to `null` when the mutation succeeds.

### isError / isIdle / isPending / isSuccess [‚Äã](#iserror-isidle-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isPaused [‚Äã](#ispaused)

`boolean`

*   will be `true` if the mutation has been `paused`.
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### reset [‚Äã](#reset)

`() => void`

A function to clean the mutation internal state (e.g. it resets the mutation to its initial state).

### status [‚Äã](#status)

`'idle' | 'pending' | 'error' | 'success'`

*   `'idle'` initial status prior to the mutation function executing.
*   `'pending'` if the mutation is currently executing.
*   `'error'` if the last mutation attempt resulted in an error.
*   `'success'` if the last mutation attempt was successful.

### submittedAt [‚Äã](#submittedat)

`number`

*   The timestamp for when the mutation was submitted.
*   Defaults to `0`.

### variables [‚Äã](#variables-1)

`WriteContractVariables | undefined`

*   The variables object passed to [`writeContract`](#mutate).
*   Defaults to `undefined`.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](https://wagmi.sh/core/api/actions/writeContract#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](https://wagmi.sh/core/api/actions/writeContract#functionname), [`args`](https://wagmi.sh/core/api/actions/writeContract#args), and the [`value`](https://wagmi.sh/core/api/actions/writeContract##value). See the Wagmi [TypeScript docs](https://wagmi.sh/vue/typescript) for more information.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type WriteContractData,
      type WriteContractVariables,
      type WriteContractMutate,
      type WriteContractMutateAsync,
      writeContractMutationOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`writeContract`](https://wagmi.sh/core/api/actions/writeContract)</content>
</page>

<page>
  <title>Actions | Wagmi</title>
  <url>https://wagmi.sh/vue/api/actions</url>
  <content>Sometimes the declarative nature of Vue Composables doesn't work for parts of your app. For those cases, you can use Wagmi Core Actions directly!

All the Wagmi Core Actions are importable using the `@wagmi/vue/actions` entrypoint. For example, you can use the `watchBlockNumber` action to watch for block number changes.

index.vueconfig.ts

vue

    <script setup lang="ts">
    import { watchEffect } from 'vue'
    import { useConfig } from '@wagmi/vue'
    import { watchBlockNumber } from '@wagmi/vue/actions'
    
    const config = useConfig()
    
    watchEffect((onCleanup) => {
      const unwatch = watchBlockNumber(config, {
        onBlockNumber(blockNumber) {
          console.log('Block number changed!', blockNumber)
        },
      })
    
      onCleanup(unwatch)
    })
    </script>

ts

    import { http, createConfig } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

See the [Wagmi Core docs](https://wagmi.sh/core/api/actions) for more info on what actions are available.</content>
</page>

<page>
  <title>Errors | Wagmi</title>
  <url>https://wagmi.sh/vue/api/errors</url>
  <content>Error classes used by Wagmi.

BaseError [‚Äã](#baseerror)
-------------------------

Error class extended by all errors.

ts

    import { BaseError } from '@wagmi/vue'

Config [‚Äã](#config)
-------------------

### ConnectorAccountNotFoundError [‚Äã](#connectoraccountnotfounderror)

When an account does not exist on the connector or is unable to be used.

ts

    import { ConnectorAccountNotFoundError } from '@wagmi/vue'

### ConnectorAlreadyConnectedError [‚Äã](#connectoralreadyconnectederror)

When a connector is already connected.

ts

    import { ConnectorAlreadyConnectedError } from '@wagmi/vue'

### ConnectorChainMismatchError [‚Äã](#connectorchainmismatcherror)

When the Wagmi Config is out-of-sync with the connector's active chain ID. This is rare and likely an upstream wallet issue.

ts

    import { ConnectorChainMismatchError } from '@wagmi/vue'

### ChainNotConfiguredError [‚Äã](#chainnotconfigurederror)

When a chain is not configured. You likely need to add the chain to [`Config['chains']`](https://wagmi.sh/vue/api/createConfig#chains).

ts

    import { ChainNotConfiguredError } from '@wagmi/vue'

### ConnectorNotConnectedError [‚Äã](#connectornotconnectederror)

When a connector is not connected.

ts

    import { ConnectorNotConnectedError } from '@wagmi/vue'

### ConnectorNotFoundError [‚Äã](#connectornotfounderror)

When a connector is not found or able to be used.

ts

    import { ConnectorNotFoundError } from '@wagmi/vue'

### ConnectorUnavailableReconnectingError [‚Äã](#connectorunavailablereconnectingerror)

During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.

ts

    import { ConnectorUnavailableReconnectingError } from '@wagmi/vue'

Connector [‚Äã](#connector)
-------------------------

### ProviderNotFoundError [‚Äã](#providernotfounderror)

When a connector's provider is not found or able to be used.

ts

    import { ProviderNotFoundError } from '@wagmi/vue'

### SwitchChainNotSupportedError [‚Äã](#switchchainnotsupportederror)

When switching chains is not supported by connectors.

ts

    import { SwitchChainNotSupportedError } from '@wagmi/vue'</content>
</page>

<page>
  <title>deserialize | Wagmi</title>
  <url>https://wagmi.sh/vue/api/utilities/deserialize</url>
  <content>Deserialize function that supports `bigint` and `Map`.

Import [‚Äã](#import)
-------------------

ts

    import { deserialize } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { deserialize } from '@wagmi/vue'
    
    const result = deserialize('{"foo":"wagmi","bar":{"__type":"bigint","value":"123"}}')

Parameters [‚Äã](#parameters)
---------------------------

### value [‚Äã](#value)

`string`

The string to deserialize.

### reviver [‚Äã](#reviver)

`(key: string, value: any) => any`

A custom reviver function for handling standard values.

Return Type [‚Äã](#return-type)
-----------------------------

`unknown`

Parsed value.</content>
</page>

<page>
  <title>serialize | Wagmi</title>
  <url>https://wagmi.sh/vue/api/utilities/serialize</url>
  <content>Serialize function that supports `bigint` and `Map`.

Import [‚Äã](#import)
-------------------

ts

    import { serialize } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

ts

    import { serialize } from '@wagmi/vue'
    
    const result = serialize({ foo: 'wagmi', bar: 123n })

Parameters [‚Äã](#parameters)
---------------------------

### value [‚Äã](#value)

`any`

The value to stringify.

### replacer [‚Äã](#replacer)

`(key: string, value: any) => any`

A custom replacer function for handling standard values.

### indent [‚Äã](#indent)

`number | null | undefined`

The number of spaces to indent the output by.

### circularReplacer [‚Äã](#circularreplacer)

A custom replacer function for handling circular values.

Return Type [‚Äã](#return-type)
-----------------------------

`string`

Stringified value.</content>
</page>

<page>
  <title>useSimulateContract | Wagmi</title>
  <url>https://wagmi.sh/vue/api/composables/useSimulateContract</url>
  <content>Composable for simulating/validating a contract interaction.

Import [‚Äã](#import)
-------------------

ts

    import { useSimulateContract } from '@wagmi/vue'

Usage [‚Äã](#usage)
-----------------

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

Parameters [‚Äã](#parameters)
---------------------------

ts

    import { type UseSimulateContractParameters } from '@wagmi/vue'

### abi [‚Äã](#abi)

`Abi | undefined`

The contract's ABI. Check out the [TypeScript docs](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) for how to set up ABIs for maximum type inference and safety.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi, 
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### accessList [‚Äã](#accesslist)

`AccessList | undefined`

The access list.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      accessList: [{ 
        address: '0x1', 
        storageKeys: ['0x1'], 
      }], 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### account [‚Äã](#account)

`Account | undefined`

Account to use when calling the contract (`msg.sender`). Throws if account is not found on [`connector`](#connector).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      account: '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### address [‚Äã](#address)

`Address | undefined`

The contract's address.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### args [‚Äã](#args)

`readonly unknown[] | undefined`

*   Arguments to pass when calling the contract.
*   Inferred from [`abi`](#abi) and [`functionName`](#functionname).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [ 
        '0xd2135CfB216b74109775236E36d4b433F1DF507B', 
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', 
        123n, 
      ], 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### blockNumber [‚Äã](#blocknumber)

`bigint | undefined`

Block number to call contract at.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      blockNumber: 17829139n, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### blockTag [‚Äã](#blocktag)

`'latest' | 'earliest' | 'pending' | 'safe' | 'finalized' | undefined`

Block tag to call contract at.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      blockTag: 'safe', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### chainId [‚Äã](#chainid)

`config['chains'][number]['id'] | undefined`

ID of chain to use when fetching data.

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { mainnet } from 'wagmi/chains'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      chainId: mainnet.id, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### config [‚Äã](#config)

`Config | undefined`

[`Config`](https://wagmi.sh/vue/api/createConfig#config) to use instead of retrieving from the [`WagmiPlugin`](https://wagmi.sh/vue/api/WagmiPlugin).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      config, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### connector [‚Äã](#connector)

`Connector | undefined`

[Connector](https://wagmi.sh/vue/api/connectors) to simulate transaction with.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useConnectorClient, useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const { data: connector } = useConnectorClient()
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      connector, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### dataSuffix [‚Äã](#datasuffix)

`` `0x${string}` | undefined ``

Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f).

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      dataSuffix: '0xdeadbeef', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### functionName [‚Äã](#functionname)

`string | undefined`

*   Function to call on the contract.
*   Inferred from [`abi`](#abi).

index.vueabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f', 
      functionName: 'transferFrom', 
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### gas [‚Äã](#gas)

`bigint | undefined`

Gas provided for transaction execution.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      gas: parseGwei('20'), 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### gasPrice [‚Äã](#gasprice)

`bigint | undefined`

The price in wei to pay per gas. Only applies to [Legacy Transactions](https://viem.sh/docs/glossary/terms.html#legacy-transaction).

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      gasPrice: parseGwei('20'), 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxFeePerGas [‚Äã](#maxfeepergas)

`bigint | undefined`

Total fee per gas in wei, inclusive of [`maxPriorityFeePerGas`](#maxPriorityFeePerGas). Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      maxFeePerGas: parseGwei('20'), 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### maxPriorityFeePerGas [‚Äã](#maxpriorityfeepergas)

`bigint | undefined`

Max priority fee per gas in wei. Only applies to [EIP-1559 Transactions](https://viem.sh/docs/glossary/terms.html#eip-1559-transaction).

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { parseGwei } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      maxFeePerGas: parseGwei('20'),
      maxPriorityFeePerGas: parseGwei('2'), 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

* * *

### nonce [‚Äã](#nonce)

`number`

Unique number identifying this transaction.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      nonce: 123, 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### type [‚Äã](#type)

`'legacy' | 'eip1559' | 'eip2930' | undefined`

Optional transaction request type to narrow parameters.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      type: 'eip1559', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### value [‚Äã](#value)

`bigint | undefined`

Value in wei sent with this transaction.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { parseEther } from 'viem'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      value: parseEther('0.01'), 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

### scopeKey [‚Äã](#scopekey)

`string | undefined`

Scopes the cache to a given context. Composables that have identical context will share the same cache.

index.tsabi.tsconfig.ts

vue

    <script setup lang="ts">
    import { useSimulateContract } from '@wagmi/vue'
    import { abi } from './abi'
    import { config } from './config'
    
    const result = useSimulateContract({
      abi,
      address: '0x6b175474e89094c44da98b954eedeac495271d0f',
      functionName: 'transferFrom',
      args: [
        '0xd2135CfB216b74109775236E36d4b433F1DF507B',
        '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
        123n,
      ],
      scopeKey: 'foo', 
    })
    </script>

ts

    export const abi = [
      {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
      {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ] as const

ts

    import { http, createConfig } from '@wagmi/vue'
    import { mainnet, sepolia } from '@wagmi/vue/chains'
    
    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    })

  

* * *

### query [‚Äã](#query)

TanStack Query parameters. See the [TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery) for more info.

Wagmi does not support passing all TanStack Query parameters

TanStack Query parameters, like `queryFn` and `queryKey`, are used internally to make Wagmi work and you cannot override them. Check out the [source](https://github.com/wevm/wagmi/blob/main/packages/react/src/types/properties.ts#L27) to see what parameters are not supported. All parameters listed below are supported.

#### enabled [‚Äã](#enabled)

`boolean | undefined`

*   Set this to `false` to disable this query from automatically running.
*   Can be used for [Dependent Queries](https://tanstack.com/query/v5/docs/react/guides/dependent-queries).

#### gcTime [‚Äã](#gctime)

`number | Infinity | undefined`

*   Defaults to `5 * 60 * 1000` (5 minutes) or `Infinity` during SSR
*   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
*   If set to `Infinity`, will disable garbage collection

#### initialData [‚Äã](#initialdata)

`SimulateContractReturnType | (() => SimulateContractReturnType) | undefined`

*   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
*   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
*   Initial data is considered stale by default unless a `staleTime` has been set.
*   `initialData` **is persisted** to the cache

#### initialDataUpdatedAt [‚Äã](#initialdataupdatedat)

`number | ((() => number | undefined)) | undefined`

If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.

#### meta [‚Äã](#meta)

`Record<string, unknown> | undefined`

If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the `query` is available, and is also part of the `QueryFunctionContext` provided to the `queryFn`.

#### networkMode [‚Äã](#networkmode)

`online' | 'always' | 'offlineFirst' | undefined`

*   Defaults to `'online'`
*   see [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

#### notifyOnChangeProps [‚Äã](#notifyonchangeprops)

`string[] | 'all' | (() => string[] | 'all') | undefined`

*   If set, the component will only re-render if any of the listed properties change.
*   If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
*   If set to `'all'`, the component will opt-out of smart tracking and re-render whenever a query is updated.
*   If set to a function, the function will be executed to compute the list of properties.
*   By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.

#### placeholderData [‚Äã](#placeholderdata)

`SimulateContractReturnType | ((previousValue: SimulateContractReturnType | undefined; previousQuery: Query | undefined) => SimulateContractReturnType) | undefined`

*   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
*   `placeholderData` is **not persisted** to the cache
*   If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.

#### queryClient [‚Äã](#queryclient)

`QueryClient | undefined`

Use this to use a custom `QueryClient`. Otherwise, the one from the nearest context will be used.

#### refetchInterval [‚Äã](#refetchinterval)

`number | false | ((data: SimulateContractReturnType | undefined, query: Query) => number | false | undefined) | undefined`

*   If set to a number, all queries will continuously refetch at this frequency in milliseconds
*   If set to a function, the function will be executed with the latest data and query to compute a frequency

#### refetchIntervalInBackground [‚Äã](#refetchintervalinbackground)

`boolean | undefined`

If set to `true`, queries that are set to continuously refetch with a `refetchInterval` will continue to refetch while their tab/window is in the background

#### refetchOnMount [‚Äã](#refetchonmount)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on mount if the data is stale.
*   If set to `false`, the query will not refetch on mount.
*   If set to `'always'`, the query will always refetch on mount.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnReconnect [‚Äã](#refetchonreconnect)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on reconnect if the data is stale.
*   If set to `false`, the query will not refetch on reconnect.
*   If set to `'always'`, the query will always refetch on reconnect.
*   If set to a function, the function will be executed with the query to compute the value

#### refetchOnWindowFocus [‚Äã](#refetchonwindowfocus)

`boolean | 'always' | ((query: Query) => boolean | 'always') | undefined`

*   Defaults to `true`
*   If set to `true`, the query will refetch on window focus if the data is stale.
*   If set to `false`, the query will not refetch on window focus.
*   If set to `'always'`, the query will always refetch on window focus.
*   If set to a function, the function will be executed with the query to compute the value

#### retry [‚Äã](#retry)

`boolean | number | ((failureCount: number, error: SimulateContractErrorType) => boolean) | undefined`

*   If `false`, failed queries will not retry by default.
*   If `true`, failed queries will retry infinitely.
*   If set to a `number`, e.g. `3`, failed queries will retry until the failed query count meets that number.
*   Defaults to `3` on the client and `0` on the server

#### retryDelay [‚Äã](#retrydelay)

`number | ((retryAttempt: number, error: SimulateContractErrorType) => number) | undefined`

*   This function receives a `retryAttempt` integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
*   A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff.
*   A function like `attempt => attempt * 1000` applies linear backoff.

#### retryOnMount [‚Äã](#retryonmount)

`boolean | undefined`

If set to `false`, the query will not be retried on mount if it contains an error. Defaults to `true`.

#### select [‚Äã](#select)

`((data: SimulateContractReturnType) => unknown) | undefined`

This option can be used to transform or select a part of the data returned by the query function. It affects the returned `data` value, but does not affect what gets stored in the query cache.

#### staleTime [‚Äã](#staletime)

`number | Infinity | undefined`

*   Defaults to `0`
*   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
*   If set to `Infinity`, the data will never be considered stale

#### structuralSharing [‚Äã](#structuralsharing)

`boolean | (((oldData: SimulateContractReturnType | undefined, newData: SimulateContractReturnType) => SimulateContractReturnType)) | undefined`

*   Defaults to `true`
*   If set to `false`, structural sharing between query results will be disabled.
*   If set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.

Return Type [‚Äã](#return-type)
-----------------------------

ts

    import { type UseSimulateContractReturnType } from '@wagmi/vue'

The return type's [`data`](#data) property is inferrable via the combination of [`abi`](#abi), [`functionName`](#functionname), and [`args`](#args). Check out the [TypeScript docs](https://wagmi.sh/vue/typescript#const-assert-abis-typed-data) for more info.

  

* * *

[TanStack Query query docs](https://tanstack.com/query/v5/docs/react/reference/useQuery)

### data [‚Äã](#data)

`SimulateContractReturnType`

*   The last successfully resolved data for the query.
*   Defaults to `undefined`.

### dataUpdatedAt [‚Äã](#dataupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'success'`.

### error [‚Äã](#error)

`null | SimulateContractErrorType`

*   The error object for the query, if an error was thrown.
*   Defaults to `null`

### errorUpdatedAt [‚Äã](#errorupdatedat)

`number`

The timestamp for when the query most recently returned the `status` as `'error'`.

### errorUpdateCount [‚Äã](#errorupdatecount)

`number`

The sum of all errors.

### failureCount [‚Äã](#failurecount)

`number`

*   The failure count for the query.
*   Incremented every time the query fails.
*   Reset to `0` when the query succeeds.

### failureReason [‚Äã](#failurereason)

`null | SimulateContractErrorType`

*   The failure reason for the query retry.
*   Reset to `null` when the query succeeds.

### fetchStatus [‚Äã](#fetchstatus)

`'fetching' | 'idle' | 'paused'`

*   `fetching` Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
*   `paused` The query wanted to fetch, but has been `paused`.
*   `idle` The query is not fetching.
*   See [Network Mode](https://tanstack.com/query/v5/docs/react/guides/network-mode) for more information.

### isError / isPending / isSuccess [‚Äã](#iserror-ispending-issuccess)

`boolean`

Boolean variables derived from [`status`](#status).

### isFetched [‚Äã](#isfetched)

`boolean`

Will be `true` if the query has been fetched.

### isFetchedAfterMount [‚Äã](#isfetchedaftermount)

`boolean`

*   Will be `true` if the query has been fetched after the component mounted.
*   This property can be used to not show any previously cached data.

### isFetching / isPaused [‚Äã](#isfetching-ispaused)

`boolean`

Boolean variables derived from [`fetchStatus`](#fetchstatus).

### isLoading [‚Äã](#isloading)

`boolean`

*   Is `true` whenever the first fetch for a query is in-flight
*   Is the same as `isFetching && isPending`

### isLoadingError [‚Äã](#isloadingerror)

`boolean`

Will be `true` if the query failed while fetching for the first time.

### isPlaceholderData [‚Äã](#isplaceholderdata)

`boolean`

Will be `true` if the data shown is the placeholder data.

### isRefetchError [‚Äã](#isrefetcherror)

`boolean`

Will be `true` if the query failed while refetching.

### isRefetching [‚Äã](#isrefetching)

`boolean`

*   Is `true` whenever a background refetch is in-flight, which _does not_ include initial `'pending'`.
*   Is the same as `isFetching && !isPending`

### isStale [‚Äã](#isstale)

`boolean`

Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.

### refetch [‚Äã](#refetch)

`(options: { cancelRefetch?: boolean | undefined; throwOnError?: boolean | undefined }) => Promise<UseQueryResult<SimulateContractReturnType, SimulateContractErrorType>>`

*   A function to manually refetch the query.
*   `throwOnError`
    *   When set to `true`, an error will be thrown if the query fails.
    *   When set to `false`, an error will be logged if the query fails.
*   `cancelRefetch`
    *   When set to `true`, a currently running request will be cancelled before a new request is made.
    *   When set to `false`, no refetch will be made if there is already a request running.
    *   Defaults to `true`

### status [‚Äã](#status)

`'error' | 'pending' | 'success'`

*   `pending` if there's no cached data and no query attempt was finished yet.
*   `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
*   `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.

Type Inference [‚Äã](#type-inference)
-----------------------------------

With [`abi`](#abi) setup correctly, TypeScript will infer the correct types for [`functionName`](#functionname), [`args`](#args), and [`value`](#value). See the Wagmi [TypeScript docs](https://wagmi.sh/vue/typescript) for more information.

TanStack Query [‚Äã](#tanstack-query)
-----------------------------------

ts

    import {
      type SimulateContractData,
      type SimulateContractOptions,
      type SimulateContractQueryFnData,
      type SimulateContractQueryKey,
      simulateContractQueryKey,
      simulateContractQueryOptions,
    } from '@wagmi/vue/query'

Action [‚Äã](#action)
-------------------

*   [`simulateContract`](https://wagmi.sh/core/api/actions/simulateContract)</content>
</page>